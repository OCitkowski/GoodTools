
Функция УбитьДействующиеWINDOWS(Процесы, БезПодтвержденияПользователя = Истина) Экспорт
	
	Перем Код;
	
	Network = Новый COMОбъект("WScript.Network");
	
	ПриложенияСтрокой = "";
	Счетчик = 1;
	
	Для Каждого Строка Из Процесы Цикл
		
		ПриложенияСтрокой = СтрШаблон("%1%2",
					?(Счетчик = 1, "", ПриложенияСтрокой),
					?(Счетчик = 1, Строка.Ключ, " и " + Строка(Строка.Ключ)));
					
		Счетчик = Счетчик+1;
	 
	КонецЦикла;

	Если БезПодтвержденияПользователя Или e_ОбщегоНазначения.ВопросПолучитьПодтверждение(СтрШаблон("Все документы %1 будут принудительно закрыты. Продолжить?", ПриложенияСтрокой), , , "Внимание")Тогда 
			
			ПараметрыЗапуска = Новый Структура("ИмяПользователя, Домен, Процесы", Network.UserName, Network.UserDomain, Процесы);  //Переписать на процесы внутри одной срокой
			
			#Если Клиент Тогда
				
				КомандаСистемы(ПолучитьКоманднуюСтрокуДляУдаленияДействующихПроцесов(ПараметрыЗапуска));
				//ЗапуститьПриложение(ПолучитьКоманднуюСтрокуДляУдаленияДействующихПроцесов(ПараметрыЗапуска),, Истина, Код);  // Не працюэ, вбиваэ лише першу програму, хоча сформованна строка працюэ в ручному режимы.
				
			#Иначе
				
				WshShell=Новый COMОбъект("Wscript.Shell");
				WshShell.run(ПолучитьКоманднуюСтрокуДляУдаленияДействующихПроцесов(ПараметрыЗапуска));
				
			#КонецЕсли
		
		Возврат Истина;
		
	Иначе
		
		Возврат Ложь;
		
	КонецЕсли;
	
КонецФункции

Функция ПолучитьКоманднуюСтрокуДляУдаленияДействующихПроцесов(ПараметрыЗапуска)
	
	СтрокаКоманды = "";
	Счетчик = 1;
	
	Для Каждого Строка Из ПараметрыЗапуска.Процесы Цикл
		
		//tasklist /fi "username eq citkowski_ov" /fi "Imagename eq WINWORD.exe" && taskkill /F /fi "USERNAME eq TOVPEK\citkowski_ov" /IM WINWORD.exe  - Приклад
		ПоискДействующихПроцесов = СтрШаблон("echo Идет поиск, ждите... && tasklist /fi %1username eq %2%3 /fi %4Imagename eq %5%6",
										Символ(34),
										ПараметрыЗапуска.ИмяПользователя,
										Символ(34),
										Символ(34),
										Строка.Значение,
										Символ(34)); //tasklist /fi "username eq citkowski_ov" /fi "Imagename eq WINWORD.exe" - Приклад

		УдалениеДействующихПроцесов = СтрШаблон("echo Идет закрытие, ждите... && taskkill /F /fi %1USERNAME eq %2\%3%4 /IM %5",
										Символ(34),
										ПараметрыЗапуска.Домен,
										ПараметрыЗапуска.ИмяПользователя,
										Символ(34),
										Строка.Значение); //taskkill /F /fi "USERNAME eq TOVPEK\citkowski_ov" /IM WINWORD.exe - Приклад 										
										
		СтрокаКоманды = СтрШаблон("%1%2%3%4%5",
						?(Счетчик = 1, "echo Подождите завершения, окно закрывается автоматически...", СтрокаКоманды),
						?(Счетчик = 1, " && ", " && "),
						ПоискДействующихПроцесов,
						" && ",
						УдалениеДействующихПроцесов);
						
		Счетчик = Счетчик + 1;
		
	КонецЦикла;
	
	Возврат  СтрокаКоманды

КонецФункции 

Функция ПолучитьНомерСеансаПользователя()
	
	Для Каждого СеансИБ Из ПолучитьСеансыИнформационнойБазы() Цикл
		Если СеансИБ.Пользователь.Имя=ИмяПользователя() Тогда
			Возврат СеансИБ.НомерСеанса;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Неопределено
	
КонецФункции

Функция ПолучитьРазностьДат(ДатаНач, ДатаКон, ТипРазности) Экспорт
	
	Запрос = Новый Запрос;
	Запрос.Текст = "
	|ВЫБРАТЬ
	|    РАЗНОСТЬДАТ(&ДатаНач, &ДатаКон, "+ТипРазности+") КАК РазностьДат"
	;
	
	Запрос.УстановитьПараметр("ДатаНач", ДатаНач);
	Запрос.УстановитьПараметр("ДатаКон", ДатаКон);
	
	Выборка = Запрос.Выполнить().Выбрать();
	Выборка.Следующий();
	
	Возврат Выборка.РазностьДат;
	
КонецФункции


  
    
ToDo
        
    #Если Клиент Тогда
	ОткрытьЗначение(значениеПоляРасшифровки.Значение);
	#Иначе
    лгорпн
    #КонецЕсли

#Область Примітки
//ЗапуститьПриложение(путьКПрограмме, рабочийКаталог);
//ЗапуститьПриложение(путьКПрограмме, рабочийКаталог);
//Выполнить("Сообщить("1с компилятор");");
//СистемнаяИнформация
//УстановитьПривилегированныйРежим(установить = Истина);//лише файловий варіант ІБ
//УстановитьМонопольныйРежим(Истина);//Ложь

//адрес = ПоместитьВоВременноеХранилище(данные, адрес);
//отчетОбъект = РеквизитФормыВЗначение("Отчет");
//отчетОбъект.Синоним = отчетОбъект.Метаданные().Синоним;
//ЗначениеВРеквизитФормы(отчетОбъект, "Отчет");

//Документы.ТипВсеСсылки()
//ПривестиЗначение()
//Справочники.ТипВсеСсылки().СодержитТип(ТипЗнч(Справочники.Банки.ПустаяСсылка()))

//#Если Клиент Тогда
//Состояние
//ОбработкаПрерыванияПользователя
//Сигнал
//Сообщить
//Предупреждение
//ПоказатьОповещениеПользователя
//КодВозвратаДиалога
//Вопрос
//ВвестиСтроку
//ВвестиЧисло
//ВвестиДату
//ВвестиЗначение(Склад, "Выберите склад отправитель", Тип("СправочникСсылка.Склады"))
//ОткрытьЗначение
//ОписаниеОповещения
//ЗапуститьПриложение
//#КонецЕсли

#КонецОбласти


#Область Стрічки

Функция СтрокаCamelStyleПолучить(строка) Экспорт
	
	Перем новаяСтрока;
	Перем символПробелаОсновной;
	
	символПробелаОсновной = Символ(32);
	
	новаяСтрока = "";
	
	Для Каждого слово из СтрокаРазбитьНаСоставляющие(СокрЛП(строка), символПробелаОсновной) цикл
		новаяСтрока = новаяСтрока + ТРег(слово);
	КонецЦикла;
	
	Возврат новаяСтрока
	
КонецФункции

Функция СтрокаИзCamelStyleПолучить(строкаCamelStyle, символРазделителя = Неопределено, какВПредложениях = Истина) Экспорт
	
	Перем длинаСтроки, строкаМассивСимволов, символ, следующийСимвол, слово, результирующаяСтрока;
	
	Если символРазделителя = Неопределено Тогда
		символРазделителя = Символ(32);
	КонецЕсли;
	
	длинаСтроки = СтрДлина(строкаCamelStyle);
	строкаМассивСимволов = СтрокаМассивСимволовПолучить(строкаCamelStyle);
	результирующаяСтрока = "";
	слово = "";
	
	Для итератор = 0 по длинаСтроки - 1 цикл
		
		символ = строкаМассивСимволов.Получить(итератор);
		следующийСимвол =
			?(итератор < длинаСтроки - 1,
			строкаМассивСимволов.Получить(итератор + 1),
			Неопределено);
			
		Если ВРег(символ) <> символ Тогда
			слово = слово + символ;
			Продолжить
		КонецЕсли;
		
		Если НЕ ПустаяСтрока(слово) Тогда
			
			Если СтрДлина(слово) = 1 И ВРег(следующийСимвол) = следующийСимвол
				ИЛИ итератор = длинаСтроки - 1 И ВРег(символ) = символ Тогда // абревіатура
				слово = слово + символ;
				Продолжить
			КонецЕсли;
			
			Если какВПредложениях = Истина И ПустаяСтрока(результирующаяСтрока) Тогда
				
				результирующаяСтрока = результирующаяСтрока + слово + символРазделителя;
				
			Иначе
				
				результирующаяСтрока =
					результирующаяСтрока +
					?(СтрДлина(слово) = 1 И ВРег(следующийСимвол) = следующийСимвол, // абревіатура
						слово,
						НРег(слово) + символРазделителя);
					
			КонецЕсли;
			
		КонецЕсли;
		
		слово = символ;
		
	КонецЦикла;
	
	// додавання останнього слова
	
	Если ВРег(слово) = слово Тогда // абревіатура
		
		результирующаяСтрока = результирующаяСтрока + слово;
		
	Иначе
		
		результирующаяСтрока = 
			результирующаяСтрока +
			?(какВПредложениях = Истина И ПустаяСтрока(результирующаяСтрока),
				слово,
				НРег(слово));
				
	КонецЕсли;
	
	Возврат результирующаяСтрока
	
КонецФункции

Функция СтрокаМассивСимволовПолучить(строка) Экспорт
	
	Перем итератор, символ, строкаМассив;
	
	строкаМассив = Новый Массив;
	итератор = 0;
	
	Пока итератор < СтрДлина(строка) цикл
		итератор = итератор + 1;
		символ = Сред(строка, итератор, 1);
		строкаМассив.Добавить(символ);
	КонецЦикла;
	
	Возврат строкаМассив
	
КонецФункции

Функция СтрокаУбратьНедопустимыеСимволы(строка, строкаНедопустимыхСимволов = ".,:;?!\ /*±+-[`']№", символЗамены = "") Экспорт
	
	Перем возвращаемаяСтрока, счетчик, индекс;
	Перем символПробелаОсновной, символПробелаАльтернативный;
	
	символПробелаОсновной = Символ(32);
	символПробелаАльтернативный = Символ(160);
	
	Если ПустаяСтрока(символЗамены) Тогда
		Если Найти(строка, символПробелаОсновной) = 0 Тогда
			возвращаемаяСтрока = строка;
		Иначе
			возвращаемаяСтрока = СтрЗаменить(строка, символПробелаОсновной, "");
		КонецЕсли;
		Если Найти(строка, символПробелаАльтернативный) = 0 Тогда
			возвращаемаяСтрока = строка;
		Иначе
			возвращаемаяСтрока = СтрЗаменить(строка, символПробелаАльтернативный, "");
		КонецЕсли;
		
	Иначе
		возвращаемаяСтрока = строка;
	КонецЕсли;
	
	Для счетчик = 1 по СтрДлина(строкаНедопустимыхСимволов) цикл
		символ = Сред(строкаНедопустимыхСимволов, счетчик, 1);
		возвращаемаяСтрока = СтрЗаменить(возвращаемаяСтрока, символ, символЗамены);
	КонецЦикла;
	
	Возврат возвращаемаяСтрока
	
КонецФункции

//ОбщегоНазначения.РазложитьСтрокуВМассивПодстрок(строка, строкаРазделителя);
Функция СтрокаРазбитьНаСоставляющие(строка, символРазделителя = Неопределено, удалитьНезначащиеПробелы = Ложь) Экспорт
	
	Перем массивСоставляющихСтрок, многострочнаяСтрока, количествоСоставляющих, счетчик;
	Перем символПробелаОсновной;
	
	Если строка = Неопределено ИЛИ ПустаяСтрока(СокрЛП(строка)) Тогда Возврат Новый Массив конецЕсли;
	
	символПробелаОсновной = Символ(32);
	
	массивСоставляющихСтрок = Новый Массив;
	
	Если символРазделителя = Неопределено Тогда
		Если СтрНайти(строка, ",") <> 0 Тогда
			символРазделителя = ",";
		Иначе
			символРазделителя = символПробелаОсновной;
		КонецЕсли;
	КонецЕсли;
	
	многострочнаяСтрока = СтрЗаменить(СокрЛП(строка), символРазделителя, Символы.ПС);
	количествоСоставляющих = СтрЧислоСтрок(многострочнаяСтрока);
	
	Для счетчик = 1 по количествоСоставляющих цикл
		массивСоставляющихСтрок.Добавить(
			?(удалитьНезначащиеПробелы,
			СокрЛП(СтрПолучитьСтроку(многострочнаяСтрока, счетчик)),
			СтрПолучитьСтроку(многострочнаяСтрока, счетчик)));
	КонецЦикла;
	
	Возврат массивСоставляющихСтрок
	
КонецФункции

Процедура СтрокаЗаменитьПодстрокуСодержащуюТекст(строка, текстВПодстроке, заменительПодстроки = "", разделитель = "|") Экспорт
	Перем подстроки, индекс;
	
	подстроки = СтрЗаменить(строка, разделитель, Символы.ПС);
	строка = "";
	
	Для индекс = 1 по СтрЧислоСтрок(подстроки) цикл
		подстрока = СтрПолучитьСтроку(подстроки, индекс);
		
		Если Найти(подстрока, текстВПодстроке) > 0 Тогда
			
			Если индекс = 1 Тогда
				строка = строка + заменительПодстроки;
			Иначе
				строка = строка + Символы.ПС + заменительПодстроки;
			КонецЕсли;
			
			Продолжить;
			
		КонецЕсли;
		
		Если индекс = 1 Тогда
			строка = строка + подстрока;
		Иначе
			строка = строка + Символы.ПС + подстрока;
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры

Функция СтрокаПолучитьHTML(строка) Экспорт
	
	Возврат СтрЗаменить(строка, Символы.ПС, "<br>");
	
КонецФункции

Функция ЧислоПодтвердитьВводНеобходимойРазрядности(разрядностьЧислом, Знач значение = Неопределено, заголовокДиалога = "") Экспорт

	Пока Истина цикл
		значение = Число(ЧислоПолучитьСтрокуЦифр(значение));
		
		Если ЧислоПолучитьРазрядность(значение) = разрядностьЧислом Тогда Возврат значение конецЕсли;
		
		#Если Клиент Тогда
		Если НЕ ВвестиЧисло(значение, заголовокДиалога, разрядностьЧислом, 0) Тогда Возврат Неопределено конецЕсли;
		#Иначе
		Возврат Неопределено;
		#КонецЕсли

	КонецЦикла;
	
КонецФункции

#КонецОбласти


#Область Друк

Функция СтруктураСведенийОрганизацииПолучить(организация, период = Неопределено, кодЯзыка = Неопределено) Экспорт
	
	Перем сведенияОбОрганизации;
	
	Если период = Неопределено Тогда
		период = ТекущаяДата();
	КонецЕсли;
	
	Если кодЯзыка = Неопределено Тогда
		кодЯзыка = КодЯзыкаПользователяПолучить(Истина);
	КонецЕсли;
	
	ответственныеЛицаОрганизации = ФормированиеПечатныхФормСервер.ОтветственныеЛицаОрганизаций(организация, период);
	сведенияОбОрганизации = УправлениеКонтактнойИнформацией.СведенияОЮрФизЛице(организация, период, Истина,, кодЯзыка);
	
	представлениенРасчетногоСчета = СтрШаблон("р/р %1 в %2, МФО %3",
		сведенияОбОрганизации.НомерСчета,
		сведенияОбОрганизации.Банк,
		СокрЛП(сведенияОбОрганизации.МФО));
	представлениеОрганизацияБанковскийСчетДляРасчетовСФСС = СтрШаблон(
		"%1 %2, %3",
		ФормированиеПечатныхФормСервер.ОписаниеОрганизации(сведенияОбОрганизации, "НомерСчета", Истина, кодЯзыка),
		ФормированиеПечатныхФормСервер.ОписаниеОрганизации(сведенияОбОрганизации, "Банк", Истина, кодЯзыка),
		ФормированиеПечатныхФормСервер.ОписаниеОрганизации(сведенияОбОрганизации, "МФО", Истина, кодЯзыка));
	представлениеОрганизацияАдрес = ФормированиеПечатныхФормСервер.ОписаниеОрганизации(сведенияОбОрганизации, "ЮридическийАдрес", Истина, кодЯзыка);
	представлениеОрганизацияЕДРПОУ = ФормированиеПечатныхФормСервер.ОписаниеОрганизации(сведенияОбОрганизации, "КодПоЕДРПОУ", Истина, кодЯзыка);
	
	Возврат Новый Структура(
		"ОтветственныеЛицаОрганизации, СведенияОбОрганизации, БанковскийСчет, РасчетныйСчет, ЮридическийАдрес, КодПоЕДРПОУ, " +
		"РуководительФИО, РуководительДолжность, Дата",
		ответственныеЛицаОрганизации,
		сведенияОбОрганизации,
		представлениеОрганизацияБанковскийСчетДляРасчетовСФСС,
		представлениенРасчетногоСчета,
		представлениеОрганизацияАдрес,
		представлениеОрганизацияЕДРПОУ,
		ответственныеЛицаОрганизации.РуководительПредставление,
		ответственныеЛицаОрганизации.РуководительДолжность,
		ПолучитьДатуОт(период, Истина, кодЯзыка))
		
КонецФункции

Функция РежимИспользованияДиалогаПечатиНастройкаТекущегоПользователяОпределить() Экспорт
	
	Возврат
		?(НастройкаПользователяПолучить(ПланыВидовХарактеристик.НастройкиПользователей.СразуНаПринтер, Ложь),
		РежимИспользованияДиалогаПечати.НеИспользовать,
		РежимИспользованияДиалогаПечати.Использовать)
		
КонецФункции

Функция НастройкаТекущегоПользователяЯзыкФормированияПечатныхФормПолучить() Экспорт
	
	Возврат ЛокализацияПовтИсп.ПолучитьЯзыкФормированияПечатныхФормДокументов() //ПолучитьЯзыкФормированияПечатныхФормОтчетов
	
КонецФункции

Функция ФамилияИмяОтчествоСтруктураПолучить(наименованиеПолное) Экспорт
	
	Перем возвращаемаяСтруктура, составляющиеНаименования;
	Перем символПробелаОсновной, символПробелаАльтернативный, символРазделителя;
	
	символПробелаОсновной = Символ(32);
	символПробелаАльтернативный = Символ(160);
	
	возвращаемаяСтруктура = Новый Структура("Фамилия, Имя, Отчество");
	
	возвращаемаяСтруктура.Фамилия = "";
	возвращаемаяСтруктура.Имя = "";
	возвращаемаяСтруктура.Отчество = "";
	
	Если ПустаяСтрока(наименованиеПолное) Тогда возврат возвращаемаяСтруктура конецЕсли;
	
	символРазделителя =
		?(Найти(наименованиеПолное, символПробелаОсновной) > 0,
		символПробелаОсновной,
		символПробелаАльтернативный);
		
	составляющиеНаименования = СтрокаРазбитьНаСоставляющие(наименованиеПолное, символРазделителя);
	
	Если составляющиеНаименования = Неопределено ИЛИ составляющиеНаименования.Количество() = 0 Тогда возврат возвращаемаяСтруктура конецЕсли;
	
	возвращаемаяСтруктура.Фамилия = составляющиеНаименования[0];
	
	Если составляющиеНаименования.Количество() > 1 Тогда
		возвращаемаяСтруктура.Имя = составляющиеНаименования[1];
	КонецЕсли;
	
	Если составляющиеНаименования.Количество() > 2 Тогда
		возвращаемаяСтруктура.Отчество = составляющиеНаименования[2];
	КонецЕсли;
	
	Возврат возвращаемаяСтруктура
	
КонецФункции

Функция ФизлицоФамилияИмяОтчествоСтруктураПолучить(физЛицо, период = Неопределено, получатьИзРегистраСведений = Ложь) Экспорт
	
	Если получатьИзРегистраСведений Тогда
		
		Возврат ФормированиеПечатныхФормСервер.ФамилияИмяОтчество(
			физЛицо,
			?(период = Неопределено,
				ТекущаяДата(),
				период))
	Иначе
		
		Возврат ФамилияИмяОтчествоСтруктураПолучить(физЛицо.Наименование)
		
	КонецЕсли;
	
КонецФункции

Функция ФизЛицоФимилияИнициалыПолучить(физлицо, период = Неопределено, получатьИзРегистраСведений = Ложь) Экспорт
	
	Перем структураФИО;
	
	Если НЕ ЗначениеЗаполнено(физлицо) Тогда Возврат "" конецЕсли;
	
	Если период = Неопределено Тогда
		период = ТекущаяДата();
	КонецЕсли;
	
	структураФИО =
		?(получатьИзРегистраСведений,
		ФормированиеПечатныхФормСервер.ФамилияИмяОтчество(физлицо, период),
		ФамилияИмяОтчествоСтруктураПолучить(физЛицо.Наименование));
		
	Возврат ФормированиеПечатныхФормСервер.ПолучитьФамилиюИмяОтчество(структураФИО.Фамилия, структураФИО.Имя, структураФИО.Отчество)
	
КонецФункции

//ОбщегоНазначения.ПаспортныеДанные(Физлицо, Дата)
Функция СклонениеФИОPadegUA(Знач фио, падеж = 2, возвращатьВИменительномПадежеЕслиНеУдаетсяИнициализироватьКомпоненту = Ложь) Экспорт
	
	Перем имяCOMОбъекта, comОбъект, структураФИО;
	
	Если Тип("СправочникСсылка.ФизическиеЛица") = ТипЗнч(фио) Тогда
		
		структураФИО = ФормированиеПечатныхФормСервер.ФамилияИмяОтчество(фио, ТекущаяДата());
		
		фио = структураФИО.Фамилия;
		
		Если НЕ ПустаяСтрока(структураФИО.Имя) Тогда
			фио =
				?(ПустаяСтрока(фио),
				структураФИО.Имя,
				СтрШаблон("%1 %2", фио, структураФИО.Имя));
		КонецЕсли;
		
		Если НЕ ПустаяСтрока(структураФИО.Отчество) Тогда
			фио =
				?(ПустаяСтрока(фио),
				структураФИО.Отчество,
				СтрШаблон("%1 %2", фио, структураФИО.Отчество));
		КонецЕсли;
		
	КонецЕсли;
	
	Если ПустаяСтрока(фио) Тогда Возврат "" конецЕсли;
	
	имяCOMОбъекта = "Padeg_ua.Declension";
	
	Попытка
		
		comОбъект = Новый COMОбъект(имяCOMОбъекта);
		
	Исключение
		
		ОтобразитьСообщениеОбОшибке(ОписаниеОшибки(), ИнформацияОбОшибке(),, СтрШаблон("НЕ удалось подключить компоненту COM «%1».", имяCOMОбъекта));
		
		Возврат
			?(возвращатьВИменительномПадежеЕслиНеУдаетсяИнициализироватьКомпоненту,
			фио,
			Неопределено)
			
	КонецПопытки;
	
	фио = comОбъект.GetFIOPadegFS(фио, "", падеж);
	
	Возврат фио
	
КонецФункции

Функция СклонениеДолжностиPadegUA(представлениеДолжности, падеж = 2, возвращатьВИменительномПадежеЕслиНеУдаетсяИнициализироватьКомпоненту = Ложь) Экспорт
	
	Перем имяCOMОбъекта, comОбъект;
	
	имяCOMОбъекта = "Padeg_ua.Declension";
	
	Попытка
		
		comОбъект = Новый COMОбъект(имяCOMОбъекта);
		
		Возврат comОбъект.GetAppointmentPadeg(СокрЛП(представлениеДолжности), падеж)
		
	Исключение
		
		ОтобразитьСообщениеОбОшибке(ОписаниеОшибки(), ИнформацияОбОшибке(),, СтрШаблон("НЕ удалось подключить компоненту COM «%1».", имяCOMОбъекта));
		
		Возврат
			?(возвращатьВИменительномПадежеЕслиНеУдаетсяИнициализироватьКомпоненту,
			представлениеДолжности,
			Неопределено)
			
	КонецПопытки;
	
КонецФункции

Функция СклонениеФИОВнешнейКомпонентойКацапской(Знач фио, падеж = 2, возвращатьВИменительномПадежеЕслиНеУдаетсяИнициализироватьКомпоненту = Ложь) Экспорт
	
	Перем имяФайла, внешняяКомпонента, структураФИО, системнаяИнформация;
	
	Если Тип("СправочникСсылка.ФизическиеЛица") = ТипЗнч(фио) Тогда
		
		структураФИО = ФормированиеПечатныхФормСервер.ФамилияИмяОтчество(фио, ТекущаяДата());
		
		фио = структураФИО.Фамилия;
		
		Если НЕ ПустаяСтрока(структураФИО.Имя) Тогда
			фио =
				?(ПустаяСтрока(фио),
				структураФИО.Имя,
				СтрШаблон("%1 %2", фио, структураФИО.Имя));
		КонецЕсли;
		
		Если НЕ ПустаяСтрока(структураФИО.Отчество) Тогда
			фио =
				?(ПустаяСтрока(фио),
				структураФИО.Отчество,
				СтрШаблон("%1 %2", фио, структураФИО.Отчество));
		КонецЕсли;
		
	КонецЕсли;
	
	Если ПустаяСтрока(фио) Тогда Возврат "" конецЕсли;
	
	имяФайла = "NameDecl.dll";
	внешняяКомпонента = Неопределено;
	
	Попытка
		
		ЗагрузитьВнешнююКомпоненту(имяФайла);
		внешняяКомпонента = Новый("AddIn.NameDeclension");
		
	Исключение
		
		системнаяИнформация = Новый СистемнаяИнформация;
		текстИнформационногоСообщения = СтрШаблон(
			"НЕ удалось инициализировать внешнюю компоненту «Склонение ФИО».
			|Проверить наличие библиотеки кода С:\Program Files%1\1cv8\%2\bin\%3",
			?(ТипПлатформы.Windows_x86 = системнаяИнформация.ТипПлатформы,
				" (x86)",
				""),
			системнаяИнформация.ВерсияПриложения,
			имяФайла);
			
		ОтобразитьСообщениеОбОшибке(ОписаниеОшибки(), ИнформацияОбОшибке(),, текстИнформационногоСообщения);
		
		Возврат
			?(возвращатьВИменительномПадежеЕслиНеУдаетсяИнициализироватьКомпоненту,
			фио,
			Неопределено)
			
	КонецПопытки;
	
	Возврат внешняяКомпонента.Просклонять(фио, падеж)
	
КонецФункции

Функция ПериодПредставление(началоПериода, конецПериода, выводитьКакОписание = Ложь) Экспорт
	
	Возврат
		?(выводитьКакОписание,
		ОбщегоНазначения.ОписаниеПериода(началоПериода, конецПериода, Ложь,, Ложь),
		ПредставлениеПериода(началоПериода, конецПериода))
		
КонецФункции

Функция МесяцаРодительный(дата = Неопределено, кодЯзыка = Неопределено) Экспорт
	
	Перем форматДаты;

	форматДаты = "ДФ = 'dd MMMM yyyy'";
	
	Если дата = Неопределено Тогда
		дата = ТекущаяДата();
	КонецЕсли;
	
	Если кодЯзыка = Неопределено Тогда
		кодЯзыка = КодЯзыкаПользователяПолучить();
	КонецЕсли;
	
	форматДаты = "Л=" + кодЯзыка + "; "+ форматДаты;
	
	Возврат Прав(Лев(Формат(дата , форматДаты),
		СтрДлина(Формат(дата , форматДаты)) - 5),
		СтрДлина(Лев(Формат(дата, форматДаты),
		СтрДлина(Формат(дата , форматДаты)) - 5)) - 3)
		
КонецФункции

Функция ПолучитьДатуОт(дата = Неопределено, использоватьКавычкиНаЧисле = Ложь, кодЯзыка = Неопределено) Экспорт
	
	Перем символПробелаОсновной, число, числоДатаОт, месяцаДатаОт, год, годСокращенно;
	
	символПробелаОсновной = Символ(32);
	
	Если дата = Неопределено Тогда
		дата = ТекущаяДата();
	КонецЕсли;
	
	Если кодЯзыка = Неопределено Тогда
		кодЯзыка = КодЯзыкаПользователяПолучить();
	КонецЕсли;
	
	число = Формат(дата , "ДФ = 'd'");
	числоДатаОт =
		?(использоватьКавычкиНаЧисле, 
		СтрШаблон("«%1»", число),
		число);
	месяцаДатаОт = МесяцаРодительный(дата, кодЯзыка);
	год = Формат(дата , "ДФ = 'yyyy'");
	
	Если "uk" = кодЯзыка Тогда
		годСокращенно = "р";
	ИначеЕсли "ru" = кодЯзыка Тогда
		годСокращенно = "г";
	Иначе
		годСокращенно = "";
	КонецЕсли;
	
	Возврат числоДатаОт + символПробелаОсновной + месяцаДатаОт + символПробелаОсновной + год + символПробелаОсновной + годСокращенно + "."
	
КонецФункции

Функция ПроцентыЧислом(значение) Экспорт
	
	Возврат Число(Лев(Строка(значение), СтрДлина(Строка(значение)) - СтрДлина("%")))
	
КонецФункции

Функция ВесПрописью(значение, кодЯзыка = Неопределено) Экспорт
	
	Если кодЯзыка = Неопределено Тогда
		кодЯзыка = КодЯзыкаПользователяПолучить();
	КонецЕсли;
	
	Возврат
		?("ru" = кодЯзыка,
		ЧислоПрописью(значение, "Л = ru_RU; ДП = ЛОЖЬ", "тонна,тонны,тонн,ж,килограмм,килограмма,килограмм,м,3"),
		ЧислоПрописью(значение, "Л = uk_UA; ДП = ЛОЖЬ", "тонна,тонни,тонн,ж,кілограм,кілограма,кілограм,м,3"))
		
КонецФункции

Функция СуммаПрописью(значение, кодЯзыка = Неопределено) Экспорт
	
	Если кодЯзыка = Неопределено Тогда
		кодЯзыка = КодЯзыкаПользователяПолучить();
	КонецЕсли;
	
	Возврат
		?("ru" = кодЯзыка,
		ЧислоПрописью(значение, "Л = ru_RU; ДП = ИСТИНА", "гривна, гривны, гривен, м, копейка, копейки, копеек, ж, 2"),
		ЧислоПрописью(значение, "Л = uk_UA; ДП = ИСТИНА", "гривня, гривні, гривень, м, копійка, копійки, копійок, ж, 2"))
		
КонецФункции

Функция СуммаПоКурсуДокументаПолучить(суммаДокумента, курсДокумента, кратностьДокумента) Экспорт
	
	Возврат Окр(суммаДокумента * курсДокумента / кратностьДокумента, 2)
	
КонецФункции

#КонецОбласти


#Область КолекціїДанихТаблиціМасиви

#Область Універсальні_колекції_даних

Функция ДанныеСовпадают(Данные1, Данные2) Экспорт
	
	Перем староеЗначение, ключИЗначение, ключиНовогоСоответствия, индекс, колонка;
	
	Если ТипЗнч(Данные1) <> ТипЗнч(Данные2) Тогда Возврат Ложь конецЕсли;
	
	Если Тип("Структура") = ТипЗнч(Данные1)
		ИЛИ Тип("ФиксированнаяСтруктура") = ТипЗнч(Данные1) Тогда
		
		Если Данные1.Количество() <> Данные2.Количество() Тогда Возврат Ложь конецЕсли;
		
		Если Данные1.Количество() = 0 И Данные2.Количество() = 0 Тогда Возврат Истина конецЕсли;
		
		Для Каждого ключИЗначение из Данные1 цикл
			
			староеЗначение = Неопределено;
			
			Если НЕ Данные2.Свойство(ключИЗначение.Ключ, староеЗначение) ИЛИ НЕ ДанныеСовпадают(ключИЗначение.Значение, староеЗначение) Тогда Возврат Ложь конецЕсли;
			
		КонецЦикла;
		
		Возврат Истина;
		
	ИначеЕсли Тип("Соответствие") = ТипЗнч(Данные1) ИЛИ Тип("ФиксированноеСоответствие") = ТипЗнч(Данные1) Тогда
		
		Если Данные1.Количество() <> Данные2.Количество() Тогда Возврат Ложь конецЕсли;
		
		Если Данные1.Количество() = 0 И Данные2.Количество() = 0 Тогда Возврат Истина конецЕсли;
		
		ключиНовогоСоответствия = Новый Соответствие;
		
		Для Каждого ключИЗначение из Данные1 цикл
			
			ключиНовогоСоответствия.Вставить(ключИЗначение.Ключ, Истина);
			староеЗначение = Данные2.Получить(КлючИЗначение.Ключ);
			
			Если НЕ ДанныеСовпадают(ключИЗначение.Значение, староеЗначение) Тогда Возврат Ложь конецЕсли;
			
		КонецЦикла;
		
		Для Каждого ключИЗначение из Данные2 цикл
			Если КлючиНовогоСоответствия[КлючИЗначение.Ключ] = Неопределено Тогда Возврат Ложь конецЕсли;
		КонецЦикла;
		
		Возврат Истина;
		
	ИначеЕсли Тип("Массив") = ТипЗнч(Данные1) ИЛИ Тип("ФиксированныйМассив") = ТипЗнч(Данные1) Тогда
		
		Если Данные1.Количество() <> Данные2.Количество() Тогда Возврат Ложь конецЕсли;
		
		Если Данные1.Количество() = 0 И Данные2.Количество() = 0 Тогда Возврат Истина конецЕсли;
		
		индекс = Данные1.Количество() - 1;
		
		Пока индекс >= 0 цикл
			Если НЕ ДанныеСовпадают(Данные1.Получить(индекс), Данные2.Получить(индекс)) Тогда Возврат Ложь конецЕсли;
			индекс = индекс - 1;
		КонецЦикла;
		
		Возврат Истина;
		
	ИначеЕсли Тип("ТаблицаЗначений") = ТипЗнч(Данные1) Тогда
		
		Если Данные1.Количество() <> Данные2.Количество() ИЛИ Данные1.Колонки.Количество() <> Данные2.Колонки.Количество() Тогда Возврат Ложь конецЕсли;
		
		Для Каждого колонка из Данные1.Колонки цикл
			
			Если Данные2.Колонки.Найти(колонка.Имя) = Неопределено Тогда Возврат Ложь конецЕсли;
			
			индекс = Данные1.Количество() - 1;
			
			Пока индекс >= 0 цикл
				Если НЕ ДанныеСовпадают(Данные1[индекс][колонка.Имя], Данные2[индекс][колонка.Имя]) Тогда Возврат Ложь конецЕсли;
				индекс = индекс - 1;
			КонецЦикла;
			
		КонецЦикла;
		
		Возврат Истина;
		
	ИначеЕсли Тип("СписокЗначений") = ТипЗнч(Данные1) Тогда
		
		Если Данные1.Количество() <> Данные2.Количество() Тогда Возврат Ложь конецЕсли;
		
		Если Данные1.Количество() = 0 И Данные2.Количество() = 0 Тогда Возврат Истина конецЕсли;
		
		Возврат ОбщегоНазначенияКлиентСервер.СпискиЗначенийИдентичны(Данные1, Данные2)
		
	ИначеЕсли Тип("ХранилищеЗначения") = ТипЗнч(Данные1) Тогда
	
		Если НЕ ДанныеСовпадают(Данные1.Получить(), Данные2.Получить()) Тогда Возврат Ложь конецЕсли;
		
		Возврат Истина;
		
	Иначе
		
		Возврат Данные1 = Данные2;
		
	КонецЕсли;
	
КонецФункции

Функция СкопироватьКоллекцию(коллекция) Экспорт
	
	Перем новыеЭлементыДобавляются, копияКоллекции;
	
	Если Тип("Массив") = ТипЗнч(коллекция) Тогда
		копияКоллекции = Новый Массив;
		новыеЭлементыДобавляются = Истина;
	ИначеЕсли Тип("СписокЗначений") = ТипЗнч(коллекция) Тогда
		копияКоллекции = Новый СписокЗначений;
		новыеЭлементыДобавляются = Истина;
	ИначеЕсли Тип("Соответствие") = ТипЗнч(коллекция) Тогда
		копияКоллекции = Новый Соответствие;
		новыеЭлементыДобавляются = Ложь;
	ИначеЕсли Тип("Структура") = ТипЗнч(коллекция) Тогда
		копияКоллекции = Новый Структура;
		новыеЭлементыДобавляются = Ложь;
	Иначе
		копияКоллекции = Неопределено
	КонецЕсли;
	
	Если копияКоллекции = Неопределено Тогда
		
		Для Каждого элемент из коллекция цикл
			Если новыеЭлементыДобавляются Тогда
				копияКоллекции.Добавить(элемент);
			Иначе
				копияКоллекции.Вставить(элемент);
			КонецЕсли;
		КонецЦикла;
		
		Возврат копияКоллекции
		
	ИначеЕсли Тип("ТаблицаЗначений") = ТипЗнч(коллекция)
		ИЛИ Тип("СписокЗначений") = ТипЗнч(коллекция) Тогда
		
		Возврат коллекция.Скопировать()
		
	КонецЕсли;
	
КонецФункции

// Массив

Функция МассивОбъектовПолучитьИтогПоРеквизиту(массивОбъектов, имяРеквизита) Экспорт
	
	Перем итог, элемент;
	
	Если НЕ ЗначениеЗаполнено(массивОбъектов) Тогда Возврат 0 конецЕсли;
	
	итог = 0;
	
	Для Каждого элемент из массивОбъектов цикл
		итог = итог + элемент[имяРеквизита];
	КонецЦикла;
	
	Возврат итог
	
КонецФункции

Функция МассивМинимальноеЗначениеПолучить(массивЗначений, значениеЕслиНеЗаполнено = Неопределено) Экспорт
	
	Перем минимальноеЗначение;
	
	Если массивЗначений.Количество() = 0 Тогда Возврат значениеЕслиНеЗаполнено конецЕсли;
	
	минимальноеЗначение = МассивСортироватьПоЗначению(массивЗначений).Получить(0);
	
	Возврат
		?(значениеЕслиНеЗаполнено = Неопределено,
		минимальноеЗначение,
		Макс(минимальноеЗначение, значениеЕслиНеЗаполнено))
		
КонецФункции

Функция МассивМаксимальноеЗначениеПолучить(массивЗначений, значениеЕслиНеЗаполнено = Неопределено) Экспорт
	
	Перем максимальноеЗначение;
	
	Если массивЗначений.Количество() = 0 Тогда Возврат значениеЕслиНеЗаполнено конецЕсли;
	
	максимальноеЗначение = МассивСортироватьПоЗначению(массивЗначений, "Убыв").Получить(0);
	
	Возврат
		?(значениеЕслиНеЗаполнено = Неопределено,
		максимальноеЗначение,
		Макс(максимальноеЗначение, значениеЕслиНеЗаполнено))
		
КонецФункции

Функция МасcивПредставлениеИзмененийПолучитьСтрокой(массивДо, массивПосле) Экспорт
	
	Перем представлениеИзменений, значение;
	
	представлениеИзменений = "";
	
	Для Каждого значение из массивПосле цикл
		Если массивДо.Количество() > 0 И массивДо.Найти(значение) <> Неопределено Тогда Продолжить конецЕсли;
		представлениеИзменений =
			?(ПустаяСтрока(представлениеИзменений),
			СтрШаблон("+ %1", значение),
			СтрШаблон(
				"%1
				|+ %2",
				представлениеИзменений,
				значение));
	КонецЦикла;
	
	Для Каждого значение из массивДо цикл
		Если массивПосле.Количество() > 0 И массивПосле.Найти(значение) <> Неопределено Тогда Продолжить конецЕсли;
		представлениеИзменений =
			?(ПустаяСтрока(представлениеИзменений),
			СтрШаблон("- %1", значение),
			СтрШаблон(
				"%1
				|- %2",
				представлениеИзменений,
				значение));
	КонецЦикла;
	
	Возврат представлениеИзменений
	
КонецФункции

//ОбщегоНазначения.СкопироватьУниверсальнуюКоллекцию
Функция МассивСкопировать(массив) Экспорт
	
	Перем массивКопия, элемент;
	
	массивКопия = Новый Массив;
	
	Для Каждого элемент из массив цикл
		массивКопия.Добавить(элемент);
	КонецЦикла;
	
	Возврат массивКопия
	
КонецФункции

Функция МассивСортироватьПоЗначениюРеквизита(массивЗначений, имяРеквизита, сортироватьПоВозрастанию = Истина) Экспорт
	
	Перем таблицаЗначений, новаяСтрока, элемент;
	
	таблицаЗначений = Новый ТаблицаЗначений;
	таблицаЗначений.Колонки.Добавить("ЗначениеЭлемента");
	таблицаЗначений.Колонки.Добавить("ЗначениеРеквизита");
	
	Для Каждого элемент из массивЗначений цикл
		новаяСтрока = таблицаЗначений.Добавить();
		новаяСтрока.ЗначениеЭлемента = элемент;
		новаяСтрока.ЗначениеРеквизита = элемент[имяРеквизита];
	КонецЦикла;
	
	таблицаЗначений.Сортировать("ЗначениеРеквизита " +
		?(сортироватьПоВозрастанию,
		"Возр",
		"Убыв"));
		
	Возврат таблицаЗначений.ВыгрузитьКолонку("ЗначениеЭлемента")
	
КонецФункции

Функция МассивСортироватьПоЗначению(массивЗначений, сортировка = "Возр") Экспорт
	
	Перем списокЗначений;
	
	списокЗначений = Новый СписокЗначений();
	
	списокЗначений.ЗагрузитьЗначения(массивЗначений);
	списокЗначений.СортироватьПоЗначению(
		?(сортировка = "Возр",
		НаправлениеСортировки.Возр,
		НаправлениеСортировки.Убыв));
		
	Возврат списокЗначений.ВыгрузитьЗначения()
	
КонецФункции

Функция МассивУдалитьЗначение(массив, удаляемоеЗначение) Экспорт
	
	Перем индекс;
	
	индекс = массив.Найти(удаляемоеЗначение);
	
	Если НЕ индекс = Неопределено Тогда
		массив.Удалить(индекс);
	КонецЕсли;
	
	Возврат НЕ индекс = Неопределено
	
КонецФункции

Функция МассивУдалитьЗначения(исходныйМассив, массивЗначенийДляУдаления) Экспорт
	
	Перем результирующийМассив, счетчик;
	
	результирующийМассив = Новый Массив;
	
	Для счетчик = 1 по исходныйМассив.Количество() цикл
		Если НЕ массивЗначенийДляУдаления.Найти(исходныйМассив[счетчик - 1]) = Неопределено Тогда Продолжить конецЕсли;
		результирующийМассив.Добавить(исходныйМассив[счетчик - 1]);
	КонецЦикла;
	
	Возврат результирующийМассив
	
КонецФункции

Процедура МассивУдалитьПовторяющиесяЭлементы(массив, вернутьПустойМассивЕслиНеЗаполненыЗначения = Ложь) Экспорт
	
	Перем всегоЭлементов, индекс, текущийИндекс;
	
	//ОбщегоНазначения.УдалитьПовторяющиесяЭлементыМассива(массив);
	
	Если массив.Количество() = 0 Тогда Возврат конецЕсли;
	
	текущийИндекс = 0;
	всегоЭлементов = массив.Количество();
	
	Пока текущийИндекс < всегоЭлементов цикл
		
		индекс = текущийИндекс + 1;
		
		Пока индекс < всегоЭлементов цикл
			Если НЕ ЗначениеЗаполнено(массив[индекс])
				ИЛИ массив[индекс] = массив[текущийИндекс] Тогда
				массив.Удалить(индекс); 
				всегоЭлементов = всегоЭлементов - 1;
			Иначе
				индекс = индекс + 1;
			КонецЕсли;
		КонецЦикла;
		
		текущийИндекс = текущийИндекс + 1;
		
	КонецЦикла;
	
	Если вернутьПустойМассивЕслиНеЗаполненыЗначения
		И НЕ ЗначениеЗаполнено(массив[0]) Тогда
		массив.Очистить();
	КонецЕсли;
	
КонецПроцедуры

Функция МассивСоздатьПредставлениеЗначений(массив, символРазделителя = Неопределено, удалитьПовторяющиесяЭлементы = Истина) Экспорт
	
	Перем элемент, представлениеМассива;
	
	представлениеМассива = "";
	
	Если символРазделителя = Неопределено Тогда
		символРазделителя = Символы.ПС;
	КонецЕсли;
	
	Если удалитьПовторяющиесяЭлементы Тогда
		МассивУдалитьПовторяющиесяЭлементы(массив);
	КонецЕсли;
	
	Для Каждого элемент из массив цикл
		представлениеМассива =
			?(ПустаяСтрока(представлениеМассива),
			СокрЛП(Строка(элемент)),
			представлениеМассива + символРазделителя + СокрЛП(Строка(элемент)));
	КонецЦикла;
	
	Возврат представлениеМассива
	
КонецФункции

//ОбщегоНазначенияКлиентСервер.ДополнитьМассив(массив, добавляемыйМассив, пропускатьПовторы);
Функция МассивДобавитьЗначенияИзМассива(массив = Неопределено, добавляемыйМассив, пропускатьПовторы = Ложь) Экспорт
	
	Перем элемент;
	
	Если массив = Неопределено Тогда
		массив = Новый Массив;
	КонецЕсли;
	
	Для Каждого элемент из добавляемыйМассив цикл
		Если пропускатьПовторы И НЕ массив.Найти(элемент) = Неопределено Тогда Продолжить конецЕсли;
		массив.Добавить(элемент);
	КонецЦикла;
	
	Возврат массив
	
КонецФункции

// Структура

//ОбщегоНазначения.СкопироватьУниверсальнуюКоллекцию
//ОбщегоНазначенияКлиентСервер.СкопироватьСтруктуру(структура);
Функция СтруктураСкопировать(структура, копироватьЗначения = Истина) Экспорт
	
	Перем копияСтруктуры, элемент;
	
	копияСтруктуры = Новый Структура;
	
	Для Каждого элемент из структура цикл
		копияСтруктуры.Вставить(
			элемент.Ключ,
				?(копироватьЗначения,
				элемент.Значение,
				Неопределено));
	КонецЦикла;
	
	Возврат копияСтруктуры
	
КонецФункции

Функция СтруктураПредставлениеПолучить(структура, исключенныеСвойства = "", символРазделителя = "", включатьЗаголовкиКлючей = Ложь) Экспорт
	
	Перем параКлючИЗначение, представлениеСтруктуры;
	
	представлениеСтруктуры = "";
	
	исключенныеСвойства = СтрокаРазбитьНаСоставляющие(исключенныеСвойства);
	
	Для Каждого параКлючИЗначение из структура цикл
		Если НЕ исключенныеСвойства.Найти(параКлючИЗначение.Ключ) = Неопределено Тогда Продолжить конецЕсли;
		представлениеСтруктуры =
			?(ПустаяСтрока(представлениеСтруктуры),
				"",
				представлениеСтруктуры + символРазделителя) +
			?(включатьЗаголовкиКлючей,
				СтрШаблон("%1: %2", параКлючИЗначение.Ключ, параКлючИЗначение.Значение),
				параКлючИЗначение.Значение);
	КонецЦикла;
	
	Возврат представлениеСтруктуры
	
КонецФункции

Функция СтруктураВыгрузитьВСписокЗначений(структура, пометка = Истина) Экспорт
	
	Перем списокЗначений, параКлючИЗначение;
	
	списокЗначений = Новый СписокЗначений;
	
	Для Каждого параКлючИЗначение из структура цикл
		списокЗначений.Добавить(параКлючИЗначение.Значение, параКлючИЗначение.Ключ, пометка);
	КонецЦикла;
	
	Возврат списокЗначений
	
КонецФункции

Функция СтруктураЗагрузитьИзСпискаЗначений(списокЗначений, толькоПомеченные = Истина) Экспорт
	
	Перем структура, элемент;
	
	структура = Новый Структура;
	
	Для Каждого элемент из списокЗначений цикл
		Если толькоПомеченные И НЕ элемент.Пометка Тогда Продолжить конецЕсли;
		структура.Вставить(элемент.Представление, элемент.Значение);
	КонецЦикла;
	
	Возврат структура
	
КонецФункции

Функция ВыгрузитьЗначенияСтруктурыВМассив(структура) Экспорт
	
	Перем массив, элемент;
	
	массив = Новый Массив;
	
	Для Каждого элемент из структура цикл
		массив.Добавить(элемент.Значение);
	КонецЦикла;
	
	Возврат массив
	
КонецФункции

Функция ВыгрузитьКлючиСтруктурыВМассив(структура) Экспорт
	
	Перем массив, элемент;
	
	массив = Новый Массив;
	
	Для Каждого элемент из структура цикл
		массив.Добавить(элемент.Представление);
	КонецЦикла;
	
	Возврат массив
	
КонецФункции

// СписокЗначений

Функция СписокЗначенийСоздатьПредставлениеЗначений(Знач списокЗначений, поПредставлению = Ложь) Экспорт
	
	Если Тип("ХранилищеЗначения") = ТипЗнч(списокЗначений) Тогда
		списокЗначений = списокЗначений.Получить();
	КонецЕсли;
	
	Возврат
		?(поПредставлению,
		МассивСоздатьПредставлениеЗначений(СписокЗначенийВыгрузитьПредставления(списокЗначений)),
		МассивСоздатьПредставлениеЗначений(списокЗначений.ВыгрузитьЗначения()))
		
КонецФункции

Функция СписокЗначенийПолучитьПервоеЗначениеПоПредставлению(списокЗначений, представление) Экспорт
	
	Перем элемент, значение;
	
	значение = Неопределено;
	
	Для Каждого элемент из списокЗначений цикл
		Если элемент.Представление <> представление Тогда Продолжить конецЕсли;
		значение = элемент.Значение;
	КонецЦикла;
	
	Возврат значение
	
КонецФункции

Функция СписокЗначенийВыгрузитьПредставления(списокЗначений, сортироватьПоПредставлению = Истина) Экспорт
	
	Перем массивПредставлений;
	
	массивПредставлений = Новый Массив;
	
	Если сортироватьПоПредставлению Тогда
		списокЗначений.СортироватьПоПредставлению();
	КонецЕсли;
	
	Для Каждого элемент из списокЗначений цикл
		массивПредставлений.Добавить(элемент.Представление);
	КонецЦикла;
	
	Возврат массивПредставлений
	
КонецФункции

Процедура СписокЗначенийЗагрузитьЗначенияИзСтруктура(списокЗначений, структура) Экспорт
	
	Перем параКлючИЗначение;
	
	списокЗначений.Очистить();
	
	Если Тип("Структура") <> ТипЗнч(структура) Тогда Возврат конецЕсли;
	
	Для Каждого параКлючИЗначение из структура цикл
		списокЗначений.Добавить(параКлючИЗначение.Значение, параКлючИЗначение.Ключ);
	КонецЦикла;
	
КонецПроцедуры

Функция СписокЗначенийВыгрузитьЗначенияВСтруктура(списокЗначений, структура = Неопределено) Экспорт
	
	Перем элемент;
	
	Если структура = Неопределено Тогда
		структура = Новый Структура;
	Иначе
		структура.Очистить();
	КонецЕсли;
	
	Если Тип("СписокЗначений") <> ТипЗнч(списокЗначений) Тогда Возврат структура конецЕсли;
	
	Для Каждого элемент из списокЗначений цикл
		структура.Вставить(элемент.Представление, элемент.Значение);
	КонецЦикла;
	
	Возврат структура
	
КонецФункции

Функция СписокЗначенийВыгрузитьЗначенияОтмеченные(списокЗначений) Экспорт
	
	Перем элемент, массивЗначений;
	
	массивЗначений = Новый Массив;
	
	Для Каждого элемент из списокЗначений цикл
		Если НЕ элемент.Пометка Тогда Продолжить конецЕсли;
		массивЗначений.Добавить(элемент.Значение);
	КонецЦикла;
	
	Возврат массивЗначений
	
КонецФункции

Функция СписокЗначенийИзКоллекции(Знач коллекция, имяРеквизитаЗначений = "", удалитьПовторяющиесяЗначения = Ложь, добавлятьПустыеЗначения = Истина) Экспорт
	
	Перем списокЗначений;
	
	Если Тип("СписокЗначений") = ТипЗнч(коллекция) Тогда Возврат коллекция конецЕсли;
	
	списокЗначений = Новый СписокЗначений;
	
	Если Тип("Массив") = ТипЗнч(коллекция) Тогда
		
		Если удалитьПовторяющиесяЗначения Тогда
			МассивУдалитьПовторяющиесяЭлементы(коллекция, добавлятьПустыеЗначения);
		КонецЕсли;
		
		списокЗначений.ЗагрузитьЗначения(
			?(ПустаяСтрока(имяРеквизитаЗначений),
			коллекция,
			РеквизитОбъектовВыгрузитьМассив(имяРеквизитаЗначений, коллекция, удалитьПовторяющиесяЗначения, добавлятьПустыеЗначения)));
			
	ИначеЕсли Тип("Структура") = ТипЗнч(коллекция) Тогда
		
		Для Каждого элемент из коллекция цикл
			списокЗначений.Добавить(элемент.Ключ, элемент.Значение);
		КонецЦикла;
		
	Иначе
		
		списокЗначений.ЗагрузитьЗначения(РеквизитОбъектовВыгрузитьМассив(имяРеквизитаЗначений, коллекция, удалитьПовторяющиесяЗначения, добавлятьПустыеЗначения));
		
	КонецЕсли;
	
	Возврат списокЗначений
	
КонецФункции

Функция СписокЗначенийПодобратьЗначениеПоПредставлению(списокЗначений, представление, возвращатьНеопреленоЕслиПустоеПредставление = Истина) Экспорт
	
	Перем элемент, значение;
	
	Если ПустаяСтрока(представление) И возвращатьНеопреленоЕслиПустоеПредставление Тогда Возврат Неопределено конецЕсли;
	
	значение = Неопределено;
	
	Для Каждого элемент из списокЗначений цикл
		Если Найти(НРег(элемент.Представление), НРег(представление)) <> 1 Тогда Продолжить конецЕсли;
		
		значение = элемент.Значение;
	КонецЦикла;
	
	Возврат значение
	
КонецФункции

Функция СписокЗначенийЗагрузитьЗначения(Знач списокЗначений = Неопределено, массивЗначений, пропускатьПовторы = Ложь) Экспорт
	
	Перем массивЗначенийСпискаЗначений;
	
	Если списокЗначений = Неопределено Тогда
		
		списокЗначений = Новый СписокЗначений;
		списокЗначений.ЗагрузитьЗначения(массивЗначений);
		
	Иначе
		
		массивЗначенийСпискаЗначений = списокЗначений.ВыгрузитьЗначения();
		
		ОбщегоНазначенияКлиентСервер.ДополнитьМассив(массивЗначенийСпискаЗначений, массивЗначений, НЕ пропускатьПовторы);
		списокЗначений.ЗагрузитьЗначения(массивЗначенийСпискаЗначений);
		
	КонецЕсли;
	
	Возврат списокЗначений
	
КонецФункции

// Соответствие

Функция СоответствиеОбъектовИхРеквизитуПолучить(массивОбъектов, имяРеквизитаОбъекта) Экспорт
	
	Перем элемент, соответствие;
	
	соответствие = Новый Соответствие;
	
	Для Каждого элемент из массивОбъектов цикл
		соответствие.Вставить(элемент[имяРеквизитаОбъекта], элемент);
	КонецЦикла;
	
	Возврат соответствие
	
КонецФункции

Функция СоответствиеВыгрузитьКлючи(соответствие, вВидеСпискаЗначений = Ложь) Экспорт
	
	Перем элемент, ключи;
	
	ключи =
		?(вВидеСпискаЗначений,
		Новый СписокЗначений,
		Новый Массив);
		
	Для Каждого элемент из соответствие цикл
		ключи.Добавить(элемент.Ключ);
	КонецЦикла;
	
	Возврат ключи
	
КонецФункции

Функция СоответствиеВыгрузитьЗначения(соответствие, вВидеСпискаЗначений = Ложь) Экспорт
	
	Перем элемент, значения;
	
	значения =
		?(вВидеСпискаЗначений,
		Новый СписокЗначений,
		Новый Массив);
	
	Для Каждого элемент из соответствие цикл
		значения.Добавить(элемент.Значение);
	КонецЦикла;
	
	Возврат значения
	
КонецФункции

Функция СоответствиеВыгрузитьВТаблицуЗначений(соответствие, сортироватьПоЗначению = Неопределено) Экспорт
	
	Перем таблицаЗначений, ключЗначение;
	
	таблицаЗначений = Новый ТаблицаЗначений;
	таблицаЗначений.Колонки.Добавить("Ключ");
	таблицаЗначений.Колонки.Добавить("Значение");
	
	Для Каждого ключЗначение из соответствие цикл
		новаяСтрока = таблицаЗначений.Добавить();
		новаяСтрока.Ключ = ключЗначение.Ключ;
		новаяСтрока.Значение = ключЗначение.Значение;
	КонецЦикла;
	
	Если сортироватьПоЗначению = Неопределено Тогда
	ИначеЕсли сортироватьПоЗначению Тогда
		таблицаЗначений.Сортировать("Значение");
	Иначе
		таблицаЗначений.Сортировать("Ключ");
	КонецЕсли;
	
	Возврат таблицаЗначений
	
КонецФункции

// ТаблицаЗначений / ТабличнаяЧасть

Функция ТаблицаЗначенийСоздать(колонки) Экспорт
	
	Перем таблицаЗначений, имяКолонки;
	
	таблицаЗначений = Новый ТаблицаЗначений;
	
	Для Каждого имяКолонки из СтрокаРазбитьНаСоставляющие(колонки,, Истина) цикл
		таблицаЗначений.Колонки.Добавить(имяКолонки);
	КонецЦикла;
	
	Возврат таблицаЗначений
	
КонецФункции

Функция ТаблицаСтрокиПроверитьИдентичность(таблица, строка0, строка1 = Неопределено) Экспорт
	Перем колонка;
	
	Если строка1 = Неопределено Тогда
		строка1 = таблица.ТекущаяСтрока;
	КонецЕсли;
	
	Для Каждого колонка из таблица.Колонки цикл
		Если строка1[колонка.Имя] <> строка0[колонка.Имя] Тогда возврат Ложь конецЕсли
	КонецЦикла;
	
	Возврат Истина;
КонецФункции

Функция ТаблицаСтруктураПолучить(таблица, вВидеТаблицы = Истина, вВидеПримитивныхТипов = Ложь) Экспорт
	
	Перем возвращаемоеЗначение, колонка, коллекцияКолонок, таблицаЕстьТипаТабличнаяЧасть, описаниеТиповЗначенийВКолонке, имяТаблицы, имяТабличнойЧасти;
	Перем списокПримитивныхТипов, описаниеПримитивныхТипов;
	
	списокПримитивныхТипов = Новый Массив;
	списокПримитивныхТипов.Добавить("Число");
	списокПримитивныхТипов.Добавить("Дата");
	списокПримитивныхТипов.Добавить("Булево");
	списокПримитивныхТипов.Добавить("Строка");
	описаниеПримитивныхТипов = Новый ОписаниеТипов(списокПримитивныхТипов);
	
	таблицаЕстьТипаТабличнаяЧасть = ТаблицаТипаТабличнаяЧастьПроверить(таблица);
	
	Если таблицаЕстьТипаТабличнаяЧасть Тогда
		структураМетаданныхТабличнойЧасти = ТабличнаяЧастьМетаданныеПолучить(таблица);
		имяТабличнойЧасти = структураМетаданныхТабличнойЧасти.Имя;
		коллекцияКолонок = структураМетаданныхТабличнойЧасти.Колонки;
	Иначе
		имяТабличнойЧасти = Неопределено;
		коллекцияКолонок = таблица.Колонки;
	КонецЕсли;
	
	возвращаемоеЗначение =
		?(вВидеТаблицы,
		Новый ТаблицаЗначений,
		Новый Структура);
		
	Для Каждого колонка из коллекцияКолонок цикл
		
		Если вВидеТаблицы Тогда
			
			описаниеТиповЗначенийВКолонке =
				?(таблицаЕстьТипаТабличнаяЧасть,
					колонка.Тип,
					колонка.ТипЗначения);
					
			Если имяТабличнойЧасти = Неопределено Тогда
				
				возвращаемоеЗначение.Колонки.Добавить(
					колонка.Имя,
					?(вВидеПримитивныхТипов,
						описаниеПримитивныхТипов,
						описаниеТиповЗначенийВКолонке),
					колонка.Заголовок,
					колонка.Ширина);
					
			Иначе
				
				возвращаемоеЗначение.Колонки.Добавить(
					колонка.Имя,
					?(вВидеПримитивныхТипов,
						описаниеПримитивныхТипов,
						описаниеТиповЗначенийВКолонке),
					колонка.Синоним);
					
			КонецЕсли;
			
		Иначе
			
			возвращаемоеЗначение.Вставить(колонка.Имя);
			
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат возвращаемоеЗначение
	
КонецФункции

Функция ТаблицыРазличающиесяСтрокиПолучить(таблица1, таблица2, вВидеТаблицы = Истина) Экспорт
	
	Перем таблица1ОтсутствующиеСтрокиТаблицы2, таблица2ОтсутствующиеСтрокиТаблицы1, структураКолонокТаблицы, структураОтбора;
	
	структураКолонокТаблицы = ТаблицаСтруктураПолучить(таблица1, Ложь);
	таблица1ОтсутствующиеСтрокиТаблицы2 = ТаблицаСтруктураПолучить(таблица1);
	таблица2ОтсутствующиеСтрокиТаблицы1 = ТаблицаСтруктураПолучить(таблица1);
	
	Для Каждого строка из таблица1 цикл
		структураОтбора = СтруктураСкопировать(структураКолонокТаблицы, Ложь);
		ЗаполнитьЗначенияСвойств(структураОтбора, строка);
		Если таблица2.НайтиСтроки(структураОтбора).Количество() = 0 Тогда Продолжить конецЕсли;
		новаяСтрока = таблица2ОтсутствующиеСтрокиТаблицы1.Добавить();
		ЗаполнитьЗначенияСвойств(новаяСтрока, строка);
	КонецЦикла;
	
	Для Каждого строка из таблица2 цикл
		структураОтбора = СтруктураСкопировать(структураКолонокТаблицы, Ложь);
		ЗаполнитьЗначенияСвойств(структураОтбора, строка);
		Если таблица1.НайтиСтроки(структураОтбора).Количество() = 0 Тогда Продолжить конецЕсли;
		новаяСтрока = таблица1ОтсутствующиеСтрокиТаблицы2.Добавить();
		ЗаполнитьЗначенияСвойств(новаяСтрока, строка);
	КонецЦикла;
	
	Если вВидеТаблицы Тогда
		
		Для Каждого строка из таблица1ОтсутствующиеСтрокиТаблицы2 цикл
			новаяСтрока = таблица2ОтсутствующиеСтрокиТаблицы1.Добавить();
			ЗаполнитьЗначенияСвойств(новаяСтрока, строка);
		КонецЦикла;
		
		Возврат таблица1ОтсутствующиеСтрокиТаблицы2
		
	Иначе
		
		Возврат Новый Структура("НовыеВТаблица2, НовыеВТаблица1",
			таблица2ОтсутствующиеСтрокиТаблицы1,
			таблица1ОтсутствующиеСтрокиТаблицы2)
			
	КонецЕсли;
	
КонецФункции

Процедура ТаблицаЗагрузитьКолонку(таблица, имяКолонки, Знач массивЗначенийКолонки, создатьСтрокиЕслиПустая = Истина) Экспорт
	
	Перем значение, строка, новаяСтрока;
	
	Если НЕ Тип("Массив") = ТипЗнч(массивЗначенийКолонки) Тогда
		
		значение = массивЗначенийКолонки;
		
		массивЗначенийКолонки = Новый Массив();
		
		Для Каждого строка из таблица цикл
			массивЗначенийКолонки.Добавить(значение);
		КонецЦикла;
		
	КонецЕсли;
	
	Если таблица.Количество() = 0 И создатьСтрокиЕслиПустая Тогда
		
		Для Каждого значение из массивЗначенийКолонки цикл
			новаяСтрока = таблица.Добавить();
			новаяСтрока[имяКолонки] = значение;
		КонецЦикла;
		
	Иначе
		
		таблица.ЗагрузитьКолонку(массивЗначенийКолонки, имяКолонки);
		
	КонецЕсли;
	
КонецПроцедуры

Процедура ТаблицаЗаполнитьЗначенияКолонки(таблица, имяКолонки, значение) Экспорт
	
	Перем таблицаЗначений;
	
	Если Тип("ДанныеФормыКоллекция") = ТипЗнч(таблица) Тогда
		
		таблицаЗначений = ДанныеФормыВЗначение(таблица, Тип("ТаблицаЗначений"));
		
		Если таблицаЗначений.Количество() = 0 Тогда Возврат конецЕсли;
		
		таблицаЗначений.ЗаполнитьЗначения(значение, имяКолонки);
		ЗначениеВДанныеФормы(таблицаЗначений, таблица);
		
	ИначеЕсли ТаблицаТипаТабличнаяЧастьПроверить(таблица, Ложь) Тогда
		
		Если таблица.Количество() = 0 Тогда Возврат конецЕсли;
		
		таблицаЗначений = таблица.Выгрузить();
		таблицаЗначений.ЗаполнитьЗначения(значение, имяКолонки);
		таблица.Загрузить(таблицаЗначений);
		
	Иначе
		
		Если таблица.Количество() = 0 Тогда Возврат конецЕсли;
		
		таблица.ЗаполнитьЗначения(значение, имяКолонки);
		
	КонецЕсли;
	
КонецПроцедуры

Процедура ТаблицаКолонкиОчистить(таблица, Знач именаКолонок = "") Экспорт
	
	Если ПустаяСтрока(именаКолонок) Тогда Возврат конецЕсли;
	
	именаКолонок = СтрокаРазбитьНаСоставляющие(именаКолонок,, Истина);
	
	Для Каждого строка из таблица цикл
		
		Для Каждого имяКолонки из именаКолонок цикл
			строка[имяКолонки] = Неопределено;
		КонецЦикла;
		
	КонецЦикла;
	
КонецПроцедуры

Процедура ТаблицаЗагрузитьТаблицуЗначений(таблицаНазначение, таблицаИсточник) Экспорт
	
	Перем строка, новаяСтрока, заполнятьКолонкуНомерСтроки, счетчик;
	
	Если таблицаИсточник.Количество() = 0 Тогда Возврат конецЕсли;
	
	Если ТаблицаТипаТабличнаяЧастьПроверить(таблицаНазначение) Тогда
		
		таблицаНазначение.Загрузить(таблицаИсточник);
		
	Иначе
		
		таблицаНазначение.Очистить();
		
		заполнятьКолонкуНомерСтроки = таблицаНазначение.Колонки.Найти("НомерСтроки") <> Неопределено;
		счетчик = 0;
		
		Для Каждого строка из таблицаИсточник цикл
			новаяСтрока = таблицаНазначение.Добавить();
			ЗаполнитьЗначенияСвойств(новаяСтрока, строка);
			счетчик = счетчик + 1;
			Если НЕ заполнятьКолонкуНомерСтроки Тогда Продолжить конецЕсли;
			новаяСтрока.НомерСтроки = счетчик;
		КонецЦикла;
		
	КонецЕсли;
	
КонецПроцедуры

Функция ТаблицаВыгрузитьКолонки(таблица, колонки = "") Экспорт
	Перем таблицаЗначений, удаляемыеКолонки, колонка;
	
	таблицаЗначений = ТаблицаСтруктураПолучить(таблица, Истина);
	ТаблицаЗагрузитьТаблицуЗначений(таблицаЗначений, таблица);
	
	Если НЕ ПустаяСтрока(колонки) Тогда
		
		удаляемыеКолонки = Новый Массив;
		
		Для Каждого колонка из таблицаЗначений.Колонки цикл
			Если СтрНайти(колонки, колонка.Имя) <> 0 Тогда Продолжить конецЕсли;
			удаляемыеКолонки.Добавить(колонка);
		КонецЦикла;
		
		Для Каждого колонка из удаляемыеКолонки цикл
			таблицаЗначений.Колонки.Удалить(колонка);
		КонецЦикла;
		
	КонецЕсли;
	
	Возврат таблицаЗначений
КонецФункции

Функция ТаблицаСтрокиОтобрать(таблица, имяКолонки, значениеОтбора, вернутьВВидеТаблицы = Ложь,
	колонкиГруппировок = "", колонкиСуммирования = "", колонкиСортировки = "", возвращатьТолькоПервыйЭлемент = Ложь) Экспорт
	
	Перем возвращаемоеЗначение;
	
	Если возвращатьТолькоПервыйЭлемент Тогда
		возвращаемоеЗначение = таблица.НайтиСтроки(Новый Структура(имяКолонки, значениеОтбора));
		Возврат
			?(возвращаемоеЗначение.Количество() > 0,
			возвращаемоеЗначение.Получить(0),
			Неопределено)
	КонецЕсли;
	
	Если НЕ вернутьВВидеТаблицы Тогда
		
		возвращаемоеЗначение = таблица.НайтиСтроки(Новый Структура(имяКолонки, значениеОтбора));
		
	Иначе
		
		возвращаемоеЗначение = ТаблицаСтруктураПолучить(таблица);
		
		Для Каждого строка из таблица.НайтиСтроки(Новый Структура(имяКолонки, значениеОтбора)) цикл
			новаяСтрока = возвращаемоеЗначение.Добавить();
			ЗаполнитьЗначенияСвойств(новаяСтрока, строка);
		КонецЦикла;
		
		Если НЕ ПустаяСтрока(колонкиГруппировок) Тогда
			возвращаемоеЗначение.Свернуть(колонкиГруппировок, колонкиСуммирования);
		КонецЕсли;
		
		Если НЕ ПустаяСтрока(колонкиСортировки) Тогда
			возвращаемоеЗначение.Сортировать(колонкиСортировки);
		КонецЕсли;
		
	КонецЕсли;
	
	Возврат возвращаемоеЗначение
	
КонецФункции

Функция ТаблицаСтрокиМассивОтобратьПоПараметрам(массивСтрокТаблицы, структураОтбора, возвращатьТолькоПервыйЭлемент = Ложь) Экспорт
	
	Перем массивОтобраныхСтрок, строка, ключИЗначение, добавитьСтрокуВОтбор;
	
	массивОтобраныхСтрок = Новый Массив;
	
	Для Каждого строка из массивСтрокТаблицы цикл
		
		добавитьСтрокуВОтбор = Истина;
		
		Для Каждого ключИЗначение из структураОтбора цикл
			Если строка[ключИЗначение.Ключ] <> ключИЗначение.Значение Тогда
				добавитьСтрокуВОтбор = Ложь;
				Прервать
			КонецЕсли;
		КонецЦикла;
		
		Если добавитьСтрокуВОтбор Тогда
			
			массивОтобраныхСтрок.Добавить(строка);
			
			Если возвращатьТолькоПервыйЭлемент Тогда Прервать конецЕсли;
			
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат массивОтобраныхСтрок
	
КонецФункции

Функция ТаблицаСтрокиОтобратьПоПараметрам(таблица, структураПараметров, вернутьВВидеТаблицы = Ложь,
	колонкиГруппировок = "", колонкиСуммирования = "", колонкиСортировки = "", возвращатьТолькоПервыйЭлемент = Ложь) Экспорт
	
	Перем возвращаемоеЗначение;
	
	Если возвращатьТолькоПервыйЭлемент Тогда
		возвращаемоеЗначение = таблица.НайтиСтроки(структураПараметров);
		Возврат
			?(возвращаемоеЗначение.Количество() > 0,
			возвращаемоеЗначение.Получить(0),
			Неопределено)
	КонецЕсли;
	
	Если НЕ вернутьВВидеТаблицы Тогда
		
		возвращаемоеЗначение = таблица.НайтиСтроки(структураПараметров);
		
	Иначе
		
		возвращаемоеЗначение = ТаблицаСтруктураПолучить(таблица);
		
		Для Каждого строка из таблица.НайтиСтроки(структураПараметров) цикл
			новаяСтрока = возвращаемоеЗначение.Добавить();
			ЗаполнитьЗначенияСвойств(новаяСтрока, строка);
		КонецЦикла;
		
		Если НЕ ПустаяСтрока(колонкиГруппировок) Тогда
			возвращаемоеЗначение.Свернуть(колонкиГруппировок, колонкиСуммирования);
		КонецЕсли;
		
		Если НЕ ПустаяСтрока(колонкиСортировки) Тогда
			возвращаемоеЗначение.Сортировать(колонкиСортировки);
		КонецЕсли;
		
	КонецЕсли;
	
	Возврат возвращаемоеЗначение
	
КонецФункции

Функция ТаблицаВыгрузитьСвернутьКолонки(таблица, колонкиГруппировок, колонкиСуммирования = "", колонкиСортировки = "", оставлятьВсеОстальныеКолонки = Истина) Экспорт
	
	Перем копияТаблица, колонки, колонка, всеКолонкиГруппировки, всеКолонкиСуммирования;
	
	Если ТаблицаТипаТабличнаяЧастьПроверить(таблица) Тогда
		копияТаблица = таблица.Выгрузить();
		колонки = ТабличнаяЧастьМетаданныеПолучить(таблица).Колонки;
	Иначе
		копияТаблица = таблица.Скопировать();
		колонки = таблица.Колонки;
	КонецЕсли;
	
	Если оставлятьВсеОстальныеКолонки Тогда
		
		всеКолонкиГруппировки = "";
		всеКолонкиСуммирования = "";
		
		Для Каждого колонка из колонки цикл
			
			Если СтрНайти(колонкиГруппировок, колонка.Имя) > 0
				ИЛИ СтрНайти(колонкиСуммирования, колонка.Имя) = 0 Тогда
				всеКолонкиГруппировки = всеКолонкиГруппировки + колонка.Имя + ", ";
			КонецЕсли;
			
			Если СтрНайти(колонкиСуммирования, колонка.Имя) > 0 Тогда
				всеКолонкиСуммирования = всеКолонкиСуммирования + колонка.Имя + ", ";
			КонецЕсли;
			
		КонецЦикла;
		
		всеКолонкиГруппировки = Лев(всеКолонкиГруппировки, СтрДлина(всеКолонкиГруппировки) - 2);
		всеКолонкиСуммирования = Лев(всеКолонкиСуммирования, СтрДлина(всеКолонкиСуммирования) - 2);
		
	Иначе
		
		всеКолонкиГруппировки = колонкиГруппировок;
		всеКолонкиСуммирования = колонкиСуммирования;
		
	КонецЕсли;
	
	копияТаблица.Свернуть(всеКолонкиГруппировки, всеКолонкиСуммирования);
	
	Если НЕ ПустаяСтрока(колонкиСортировки) Тогда
		копияТаблица.Сортировать(колонкиСортировки);
	КонецЕсли;
	
	Возврат копияТаблица
	
КонецФункции

Функция ТаблицаВыгрузитьСвернутьКолонку(Знач таблица, имяКолонки, возвращатьПустойМасивВместоНеопределено = Истина, удалятьНезаполненныеСтроки = Ложь, индексНачальнойСтроки = 0) Экспорт
	
	Перем этоТаблицаЗначений, копияТаблица, колонкаНайденаВТаблице, элемент;
	
	Если ПустаяСтрока(имяКолонки) ИЛИ таблица.Количество() = 0 Тогда Возврат Новый массив конецЕсли;
	
	этоТаблицаЗначений = ТаблицаТипаТаблицаЗначенийПроверить(таблица);
	
	Если этоТаблицаЗначений = Неопределено Тогда
		//таблица = таблица.Выгрузить();
		//этоТаблицаЗначений = Истина;
		ВызватьИсключениеОтсутствиеРеализации("Отсутствует реализация выгрузки колонки данных формы управляемой формы")
	КонецЕсли;
	
	колонкаОтсутствуетВТаблице = Ложь;
	
	Если этоТаблицаЗначений Тогда
		колонкаОтсутствуетВТаблице =
			таблица.Колонки.Найти(имяКолонки) = Неопределено;
	Иначе
		Попытка
			копияТаблица = таблица.Получить(0)[имяКолонки];
		Исключение
			колонкаОтсутствуетВТаблице = Истина;
		КонецПопытки;
	КонецЕсли;
	
	Если колонкаОтсутствуетВТаблице Тогда возврат Неопределено конецЕсли;
	
	Если этоТаблицаЗначений Тогда
		копияТаблица = таблица.Скопировать();
	Иначе
		копияТаблица = таблица.Выгрузить();
	КонецЕсли;
	
	копияТаблица.Свернуть(имяКолонки);
	копияТаблица = копияТаблица.ВыгрузитьКолонку(имяКолонки);
	
	Если индексНачальнойСтроки > 0 Тогда
		Для счетчик = 0 по индексНачальнойСтроки - 1 цикл
			копияТаблица.Удалить(0);
		КонецЦикла;
	КонецЕсли;
	
	Если удалятьНезаполненныеСтроки Тогда
		Для счечик = копияТаблица.Количество() - 1 по копияТаблица.Количество() - 1 цикл
			Если ЗначениеЗаполнено(копияТаблица[счечик]) Тогда Продолжить конецЕсли;
			копияТаблица.Удалить(счечик);
		КонецЦикла;
	КонецЕсли;
	
	Если копияТаблица.Количество() = 1 И НЕ ЗначениеЗаполнено(копияТаблица.Получить(0)) Тогда
		Возврат
			?(возвращатьПустойМасивВместоНеопределено,
			Новый Массив,
			Неопределено)
	Иначе
		Возврат копияТаблица
	КонецЕсли;
	
КонецФункции

Функция ТаблицаВыгрузитьКолонкиВТаблицу(таблицаРезультирующая = Неопределено, таблица, колонки = "", Знач структураЗаменыКолонок = Неопределено,
	выгружатьВВидеПримитивныхТипов = Ложь, удалятьКолонкиВИсходнойТаблицаРезультирующая = Ложь) Экспорт
	
	Перем именаВыгружаемыхКолонок, имяКолонки, колонка;
	Перем строка, значениеЯчейки, новаяСтрока, списокПримитивныхТипов, описаниеПримитивныхТипов;
	
	Если структураЗаменыКолонок = Неопределено Тогда
		структураЗаменыКолонок = Новый Структура;
	КонецЕсли;
	
	списокПримитивныхТипов = Новый Массив;
	списокПримитивныхТипов.Добавить(Тип("Число"));
	списокПримитивныхТипов.Добавить(Тип("Дата"));
	списокПримитивныхТипов.Добавить(Тип("Булево"));
	списокПримитивныхТипов.Добавить(Тип("Строка"));
	описаниеПримитивныхТипов = Новый ОписаниеТипов(списокПримитивныхТипов);
	
	именаВыгружаемыхКолонок = СтрокаРазбитьНаСоставляющие(колонки,, Истина);
	
	#Область ФормуванняСтруктуриТаблиці
	
	Если таблицаРезультирующая = Неопределено Тогда
		
		таблицаРезультирующая = ТаблицаСтруктураПолучить(таблица, Истина, Истина);
		
		итератор = таблицаРезультирующая.Колонки.Количество();
		
		Пока итератор > 0 цикл
			
			итератор = итератор - 1;
			
			колонка = таблицаРезультирующая.Колонки[итератор];
			
			Если именаВыгружаемыхКолонок.Найти(колонка.Имя) = Неопределено Тогда
				
				таблицаРезультирующая.Колонки.Удалить(колонка.Имя);
				
			Иначе
				
				Если структураЗаменыКолонок.Свойство(колонка.Имя) Тогда
					имяКолонки = колонка.Имя;
					таблицаРезультирующая.Колонки.Удалить(имяКолонки);
					таблицаРезультирующая.Колонки.Добавить(структураЗаменыКолонок[имяКолонки]);
				КонецЕсли;
				
			КонецЕсли;
			
		КонецЦикла;
		
		Если именаВыгружаемыхКолонок.Найти("НомерСтроки") <> Неопределено
			И таблицаРезультирующая.Колонки.Найти("НомерСтроки") = Неопределено Тогда
			таблицаРезультирующая.Колонки.Добавить("НомерСтроки",, "N");
		КонецЕсли;
		
	КонецЕсли;
	
	#КонецОбласти
	
	Для Каждого строка из таблица цикл
		
		новаяСтрока = таблицаРезультирующая.Добавить();
		
		Если выгружатьВВидеПримитивныхТипов Тогда
			
			Для Каждого имяКолонки из именаВыгружаемыхКолонок цикл
				
				Если "НомерСтроки" = имяКолонки Тогда
					новаяСтрока.НомерСтроки = таблицаРезультирующая.Количество();
					Продолжить
				КонецЕсли;
				
				значениеЯчейки = строка[имяКолонки];
				
				Если структураЗаменыКолонок.Свойство(имяКолонки) Тогда
					имяКолонки = структураЗаменыКолонок[имяКолонки];
				КонецЕсли;
				
				Если НЕ ЗначениеЗаполнено(значениеЯчейки) Тогда
					новаяСтрока[имяКолонки] = "";
				ИначеЕсли описаниеПримитивныхТипов.СодержитТип(ТипЗнч(значениеЯчейки)) Тогда
					новаяСтрока[имяКолонки] = значениеЯчейки;
				Иначе
					новаяСтрока[имяКолонки] = СокрЛП(значениеЯчейки);
				КонецЕсли;
				
			КонецЦикла;
			
		Иначе
			
			ЗаполнитьЗначенияСвойств(новаяСтрока, строка);
			
			Если именаВыгружаемыхКолонок.Найти("НомерСтроки") <> Неопределено Тогда
				новаяСтрока.НомерСтроки = таблицаРезультирующая.Количество();
			КонецЕсли;
			
			Для Каждого ключИЗначение из структураЗаменыКолонок цикл
				Если НЕ ЗначениеЗаполнено(строка[ключИЗначение.Ключ]) Тогда
					новаяСтрока[ключИЗначение.Значение] = Неопределено;
				ИначеЕсли таблицаРезультирующая.Колонки[ключИЗначение.Значение].ТипЗначения.СодержитТип(ТипЗнч(строка[ключИЗначение.Ключ])) Тогда
					новаяСтрока[ключИЗначение.Значение] = строка[ключИЗначение.Ключ];
				Иначе
					ВызватьИсключениеОтсутствиеРеализации("Для объединения таблиц требуется установить аргумент метода Выгружать в виде примитивных типов")
				КонецЕсли
			КонецЦикла;
			
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат таблицаРезультирующая
	
КонецФункции

//ОбщегоНазначенияКлиентСервер.ДополнитьТаблицу(таблицаИсточник, таблицаНазначение);
//ОбщегоНазначения.ЗагрузитьВТаблицуЗначений(таблицаИсточник, таблицаНазначение);
Процедура ТаблицаДобавитьСтрокиТаблицы(таблицаНазначение, таблицаИсточник, очиститьНазначениеПередЗаполнением = Ложь) Экспорт
	Перем строкаИсточник, строкаНазначение;
	
	Если очиститьНазначениеПередЗаполнением Тогда
		таблицаНазначение.Очистить();
	КонецЕсли;
	
	Для Каждого строкаИсточник из таблицаИсточник цикл
		строкаНазначение = таблицаНазначение.Добавить();
		ЗаполнитьЗначенияСвойств(строкаНазначение, строкаИсточник);
	КонецЦикла;
	
КонецПроцедуры

Функция СтрокаТаблицыИтогПолучить(строка, таблица, исключаемыеКолонки = "НомерСтроки") Экспорт
	
	Перем колонки, колонка, итог;
	
	колонки =
		?(ТаблицаТипаТабличнаяЧастьПроверить(таблица),
		ТабличнаяЧастьМетаданныеПолучить(таблица).Колонки,
		таблица.Колонки);
		
	итог = 0;
	
	Для Каждого колонка из колонки цикл
		Если Тип("Число") <> ТипЗнч(строка[колонка.Имя]) ИЛИ СтрНайти(исключаемыеКолонки, колонка.Имя) <> 0 Тогда Продолжить конецЕсли;
		итог = итог + строка[колонка.Имя];
	КонецЦикла;
	
	Возврат итог
	
КонецФункции

Функция ТаблицаСтроковоеПредставлениеПолучить(таблица) Экспорт
	
	Перем строковоеПредставлениеТаблицы, строковоеПредставлениеСтрокиТаблицы, строка, колонка;
	
	строковоеПредставлениеТаблицы = "";
	
	Для Каждого строка из таблица цикл
		
		Если НЕ ПустаяСтрока(строковоеПредставлениеТаблицы) Тогда
			строковоеПредставлениеТаблицы = строковоеПредставлениеТаблицы + Символы.ПС;
		КонецЕсли;
		
		строковоеПредставлениеСтрокиТаблицы = "";
		
		Для Каждого колонка из таблица.Колонки цикл
			
			Если НЕ ПустаяСтрока(строковоеПредставлениеСтрокиТаблицы) Тогда
				строковоеПредставлениеСтрокиТаблицы = строковоеПредставлениеСтрокиТаблицы + "; ";
			КонецЕсли;
			
			строковоеПредставлениеСтрокиТаблицы = строковоеПредставлениеСтрокиТаблицы + СтрШаблон("%1: %2", колонка.Имя, строка[колонка.Имя]);
			
		КонецЦикла;
		
		строковоеПредставлениеТаблицы = строковоеПредставлениеТаблицы + строковоеПредставлениеСтрокиТаблицы + ";";
		
	КонецЦикла;
	
	Возврат строковоеПредставлениеТаблицы
	
КонецФункции

Функция ТаблицаПолучитьHTMLПредставлениеСтрокой(таблица, Знач списокКолонок = Неопределено,
	заголовокТаблицы = "", Знач параметрыФорматирования = Неопределено, запретПереносаСлов = Ложь, htmlДокументВладелец = Неопределено) Экспорт
	
	Перем кодировка, ширина, высота, цветФона, выравниваниеТаблицы, выравниваниеГоризонтальное, выравниваниеВертикальное;
	Перем ширинаРамки, цветРамки, цветРамкиЯркий, цветРамкиТёмный, типРамки, линии, расстояниеМеждуЯчейками, отступДоЯчейки;
	Перем документHtml, документHtmlBody, документHtmlTable, документHtmlTableCaption, документHtmlTBody, документHtmlАтрибут;
	Перем строка, колонка, ключЗначениеКолонки, значениеВЯчейке, элемент, документHtmlTableСтрока, документHtmlTableЯчейка;
	Перем записьHTML, записьDOM;
	
	Если таблица = Неопределено ИЛИ таблица.Количество() = 0 Тогда Возврат "" конецЕсли;
	
	#Область ОпределениеПараметровФорматирования
	
	Если ТипЗнч(параметрыФорматирования) <> Тип("Структура") Тогда
		параметрыФорматирования = Новый Структура;
	КонецЕсли;
	
	Если списокКолонок = Неопределено Тогда
		списокКолонок = Новый СписокЗначений;
		Для Каждого колонка из таблица.Колонки цикл
			списокКолонок.Добавить(колонка.Имя, колонка.Заголовок);
		КонецЦикла;
	КонецЕсли;
	
	кодировка =
		?(параметрыФорматирования.Свойство("Кодировка"),
		параметрыФорматирования.Кодировка,
		"UTF-8");
		
	ширинаРамки =// в пикселях
		?(параметрыФорматирования.Свойство("ШиринаРамки"),
		параметрыФорматирования.ШиринаРамки,
		1);
		
	Если ширинаРамки <> 0 Тогда
		
		цветРамки =
			?(параметрыФорматирования.Свойство("ЦветРамки"),
			параметрыФорматирования.ЦветРамки,
			"");
			
		цветРамкиЯркий =
			?(параметрыФорматирования.Свойство("ЦветРамкиЯркий"),
			параметрыФорматирования.ЦветРамкиЯркий,
			"");
			
		цветРамкиТёмный =
			?(параметрыФорматирования.Свойство("ЦветРамкиТемный"),
			параметрыФорматирования.ЦветРамкиТемный,
			"");
			
		типРамки =// доступные типы рамок: void, above, below, lhs, rhs, hsides, vsides, box
			?(параметрыФорматирования.Свойство("ТипРамки"),
			параметрыФорматирования.ТипРамки,
			"box");
			
		линии =// допустимо: all, groups, cols, none, rows
			?(параметрыФорматирования.Свойство("Линии"),
			параметрыФорматирования.Линии,
			"all");
			
	КонецЕсли;
	
	расстояниеМеждуЯчейками =
		?(параметрыФорматирования.Свойство("МеждуЯчейками"),
		параметрыФорматирования.МеждуЯчейками,
		1);
		
	отступДоЯчейки =
		?(параметрыФорматирования.Свойство("ОтступДоЯчейки"),
		параметрыФорматирования.ОтступДоЯчейки,
		1);
		
	ширина =// макс.ширина, пиксели или проценты
		?(параметрыФорматирования.Свойство("Ширина"),
		параметрыФорматирования.Ширина,
		"100%");
		
	высота =
		?(параметрыФорматирования.Свойство("Высота"),
		параметрыФорматирования.Высота,
		1);
		
	цветФона =
		?(параметрыФорматирования.Свойство("ЦветФона"),
		параметрыФорматирования.ЦветФона,
		"");
		
	выравниваниеТаблицы =
		?(параметрыФорматирования.Свойство("Выравнивание"),
		параметрыФорматирования.Выравнивание,
		"middle");//left/middle/right
		
	выравниваниеГоризонтальное =
		?(параметрыФорматирования.Свойство("ВыравниваниеГоризонтальное"),
		параметрыФорматирования.ВыравниваниеГоризонтальное,
		"left");//left/middle/right
		
	выравниваниеВертикальное =
		?(параметрыФорматирования.Свойство("ВыравниваниеВертикальное"),
		параметрыФорматирования.ВыравниваниеВертикальное,
		"center");//left/middle/right
		
	Если htmlДокументВладелец = Неопределено Тогда
		документHtml = Новый ДокументHTML("");
		документHtmlBody = документHtml.СоздатьЭлемент("BODY");
		документHtml.Тело = документHtmlBody;
	Иначе
		документHtml = htmlДокументВладелец;
		документHtmlBody = документHtml.Тело;
	КонецЕсли;
	
	документHtmlTable = документHtml.СоздатьЭлемент("TABLE");
	
	документHtmlTable.Выравнивание = выравниваниеТаблицы; // align
	документHtmlTable.Рамка = СокрЛП(ширинаРамки); // border
	документHtmlTable.ОтступДоЯчейки = СокрЛП(отступДоЯчейки); // cellPadding
	документHtmlTable.РасстояниеМеждуЯчейками = СокрЛП(расстояниеМеждуЯчейками); // cellSpacing
	документHtmlTable.ЦветФона = СокрЛП(цветФона); // bgColor
	документHtmlTable.Ширина = СокрЛП(ширина); // width
	
	Если ширинаРамки <> 0 Тогда
		документHtmlTable.Линии = СокрЛП(линии); // rules
	КонецЕсли;
	
	// ставим параметры таблицы в целом, НЕ имеющие свойств в объектной модели 1С
	// ставим их в атрибуты именно к таб, а не ко всему Телу документа, и не к Телу таблицы
	
	документHtmlАтрибут = документHtml.СоздатьАтрибут("height");
	документHtmlАтрибут.Значение = СокрЛП(высота);
	документHtmlTable.Атрибуты.УстановитьИменованныйЭлемент(документHtmlАтрибут);
	
	документHtmlАтрибут = документHtml.СоздатьАтрибут("cols");
	документHtmlАтрибут.Значение = СокрЛП(таблица.Колонки.Количество());
	документHtmlTable.Атрибуты.УстановитьИменованныйЭлемент(документHtmlАтрибут);
	
	Если запретПереносаСлов Тогда
		документHtmlАтрибут = документHtml.СоздатьАтрибут("nowrap");
		документHtmlTable.Атрибуты.УстановитьИменованныйЭлемент(документHtmlАтрибут);
	КонецЕсли;
	
	Если ширинаРамки <> 0 Тогда
		
		документHtmlАтрибут = документHtml.СоздатьАтрибут("borderColor");
		документHtmlАтрибут.Значение = СокрЛП(цветРамки);
		документHtmlTable.Атрибуты.УстановитьИменованныйЭлемент(документHtmlАтрибут);
		
		документHtmlАтрибут = документHtml.СоздатьАтрибут("borderColorLight");
		документHtmlАтрибут.Значение = СокрЛП(цветРамкиЯркий);
		документHtmlTable.Атрибуты.УстановитьИменованныйЭлемент(документHtmlАтрибут);
		
		документHtmlАтрибут=документHtml.СоздатьАтрибут("borderColorDark");
		документHtmlАтрибут.Значение=СокрЛП(цветРамкиТёмный);
		документHtmlTable.Атрибуты.УстановитьИменованныйЭлемент(документHtmlАтрибут);
		
		документHtmlАтрибут = документHtml.СоздатьАтрибут("frame");
		документHtmlАтрибут.Значение = СокрЛП(типРамки);
		документHtmlTable.Атрибуты.УстановитьИменованныйЭлемент(документHtmlАтрибут);
		
	КонецЕсли;
	
	#КонецОбласти
	
	документHtmlTBody = документHtml.СоздатьЭлемент("TBODY");
	документHtmlTable.ДобавитьДочерний(документHtmlTBody);
	документHtmlBody.ДобавитьДочерний(документHtmlTable);
	
	// Заголовок
	
	Если НЕ ПустаяСтрока(заголовокТаблицы) Тогда
		//документHtmlTableCaption = документHtmlTable.СоздатьЗаголовок();
		документHtmlTableCaption = документHtml.СоздатьЭлемент("caption");
		документHtmlTableCaption.ТекстовоеСодержимое = заголовокТаблицы;
		документHtmlTable.ДобавитьДочерний(документHtmlTableCaption);
	КонецЕсли;
	
	// Шапка
	
	документHtmlTableСтрока = документHtmlTable.ВставитьСтроку(1);
	документHtmlTableСтрока.ВертикальноеПоложение = выравниваниеВертикальное;
	документHtmlTableСтрока.Выравнивание = выравниваниеГоризонтальное;
	документHtmlTableСтрока.ЦветФона = цветФона;
	документHtmlTBody.ДобавитьДочерний(документHtmlTableСтрока);
	
	Для Каждого колонка из списокКолонок цикл
		
		документHtmlTableЯчейка = документHtml.СоздатьЭлемент("TD");
		
		документHtmlАтрибут = документHtml.СоздатьАтрибут("style");
		документHtmlАтрибут.Значение = "font-weight:bold";
		документHtmlTableЯчейка.Атрибуты.УстановитьИменованныйЭлемент(документHtmlАтрибут);
		
		документHtmlTableЯчейка.ТекстовоеСодержимое = СокрЛП(колонка.Представление);
		документHtmlTableСтрока.ДобавитьДочерний(документHtmlTableЯчейка);
		
	КонецЦикла;
	
	// Таблиця
	
	Для Каждого строка из таблица цикл
		
		#Если Клиент Тогда
		ОбработкаПрерыванияПользователя();
		#КонецЕсли
		
		// вопреки документации, Индекс это обязательный параметр
		// хотя, строку можно добавлять и так:
		//документHtmlTableСтрока = документHtml.СоздатьЭлемент("TR"), но ИндексСтроки поменять будет нельзя!
		документHtmlTableСтрока = документHtmlTable.ВставитьСтроку(1);
		
		документHtmlTableСтрока.ВертикальноеПоложение = выравниваниеВертикальное;
		документHtmlTableСтрока.Выравнивание = выравниваниеГоризонтальное;
		документHtmlTableСтрока.ЦветФона = цветФона;
		
		документHtmlTBody.ДобавитьДочерний(документHtmlTableСтрока);
		
		// коллекция Ячейки - для чтения, а нам надо добавлять
		
		Для Каждого колонка из списокКолонок цикл
			
			#Если Клиент Тогда
			ОбработкаПрерыванияПользователя();
			#КонецЕсли
			
			значениеВЯчейке = строка[колонка.Значение];
			
			// это почему-то вообще не заработало ни при каких...
			//документHtmlTableЯчейка = документHtmlTableСтрока.ВставитьЯчейку(1);
			документHtmlTableЯчейка = документHtml.СоздатьЭлемент("TD");
			
			Если Тип("ТаблицаЗначений") = ТипЗнч(значениеВЯчейке) Тогда
				
				документHtmlTableЯчейка.ДобавитьДочерний(ТаблицаПолучитьHTMLПредставлениеСтрокой(значениеВЯчейке, параметрыФорматирования, запретПереносаСлов, документHtml));
				
			ИначеЕсли Тип("Массив") = ТипЗнч(значениеВЯчейке) Тогда
				
				Для Каждого элемент из значениеВЯчейке цикл
					
					#Если Клиент Тогда
					ОбработкаПрерыванияПользователя();
					#КонецЕсли
					
					Если Тип("ТаблицаЗначений") = ТипЗнч(элемент) Тогда
						
						документHtmlTableЯчейка.ДобавитьДочерний(ТаблицаПолучитьHTMLПредставлениеСтрокой(элемент, параметрыФорматирования, запретПереносаСлов, документHtml));
						
					Иначе // вложенные массивы поддерживать не будем, но при желании можно сделать
						
						документHtmlАбзац = документHtml.СоздатьЭлемент("P"); // можно, например, так
						документHtmlАбзац.ТекстовоеСодержимое = СокрЛП(Строка(элемент));
						документHtmlTableЯчейка.ДобавитьДочерний(документHtmlАбзац);
						
					КонецЕсли;
					
				КонецЦикла;
				
			Иначе // записываем строковое представление
				
				Если Тип("Число") = ТипЗнч(значениеВЯчейке) Тогда
					документHtmlАтрибут = документHtml.СоздатьАтрибут("align");
					документHtmlАтрибут.Значение = "right";
					документHtmlTableЯчейка.Атрибуты.УстановитьИменованныйЭлемент(документHtmlАтрибут);
				КонецЕсли;
				
				документHtmlTableЯчейка.ТекстовоеСодержимое = СокрЛП(Строка(значениеВЯчейке));
				
			КонецЕсли;
			
			документHtmlTableСтрока.ДобавитьДочерний(документHtmlTableЯчейка);
			
		КонецЦикла;
		
	КонецЦикла;
	
	Если htmlДокументВладелец <> Неопределено Тогда
		
		Возврат документHtmlTable; // нужна таблица как ЭлементHTML
		
	Иначе
		
		// нужен полноценный текст результата, записываем получившееся
		
		записьHTML = Новый ЗаписьHTML;
		
		записьHTML.УстановитьСтроку(); // вопреки документации, параметр Кодировка не допускается
		
		записьDOM = Новый ЗаписьDOM; // обойдёмся без явного указания конфигурации записи DOM
		
		записьDOM.Записать(документHtml, записьHTML);
		
		Возврат записьHTML.Закрыть()
		
	КонецЕсли;
	
КонецФункции

Функция ТаблицаСохранитьВExcel(таблица, массивНаименованийКолонок, полноеИмяФайла, комментарий) Экспорт
	
	Перем количествоЗаписанныхЯчеек, счетчикСтрок, счетчикКолонок, имяКолонки, колонка, столбец, ячейкаЗначение;
	Перем excelCOM, допустимаяДлинаИмениЛистаExcel, номерЛиста, книгаExcel, листExcel, ячейкаExcel;
	
	количествоЗаписанныхЯчеек = 0;
	номерЛиста = 1;
	
	excelCOM = ExcelCOMКнигаПолучить(полноеИмяФайла, номерЛиста);
	Если excelCOM = Неопределено Тогда Возврат Ложь конецЕсли;
	
	допустимаяДлинаИмениЛистаExcel = 31;
	книгаExcel = excelCOM.WorkBooks.Add();
	листExcel = книгаExcel.Sheets(номерЛиста);
	
	листExcel.Name = Лев(СтрокаУбратьНедопустимыеСимволы(комментарий), допустимаяДлинаИмениЛистаExcel);
	
	// Шапка
	
	счетчикСтрок = 1;
	счетчикКолонок = 1;
	Для Каждого имяКолонки из массивНаименованийКолонок цикл
		листExcel.Cells(счетчикСтрок, счетчикКолонок).Value = имяКолонки;
		счетчикКолонок = счетчикКолонок + 1;
	КонецЦикла;
	
	// Збереження строкових даних
	
	счетчикКолонок = 1;
	Для Каждого имяКолонки из массивНаименованийКолонок цикл
		
		счетчикСтрок = 2;
		Для Каждого строка из таблица цикл
			
			ячейкаЗначение = строка[имяКолонки];
			ячейкаExcel = листExcel.Cells(счетчикСтрок, счетчикКолонок);
			ячейкаExcel.NumberFormat = "@";
			ячейкаExcel.Value = Строка(ячейкаЗначение);
			количествоЗаписанныхЯчеек = количествоЗаписанныхЯчеек + 1;
			
			счетчикСтрок = счетчикСтрок + 1;
			
		КонецЦикла;
		
		счетчикКолонок = счетчикКолонок + 1;
		
	КонецЦикла;
	
	Попытка
		
		книгаExcel.SaveAs(полноеИмяФайла);
		
	Исключение
		
		Если ИнформацияОбОшибке().Причина <> Неопределено Тогда
			
			Сообщить(ИнформацияОбОшибке().Причина.Описание, СтатусСообщения.Важное);
			
		Иначе
			
			таблица.Очистить();
			ExcelCOMЗакрыть(excelCOM);
			
			#Если Клиент Тогда
			Сигнал();
			#КонецЕсли
			
			ВызватьИсключение
			
		КонецЕсли;
		
		количествоЗаписанныхЯчеек = 0;
		
	КонецПопытки;
	
	ExcelCOMЗакрыть(excelCOM);
	
	Возврат количествоЗаписанныхЯчеек
	
КонецФункции

Функция ТаблицаЗначенийЛистаExcelПолучитьВДиалоге(номерЛиста = 1, номерНачальнойСтроки = 1) Экспорт
	
	Перем полноеИмяФайла, таблицаЗначений, колонка, счетчик, соответствиеИменРеквизитовТаблицы;
	
	полноеИмяФайла = ФайлВыбратьПолучитьПолноеИмя(ФайлФильтрВОкноДиалогаПолучить("xlsx xls"));
	
	Если ПустаяСтрока(полноеИмяФайла) Тогда Возврат Неопределено конецЕсли;
	
	таблицаЗначений = ТаблицаПрочитатьИзExcel(полноеИмяФайла);
	Если таблицаЗначений = Неопределено ИЛИ таблицаЗначений.Количество() = 0 Тогда Возврат таблицаЗначений конецЕсли;
	
	// отримання імен реквізитів із заголовків таблиці
	
	соответствиеИменРеквизитовТаблицы = Новый Соответствие;
	счетчик = 0;
	
	Для Каждого имяРеквизитаТаблицы из таблицаЗначений.Получить(0) цикл
		счетчик = счетчик + 1;
		соответствиеИменРеквизитовТаблицы.Вставить(СтрШаблон("К%1", счетчик), имяРеквизитаТаблицы);
	КонецЦикла;
	
	Для Каждого колонка из таблицаЗначений.Колонки цикл
		Попытка
			колонка.Имя = соответствиеИменРеквизитовТаблицы.Получить(колонка.Имя);
		Исключение
			колонка.Имя = e_ОбщегоНазначения.СтрокаCamelStyleПолучить(соответствиеИменРеквизитовТаблицы.Получить(колонка.Имя));
		КонецПопытки;
	КонецЦикла;
	
	Возврат таблицаЗначений
	
КонецФункции

//ToDo: додати параметр - кількість стрічок - в першій комірці
Функция ТаблицаПрочитатьИзExcel(полноеИмяФайла, номерЛиста = 1, структураКолонок = Неопределено, Знач номерНачальнойСтроки = 0, Знач номерКонечнойСтроки = 0) Экспорт
	
	Перем excelCOM, книгаExcel, листExcel;
	Перем количествоСтрок, количествоКолонок, таблицаЗначений, новаяСтрока, колонкаТаблицыЗначений, ключИЗначение;
	Перем счетчикКолонок, счетчикСтрок, ячейкаExce, значениеВПервойЯчейкеl;
	
	excelCOM = ExcelCOMКнигаПолучить(полноеИмяФайла, номерЛиста);
	
	Если excelCOM = Неопределено Тогда Возврат Неопределено конецЕсли;
	
	СостояниеОтобразить(СтрШаблон("Чтение файла %1...", полноеИмяФайла));
	
	Попытка
		
		книгаExcel = excelCOM.Workbooks.Open(полноеИмяФайла,, Истина);
		excelCOM.ActiveWorkbook.Activate();// имя не может совпадать со встроенным именем
		
	Исключение
		
		Если книгаExcel <> Неопределено Тогда
			книгаExcel = Неопределено;
		КонецЕсли;
		
		ExcelCOMЗакрыть(excelCOM);
		СообщениеОтобразить(СтрШаблон("Ошибка во время открытия книги %1.", полноеИмяФайла));
		
		Возврат Неопределено
		
	КонецПопытки;
	
	Попытка
		
		листExcel = книгаExcel.Sheets(номерЛиста);
		
	Исключение
		
		Если книгаExcel <> Неопределено Тогда
			книгаExcel = Неопределено;
		КонецЕсли;
		
		Если листExcel <> Неопределено Тогда
			листExcel = Неопределено;
		КонецЕсли;
		
		ExcelCOMЗакрыть(excelCOM);
		СообщениеОтобразить(СтрШаблон("Ошибка во время листа %1 открытия книги %2.", номерЛиста, полноеИмяФайла));
		
		Возврат Неопределено
		
	КонецПопытки;
	
	количествоСтрок = excelCOM.Cells(1, 1).SpecialCells(11).Row;
	количествоКолонок = excelCOM.Cells(1, 1).SpecialCells(11).Column;
	
	таблицаЗначений = Новый ТаблицаЗначений;
	
	Если структураКолонок = Неопределено Тогда
		
		Для счетчикКолонок = 1 по количествоКолонок цикл
			колонкаТаблицыЗначений = таблицаЗначений.Колонки.Добавить("К" + СтрЗаменить(счетчикКолонок, Символы.НПП, ""));
		КонецЦикла;
		
	Иначе
		
		счетчикКолонок = 0;
		
		Для Каждого ключИЗначение из структураКолонок цикл
			счетчикКолонок = счетчикКолонок + 1;
			колонкаТаблицыЗначений = таблицаЗначений.Колонки.Добавить(ключИЗначение.Ключ);
			Если ЗначениеЗаполнено(ключИЗначение.Значение) Тогда Продолжить конецЕсли;
			структураКолонок[ключИЗначение.Ключ] = счетчикКолонок;
		КонецЦикла;
		
	КонецЕсли;
	
	номерНачальнойСтроки =
		?(номерНачальнойСтроки = 0,
		1,
		номерНачальнойСтроки);
	значениеВПервойЯчейке = листExcel.Cells(1, 1).Value;
	
	Если номерКонечнойСтроки = 0 И ЗначениеЗаполнено(значениеВПервойЯчейке) И НЕ ОбщегоНазначения.ЕстьНеЦифры(значениеВПервойЯчейке) Тогда
		номерКонечнойСтроки = Мин(значениеВПервойЯчейке, количествоСтрок);
	Иначе
		номерКонечнойСтроки = количествоСтрок;
	КонецЕсли;
	
	номерКонечнойСтроки = Мин(номерКонечнойСтроки, количествоСтрок);
	
	Для счетчикСтрок = номерНачальнойСтроки по номерКонечнойСтроки цикл
		
		#Если Клиент Тогда
		Состояние(СтрШаблон(
			"Чтение данных листа %1: %2 / %3...",
			номерЛиста,
			счетчикСтрок,
			номерКонечнойСтроки));
		ОбработкаПрерыванияПользователя();
		#КонецЕсли
		
		новаяСтрока = таблицаЗначений.Добавить();
		
		Если структураКолонок = Неопределено Тогда
			
			Для номерКолонки = 1 по количествоКолонок цикл
				ячейкаExcel = листExcel.Cells(счетчикСтрок, номерКолонки);
				новаяСтрока["К" + Формат(номерКолонки, "ЧГ=0")] = ячейкаExcel.Value;
			КонецЦикла;
			
		Иначе
			
			Для Каждого ключИЗначение из структураКолонок цикл
				ячейкаExcel = листExcel.Cells(счетчикСтрок, ключИЗначение.Значение);
				новаяСтрока[ключИЗначение.Ключ] = ячейкаExcel.Value;
			КонецЦикла;
			
		КонецЕсли;
		
	КонецЦикла;
	
	ExcelCOMЗакрыть(excelCOM);
	
	Возврат таблицаЗначений
	
КонецФункции

Функция ТаблицаЗаполнитьИзExcel(полноеИмяФайла, таблица, элементФормыТаблица, номерЛиста = 1, номерСтрокиНачалоЗаголовков = 1, номерСтрокиНачалоДанных = 2) Экспорт
	
	Перем количествоСтрок, количествоКолонок, счетчикСтрок, счетчикКолонок, ячейкаЗначение, ячейкаЗначениеБезПробелов;
	Перем excel, версияExcel;
	Перем естьОтсутствиеКолонкиФормы, списокКолонокФайла, колонкаФайла, колонкаФормы, новаяСтрока;
	Перем строкаСостояния, коэффициент;
	Перем символПробелаОсновной;
	
	символПробелаОсновной = Символ(32);
	
	excel = ExcelCOMКнигаПолучить(полноеИмяФайла, номерЛиста);
	
	Если excel = Неопределено Тогда Возврат Ложь конецЕсли;
	
	списокКолонокФайла = Новый СписокЗначений();
	
	// Визначення кількості даних у файлі
	
	Попытка
		
		excel.Sheets.Select(номерЛиста);
		версияExcel = Лев(excel.Version, Найти(excel.Version, ".") - 1);
		
		Если версияExcel = "8" Тогда
			количествоСтрок = excel.Cells.CurrentRegion.Rows.Count;
			количествоКолонок = Макс(excel.Cells.CurrentRegion.Columns.Count, 13);
		Иначе
			количествоСтрок = excel.Cells(1, 1).SpecialCells(11).Row;
			количествоКолонок = excel.Cells(1, 1).SpecialCells(11).Column;
		Конецесли;
		
		// Визначення заголовків колонок файла
		
		счетчикКолонок = 1;
		Пока ЗначениеЗаполнено(excel.Cells(номерСтрокиНачалоЗаголовков, счетчикКолонок).Text) цикл
			ячейкаЗначение = excel.Cells(номерСтрокиНачалоЗаголовков, счетчикКолонок).Text;
			ячейкаЗначениеБезПробелов = СтрЗаменить(ячейкаЗначение, символПробелаОсновной, "");
			списокКолонокФайла.Добавить(ячейкаЗначениеБезПробелов, ячейкаЗначение);
			счетчикКолонок = счетчикКолонок + 1;
		КонецЦикла;
		
		// Перевірка відповідності таблиці файла таблиці форми
		
		естьОтсутствиеКолонкиФормы = Ложь;
		
		счетчикКолонок = 0;
		Для Каждого колонкаФормы из элементФормыТаблица.Колонки цикл
			
			колонкаФайла = списокКолонокФайла.Получить(счетчикКолонок);
			Если колонкаФормы.Имя = "НомерСтроки" Тогда Продолжить конецЕсли;
			
			Если списокКолонокФайла.НайтиПоЗначению(колонкаФормы.Имя) = Неопределено Тогда
				Сообщить(НСтр("ru='В файле отсутствует колонка: '; uk='У файлі відсутня колонка: '") + колонкаФормы.Имя, СтатусСообщения.Внимание);
				естьОтсутствиеКолонкиФормы = Истина;
			КонецЕсли;
			
			счетчикКолонок = счетчикКолонок + 1;
			
		КонецЦикла;
		
		Если естьОтсутствиеКолонкиФормы Тогда
			ExcelCOMЗакрыть(excel);
			Возврат 0
		КонецЕсли;
		
		// Заповнення таблиці
		
		таблица.Очистить();
		
		количествоПрочитанныхЯчеек = количествоКолонок * (количествоСтрок - 1);
		коэффициент = 100 / количествоПрочитанныхЯчеек;
		
		строкаСостояния = НСтр("ru='Загрузка данных из файла'; uk='Завантаження даних із файла'");
		
		количествоПрочитанныхЯчеек = 0;
		Для счетчикСтрок = номерСтрокиНачалоДанных по количествоСтрок цикл
			
			#Если Клиент Тогда
			ОбработкаПрерыванияПользователя();
			Состояние(Формат(коэффициент * счетчикСтрок, "ЧЦ=3; ЧН=0") + "% - " + строкаСостояния);
			#КонецЕсли
			
			новаяСтрока = таблица.Добавить();
			
			Для Каждого колонкаФормы из элементФормыТаблица.Колонки цикл
				
				Если колонкаФормы.Имя = "НомерСтроки" Тогда Продолжить конецЕсли;
				
				счетчикКолонок = списокКолонокФайла.Индекс(списокКолонокФайла.НайтиПоЗначению(колонкаФормы.Имя));
				ячейкаЗначение = excel.Cells(счетчикСтрок, счетчикКолонок + 1).Text;
				новаяСтрока[колонкаФормы.Имя] = ячейкаЗначение;
				количествоПрочитанныхЯчеек = количествоПрочитанныхЯчеек + 1;
				
			КонецЦикла;
			
		КонецЦикла;
		
	Исключение
		
		Если НЕ ИнформацияОбОшибке().Причина = Неопределено Тогда
			
			#Если Клиент Тогда
			Сообщить(ИнформацияОбОшибке().Причина.Описание, СтатусСообщения.Важное);
			#КонецЕсли
			
		Иначе
			
			таблица.Очистить();
			ExcelCOMЗакрыть(excel);
			
			#Если Клиент Тогда
			Сигнал();
			#КонецЕсли
			
			ВызватьИсключение
			
		КонецЕсли;
		
		количествоПрочитанныхЯчеек = 0;
		
	КонецПопытки;
	
	ExcelCOMЗакрыть(excel);
	
	Возврат количествоПрочитанныхЯчеек
	
КонецФункции

Функция ТаблицаЗаполнитьИзXML(полноеИмяФайла, таблица) Экспорт
	
	Перем количествоПрочитанныхОбъектов, заголовокЭлемента, чтениеXML;
	Перем имяЭлемента, имяАтрибута, значениеАтрибута, новаяСтрока;
	
	количествоПрочитанныхОбъектов = 0;
	заголовокЭлемента = "Запись";
	чтениеXML = Новый ЧтениеXML;
	
	Попытка
		
		чтениеXML.ОткрытьФайл(полноеИмяФайла);
		
		Если НЕ чтениеXML.Прочитать() Тогда
			
			#Если Клиент Тогда
			Сигнал();
			Сообщить(НСтр("ru = 'Неверный формат файла: '; uk = 'Хибний формат файла: '")
				+ полноеИмяФайла + "!", СтатусСообщения.ОченьВажное);
			#КонецЕсли
			чтениеXML.Закрыть();
			
			Возврат 0
			
		КонецЕсли;
		
		таблица.Очистить();
		
		Пока чтениеXML.Прочитать() цикл
			
			Если чтениеXML.ТипУзла = ТипУзлаXML.НачалоЭлемента Тогда
				
				имяЭлемента = чтениеXML.Имя;
				
				Если имяЭлемента = заголовокЭлемента Тогда
					
					новаяСтрока = таблица.Добавить();
					
					Пока чтениеXML.ПрочитатьАтрибут() цикл
						
						имяАтрибута = чтениеXML.Имя;
						Если имяАтрибута = "НомерСтроки" Тогда продолжить конецЕсли;
						
						значениеАтрибута = чтениеXML.Значение;
						новаяСтрока[имяАтрибута] = значениеАтрибута;
						
					КонецЦикла;
					
					количествоПрочитанныхОбъектов = количествоПрочитанныхОбъектов + 1;
					
				Иначе
					
					#Если Клиент Тогда
					Сообщить(НСтр("ru='Неверный атрибут в XML-файле! Ожидается: '; uk='Невірний атрибут в XML-файлі! Очікується: '")
						+ заголовокЭлемента, СтатусСообщения.Важное);
					#КонецЕсли
					
					чтениеXML.Закрыть();
					Возврат 0
					
				КонецЕсли;
				
			КонецЕсли;
			
		КонецЦикла;
		
		//ЗначениеВРеквизитФормы(таблицаСтроковыхДанныхНаСервере, "Объект.ТаблицаДанных");
		
		чтениеXML.Закрыть();
		
	Исключение
		
		чтениеXML.Закрыть();
		
		Если НЕ ИнформацияОбОшибке().Причина = Неопределено Тогда
			#Если Клиент Тогда
			Сигнал();
			Сообщить(ИнформацияОбОшибке().Причина.Описание, СтатусСообщения.Важное);
			#КонецЕсли
		Иначе
			таблица.Очистить();
			ВызватьИсключение
		КонецЕсли;
		
		Возврат 0
		
	КонецПопытки;
	
	Возврат количествоПрочитанныхОбъектов
	
КонецФункции

Процедура ТаблицаОтобразитьВДиаграммуГанта(таблица, диаграмма, имяКолонкиТочка, имяКолонкиСерия, имяКолонкиЗначение,
	имяКолонкиИнтервал, имяКолонкиНачалоИнтервала = "Начало", имяКолонкиКонецИнтервала = "Конец", имяКолонкиРасшифровка = Неопределено) Экспорт
	
	Перем элемент, строкаДанных, интервал, точка, серия, значениеТочки, значениеСерии;
	
	диаграмма.Очистить();
	
	//диаграмма.АвтоОпределениеПолногоИнтервала = Ложь;
	//диаграмма.УстановитьПолныйИнтервал(НачалоПериода, КонецПериода);
	
	диаграмма.ОбластьЗаголовка.Текст = имяКолонкиСерия;
	//диаграмма.ОбластьЗаголовка.Шрифт = Новый Шрифт(, 8, Истина,, Истина);
	
	диаграмма.ОбластьПостроения.Заголовок = имяКолонкиТочка;
	//диаграмма.ОбластьПостроения.ЦветФона = WebЦвета.ТопленоеМолоко;
	
	// Шкала времени
	
	Если диаграмма.ОбластьПостроения.ШкалаВремени.Элементы.Количество() = 1 Тогда
		диаграмма.ОбластьПостроения.ШкалаВремени.Элементы.Добавить().Единица = ТипЕдиницыШкалыВремени.Час;
	КонецЕсли;
	
	Для Каждого элемент из диаграмма.ОбластьПостроения.ШкалаВремени.Элементы цикл
		Если НЕ элемент.Единица = ТипЕдиницыШкалыВремени.Час Тогда Продолжить конецЕсли;
		элемент.Кратность = 8;
		элемент.Формат = "ДФ = 'Ч'";
		элемент.ЛинииДелений = Новый Линия(ТипЛинииДиаграммы.Точечная);
	КонецЦикла;
	
	//диаграмма.ОбластьПостроения.ШкалаВремени.Положение = ПоложениеШкалыВремени.Низ;
	диаграмма.ОбластьПостроения.ШкалаВремени.ЦветФона = WebЦвета.ТопленоеМолоко;
	
	диаграмма.ОтображениеИнтервала = ОтображениеИнтервалаДиаграммыГанта.Плоский;
	
	диаграмма.ОтображениеТекстаЗначения = ОтображениеТекстаЗначенияДиаграммыГанта.Право;
	диаграмма.ПоддержкаМасштаба = ПоддержкаМасштабаДиаграммыГанта.ВсеДанные;
	диаграмма.РастягиваниеПоВертикали = РастягиваниеПоВертикалиДиаграммыГанта.РастягиватьСтроки;
	
	диаграмма.Обновление = Ложь;
	
	//таблица.Сортировать(имяКолонкиСерия);
	
	Для Каждого строкаДанных из таблица цикл
		
		значениеТочки = строкаДанных[имяКолонкиТочка];
		точка = диаграмма.УстановитьТочку(значениеТочки);
		точка.Текст = значениеТочки;
		
		значениеСерии = строкаДанных[имяКолонкиСерия];
		серия = диаграмма.УстановитьСерию(значениеСерии);
		серия.Текст = значениеСерии;
		серия.ШтриховкаПерекрывающихсяИнтервалов = Истина;
		//серия.ШтриховкаМеждуИнтервалами = Истина;
		//серия.Цвет = WebЦвета.БледноБирюзовый;
		
		значение = диаграмма.ПолучитьЗначение(точка, серия);
		значение.Текст = строкаДанных[имяКолонкиЗначение];
		//значение.Редактирование = Истина;
		//значение.Цвет = WebЦвета.БледноБирюзовый;
		
		интервал = значение.Добавить();
		интервал.Начало =
			?(ЗначениеЗаполнено(строкаДанных[имяКолонкиНачалоИнтервала]),
			строкаДанных[имяКолонкиНачалоИнтервала],
			ТекущаяДата());
		интервал.Конец =
			?(ЗначениеЗаполнено(строкаДанных[имяКолонкиКонецИнтервала]),
			строкаДанных[имяКолонкиКонецИнтервала],
			ТекущаяДата());
		интервал.Текст = строкаДанных[имяКолонкиИнтервал];
		
		Если НЕ имяКолонкиРасшифровка = Неопределено Тогда
			интервал.Расшифровка = строкаДанных[имяКолонкиРасшифровка];
		КонецЕсли;
		
		//интервал.Цвет = WebЦвета.БледноБирюзовый;
		
	КонецЦикла;
	
	диаграмма.Обновление = Истина;
	
КонецПроцедуры

Функция ТаблицаКолонкаЗаполнитьВExcel(полноеИмяФайла, таблица, соответствиеКолонокТаблицыВКниге, номерНачальнойСтроки = 1, номерЛиста = 1, запросНаСохранение = Ложь) Экспорт
	
	Перем excelCOM;
	
	excelCOM = ExcelCOMКнигаПолучить(полноеИмяФайла, номерЛиста);
	Если excelCOM = Неопределено Тогда Возврат Ложь конецЕсли;
	
	Попытка
		книгаExcel = excelCOM.WorkBooks.Open(полноеИмяФайла);
		листExcel = книгаExcel.Sheets(номерЛиста);
	Исключение
		ОтобразитьСообщениеОбОшибке(ОписаниеОшибки(), ИнформацияОбОшибке());
		Возврат Ложь
	КонецПопытки;
	
	индекс = 0;
	Для Каждого строка из таблица цикл
		
		Для Каждого параКлючИЗначение из соответствиеКолонокТаблицыВКниге цикл
			листExcel.Cells(номерНачальнойСтроки + индекс, параКлючИЗначение.Значение).Value = строка[параКлючИЗначение.Ключ];
		КонецЦикла;
		
		индекс = индекс + 1;
		
	КонецЦикла;
	
	excelCOM.Workbooks.Application.DisplayAlerts = запросНаСохранение;
	
	Попытка
		
		книгаExcel.SaveAs(полноеИмяФайла);
		
	Исключение
		
		Если ИнформацияОбОшибке().Причина <> Неопределено Тогда
			
			Сообщить(ИнформацияОбОшибке().Причина.Описание, СтатусСообщения.Важное);
			
		Иначе
			
			ExcelCOMЗакрыть(excelCOM);
			
			#Если Клиент Тогда
			Сигнал();
			#КонецЕсли
			
			ВызватьИсключение
			
		КонецЕсли;
		
	КонецПопытки;
	
	ExcelCOMЗакрыть(excelCOM);
	
	Возврат Истина
	
КонецФункции

Функция ТаблицаПредставлениеИзмененийПолучитьСтрокой(таблицаДо, таблицаПосле, колонкиСтруктуры) Экспорт
	
	Перем представлениеИзменений, строка, структураЗначений, представлениеСтроки;
	
	представлениеИзменений = "";
	
	Для Каждого строка из таблицаПосле цикл
		
		структураЗначений = Новый Структура(колонкиСтруктуры);
		ЗаполнитьЗначенияСвойств(структураЗначений, строка);
		
		Если таблицаДо.Количество() > 0 И таблицаДо.НайтиСтроки(структураЗначений).Количество() > 0 Тогда Продолжить конецЕсли;
		
		представлениеСтроки = СтруктураПредставлениеПолучить(структураЗначений,, "; ", Истина);
		представлениеИзменений =
			?(ПустаяСтрока(представлениеИзменений),
			СтрШаблон("+ %1", представлениеСтроки),
			СтрШаблон(
				"%1
				|+ %2",
				представлениеИзменений,
				представлениеСтроки));
				
	КонецЦикла;
	
	Для Каждого строка из таблицаДо цикл
		
		структураЗначений = Новый Структура(колонкиСтруктуры);
		ЗаполнитьЗначенияСвойств(структураЗначений, строка);
		
		Если таблицаПосле.Количество() > 0 И таблицаПосле.НайтиСтроки(структураЗначений).Количество() > 0 Тогда Продолжить конецЕсли;
		
		представлениеСтроки = СтруктураПредставлениеПолучить(структураЗначений,, "; ", Истина);
		представлениеИзменений =
			?(ПустаяСтрока(представлениеИзменений),
			СтрШаблон("- %1", представлениеСтроки),
			СтрШаблон(
				"%1
				|- %2",
				представлениеИзменений,
				представлениеСтроки));
	КонецЦикла;
	
	Возврат представлениеИзменений
	
КонецФункции

Процедура ТаблицаУстановитьНижнийРегистрВЯчейках(таблица, массивНаименованийКолонок) Экспорт
	
	Перем имяКолонки, строка, ячейка;
	
	Для Каждого имяКолонки из массивНаименованийКолонок цикл
		Для Каждого строка из таблица цикл
			ячейка = строка[имяКолонки];
			строка[имяКолонки] = НРег(ячейка);
		КонецЦикла;
	КонецЦикла;
	
КонецПроцедуры

Процедура ТаблицаУдалитьНезначащиеСимволыВЯчейках(таблица, массивНаименованийКолонок) Экспорт
	
	Перем имяКолонки, строка, ячейка;
	
	Для Каждого имяКолонки из массивНаименованийКолонок цикл
		Для Каждого строка из таблица цикл
			ячейка = строка[имяКолонки];
			строка[имяКолонки] = СокрЛП(ячейка);
		КонецЦикла;
	КонецЦикла;
	
КонецПроцедуры

Функция ТаблицаТипаТаблицаЗначенийПроверить(таблица, возвращатьНеопределеноЕслиКоллекцияУправляемойФормы = Истина) Экспорт
	
	Перем этоТабличнаяЧасть;
	
	этоТабличнаяЧасть = ТаблицаТипаТабличнаяЧастьПроверить(таблица, Ложь);
	
	Если этоТабличнаяЧасть = Неопределено Тогда
		Возврат
			?(возвращатьНеопределеноЕслиКоллекцияУправляемойФормы,
			Неопределено,
			Ложь)
	Иначе
		Возврат НЕ этоТабличнаяЧасть
	КонецЕсли;
	
КонецФункции

Функция ТаблицаТипаТабличнаяЧастьПроверить(таблица, вызыватьИсключениеЕслиКоллекцияУправляемойФормы = Истина) Экспорт
	
	Перем кодЯзыкаСистемы;
	
	Если Тип("ДанныеФормыКоллекция") = ТипЗнч(таблица) Тогда
		
		Если вызыватьИсключениеЕслиКоллекцияУправляемойФормы Тогда
			ВызватьИсключениеОтсутствиеРеализации()
		Иначе
			Возврат Неопределено
		КонецЕсли;
		
	КонецЕсли;
	
	кодЯзыкаСистемы = КодЯзыкаСистемыПолучить();
	
	Если "ru" = кодЯзыкаСистемы Тогда
		
		Возврат
			СтрНайти(ТипЗнч(таблица), "Документ табличная часть: ") = 1
			ИЛИ СтрНайти(ТипЗнч(таблица), "Справочник табличная часть: ") = 1
			ИЛИ СтрНайти(ТипЗнч(таблица), "Обработка табличная часть: ") = 1
			
	ИначеЕсли "uk" = кодЯзыкаСистемы Тогда
		
		Возврат
			СтрНайти(ТипЗнч(таблица), "Документ таблична частина: ") = 1
			ИЛИ СтрНайти(ТипЗнч(таблица), "Довідник таблична частина: ") = 1
			ИЛИ СтрНайти(ТипЗнч(таблица), "Обробка таблична частина: ") = 1
			
	Иначе
		
		ВызватьИсключениеОтсутствиеРеализации()
		
	КонецЕсли;
	
КонецФункции

Функция ОбъектТабличныеЧастиПолучить(объект, получитьТолькоИмена = Ложь) Экспорт
	
	Перем коллекцияОбъектовМетаданных, табличныеЧасти;
	
	табличныеЧасти =
		?(получитьТолькоИмена,
		"",
		Новый Массив);
		
	Для Каждого коллекцияОбъектовМетаданных из объект.Метаданные().ТабличныеЧасти цикл
		Если получитьТолькоИмена Тогда
			табличныеЧасти = табличныеЧасти + коллекцияОбъектовМетаданных.Имя;
		Иначе
			табличныеЧасти.Добавить(коллекцияОбъектовМетаданных);
		КонецЕсли;
	КонецЦикла;
	
	Возврат табличныеЧасти
	
КонецФункции

Функция ТабличнаяЧастьМетаданныеПолучить(табличнаяЧасть) Экспорт
	
	Перем структураМетаданныхТабличнойЧасти, имя, типОбъекта;
	
	структураМетаданныхТабличнойЧасти = Новый Структура("Имя, Синоним, Колонки, ОбъектТип, ОбъектИмя, ОбъектСиноним");
	
	имя = Прав(Строка(табличнаяЧасть), СтрДлина(Строка(табличнаяЧасть)) - Найти(Строка(табличнаяЧасть), "."));
	структураМетаданныхТабличнойЧасти.ОбъектТип = Лев(табличнаяЧасть, Найти(табличнаяЧасть, ".") - СтрДлина("ТабличнаяЧасть."));
	типОбъекта = МетаданныеИмяМенеджераВМножественномИЕдинственномЧислеСоответствиеПолучить(Ложь).НайтиПоЗначению(структураМетаданныхТабличнойЧасти.ОбъектТип).Представление;
	структураМетаданныхТабличнойЧасти.ОбъектИмя = Лев(имя, Найти(имя, ".") - 1);
	структураМетаданныхТабличнойЧасти.ОбъектСиноним = Метаданные[типОбъекта][структураМетаданныхТабличнойЧасти.ОбъектИмя].Синоним;
	структураМетаданныхТабличнойЧасти.Имя = Прав(имя, СтрДлина(имя) - Найти(имя, "."));
	структураМетаданныхТабличнойЧасти.Синоним = Метаданные[типОбъекта][структураМетаданныхТабличнойЧасти.ОбъектИмя].ТабличныеЧасти[структураМетаданныхТабличнойЧасти.Имя].Синоним;
	структураМетаданныхТабличнойЧасти.Колонки = Метаданные[типОбъекта][структураМетаданныхТабличнойЧасти.ОбъектИмя].ТабличныеЧасти[структураМетаданныхТабличнойЧасти.Имя].Реквизиты;
	
	Возврат структураМетаданныхТабличнойЧасти
	
КонецФункции

Функция ОбъектТабличныеЧастиПолучитНаименования(объект) Экспорт
	
	Перем табличныеЧастиНаименования;
	
	табличныеЧастиНаименования = Новый СписокЗначений;
	
	Для Каждого объектМетаданных из объект.Метаданные().ТабличныеЧасти цикл
		табличныеЧастиНаименования.Добавить(объектМетаданных.Имя, объектМетаданных.Синоним);
	КонецЦикла;
	
	Возврат табличныеЧастиНаименования
	
КонецФункции

Функция СтрокаТаблицыТипаТабличнаяЧастьПроверить(строкаТаблицы) Экспорт
	Перем этоСтрокаТаблицыЗначений, этоСтрокаТабличнойЧасти, типТабличнаяЧастьДокумент, типТабличнаяЧастьСправочник;
	
	типТабличнаяЧастьДокумент = Тип("ДокументТабличнаяЧастьСтрока.ПоступлениеТоваровУслуг.Товары");
	типТабличнаяЧастьСправочник = Тип("СправочникТабличнаяЧасть.Контрагенты.ВидыДеятельности");
	
	этоСтрокаТаблицыЗначений =
		ТипЗнч(строкаТаблицы) = Тип("СтрокаТаблицыЗначений");
		
	этоСтрокаТабличнойЧасти =
		СтрНайти(ТипЗнч(строкаТаблицы), Лев(типТабличнаяЧастьДокумент, СтрНайти(типТабличнаяЧастьДокумент, ":") - 1)) > 0
		ИЛИ СтрНайти(ТипЗнч(строкаТаблицы), Лев(типТабличнаяЧастьСправочник, СтрНайти(типТабличнаяЧастьСправочник, ":") - 1)) > 0;
		
	Возврат
		?(НЕ этоСтрокаТаблицыЗначений И НЕ этоСтрокаТабличнойЧасти,
		Неопределено,
		этоСтрокаТабличнойЧасти)
КонецФункции

Процедура ТаблицаОтобразитьВТабличномДокументе(таблица, табличныйДокумент, макетТабличногоДокумента,
	строкаГруппировок = Неопределено, раскрыватьГруппировки = Неопределено,
	отображатьСтрокуИтогов = Истина, заголовок = Неопределено) Экспорт
	
	Перем списокГруппировок, имяГруппировки, уровеньГруппировки, областьМакета, ячейка, строка, колонка;
	Перем строкаСостояния, коэффициент, счетчик, счетчикКолонок;
	
	Если таблица.Количество() = 0 Тогда Возврат конецЕсли;
	
	Если строкаГруппировок <> Неопределено Тогда
		
		списокГруппировок = Новый СписокЗначений();
		
		Для Каждого имяГруппировки из ОбщегоНазначения.РазложитьСтрокуВМассивПодстрок(СтрокаУбратьНедопустимыеСимволы(строкаГруппировок)) цикл
			списокГруппировок.Добавить(, имяГруппировки, раскрыватьГруппировки);
		КонецЦикла;
		
	КонецЕсли;
	
	Если НЕ отображатьСтрокуИтогов Тогда
		строка = таблица.Получить(таблица.Количество() - 1);
		таблица.Удалить(строка);
	КонецЕсли;
	
	табличныйДокумент.Очистить();
	
	////////////////////////////////// Заголовки колонок //////////////////////////////////
	
	областьМакета = макетТабличногоДокумента.ПолучитьОбласть("КолонкиТаблицы");
	
	Для Каждого колонка из таблица.Колонки цикл
		ячейка = областьМакета.Область("R1C1");
		ячейка.Текст = колонка.Заголовок;
		табличноеПолеОформитьВнешнийВидЯчейки(ячейка, "Заголовок");
		табличныйДокумент.Вывести(областьМакета);
	КонецЦикла;
	
	табличныйДокумент.ФиксацияСверху = 1;
	
	////////////////////////////////// Детальні записи та підсумки таблиці //////////////////////////////////
	
	областьМакета = макетТабличногоДокумента.ПолучитьОбласть("СтрокиТаблицы");
	
	строкаСостояния = НСтр("ru='Заполнение табличного документа данными...'; uk='Заповнення табличного документа даними...'");
	коэффициент = 100 / таблица.Количество();
	
	счетчик = 0;
	счетчикКолонок = 1;
	Для Каждого строка из таблица цикл
		
		#Если Клиент Тогда
		ОбработкаПрерыванияПользователя();
		Состояние(Формат(коэффициент * счетчик, "ЧЦ=3; ЧН=0") + "% - " + строкаСостояния);
		#КонецЕсли
		
		Если строкаГруппировок <> Неопределено
			И раскрыватьГруппировки <> Неопределено Тогда
			табличныйДокументОпределитьГруппировкуСтроки(табличныйДокумент, областьМакета, строка, таблица.Колонки, списокГруппировок, строкаГруппировок);
		КонецЕсли;
		
		счетчикКолонок = 1;
		Для Каждого колонка из таблица.Колонки цикл
			ячейка = областьМакета.Область("R1C" + Строка(счетчикКолонок));
			ячейка.Текст = СокрЛП(Строка(строка[колонка.Имя]));
			табличноеПолеОформитьВнешнийВидЯчейки(ячейка);
			счетчикКолонок = счетчикКолонок + 1;
		КонецЦикла;
		
		табличныйДокумент.Вывести(областьМакета);
		
		счетчик = счетчик + 1;
		Если отображатьСтрокуИтогов И счетчик = таблица.Количество() - 1 Тогда Прервать конецЕсли;
		
	КонецЦикла;
	
	Если НЕ строкаГруппировок = Неопределено Тогда
		уровеньГруппировки = 0;
		Пока уровеньГруппировки < списокГруппировок.Количество() цикл
			табличныйДокумент.ЗакончитьГруппуСтрок();
			уровеньГруппировки = уровеньГруппировки + 1;
		КонецЦикла;
	КонецЕсли;
	
	////////////////////////////////// Підсумки //////////////////////////////////
	
	строка = таблица.Получить(таблица.Количество() - 1);
	
	счетчикКолонок = 1;
	Для Каждого колонка из таблица.Колонки цикл
		
		ячейка = областьМакета.Область("R1C" + Строка(счетчикКолонок));
		
		Если отображатьСтрокуИтогов Тогда
			ячейка.Текст = СокрЛП(Строка(строка[колонка.Имя]));
			типОформления = "Итог";
		Иначе
			типОформления = "ВерхняяТолстаяЛиния";
		КонецЕсли;
		
		табличноеПолеОформитьВнешнийВидЯчейки(ячейка, типОформления);
		
		счетчикКолонок = счетчикКолонок + 1;
		
	КонецЦикла;
	
	Если отображатьСтрокуИтогов Тогда
		ячейка = областьМакета.Область("R1C" + Строка(счетчикКолонок));
		ячейка.Текст = "Итого";
		табличноеПолеОформитьВнешнийВидЯчейки(ячейка, "Запись");
		ячейка.Шрифт = Новый Шрифт(, 8, Истина, Ложь, Ложь, Ложь);
		табличныйДокумент.Вывести(областьМакета);
	КонецЕсли;
	
	ТабличныйДокументПоказать(табличныйДокумент, заголовок);
	
КонецПроцедуры

Функция ТаблицаПолучитьМассивСтрокИзСтруктур(таблица) Экспорт
	
	Перем массивСтрок, строка, структураСтрокиТаблицы;
	
	структураСтрокиТаблицы = ТаблицаСтруктураПолучить(таблица, Ложь);
	массивСтрок = Новый Массив;
	
	Для Каждого строка из таблица цикл
		новаяСтрока = СтруктураСкопировать(структураСтрокиТаблицы, Ложь);
		ЗаполнитьЗначенияСвойств(новаяСтрока, строка);
		массивСтрок.Добавить(новаяСтрока);
	КонецЦикла;
	
	Возврат массивСтрок
	
КонецФункции

Функция ТаблицаПолучитьИзМассивСтрокСтруктура(массивСтрок) Экспорт
	
	перем строка, новаяСтрока, таблицаЗначений;
	
	Если массивСтрок.Количество() = 0 Тогда Возврат Неопределено конецЕсли;
	
	таблицаЗначений = Новый ТаблицаЗначений();
	
	Для Каждого ключЗначение из массивСтрок.Получить(0) цикл
		таблицаЗначений.Колонки.Добавить(ключЗначение.Ключ);
	КонецЦикла;
	
	Для Каждого строка из массивСтрок цикл
		новаяСтрока = таблицаЗначений.Добавить();
		ЗаполнитьЗначенияСвойств(новаяСтрока, строка);
	КонецЦикла;
	
	Возврат таблицаЗначений
	
КонецФункции

// ТабличныйДокумент

Процедура ТабличныйДокументУстановитьДополнительныеПараметрыДляПечати(табличныйДокумент) Экспорт
	
	табличныйДокумент.РазмерСтраницы = "A4";
	//табличныйДокумент.ОбластьПечати = табличныйДокумент.Область(1, 1, макет.ВысотаТаблицы, макет.ШиринаТаблицы);//!!!
	
	//табличныйДокумент.ДвусторонняяПечать = ТипДвустороннейПечати.ПереворотВверх;//
	табличныйДокумент.ОриентацияСтраницы = ОриентацияСтраницы.Портрет;//
	
	табличныйДокумент.ОтображатьСетку = Ложь;
	табличныйДокумент.ОтображатьЗаголовки = Ложь;//
	табличныйДокумент.Защита = Истина;//
	табличныйДокумент.ТолькоПросмотр = Истина;// расшифровка
	табличныйДокумент.АвтоМасштаб = Ложь;// колонтитули
	
	табличныйДокумент.ПолеСнизу = 8;
	табличныйДокумент.НижнийКолонтитул.Выводить = Истина;
	табличныйДокумент.НижнийКолонтитул.НачальнаяСтраница = 1;
	табличныйДокумент.НижнийКолонтитул.ВертикальноеПоложение = ВертикальноеПоложение.Низ;
	
	табличныйДокумент.НижнийКолонтитул.Шрифт = Новый Шрифт("Verdana", 6,, Истина);
	
	табличныйДокумент.НижнийКолонтитул.ТекстСлева = Формат(ТекущаяДата(), "ДФ='dd.MM.yyyy HH:mm'; ДЛФ=");
	табличныйДокумент.НижнийКолонтитул.ТекстСправа = ПараметрыСеанса.ТекущийПользователь.Наименование;
	табличныйДокумент.НижнийКолонтитул.ТекстВЦентре = НастройкаПользователяПолучитьОсновнаяОрганизация(ПараметрыСеанса.ТекущийПользователь);
	
	//табличныйДокумент.Показать();//документСсылка.Метаданные().Имя, Строка(документСсылка.Метаданные().Синоним));
	//табличныйДокумент.Напечатать(РежимИспользованияДиалогаПечати.НеИспользовать);
	//УниверсальныеМеханизмы.НапечататьДокумент(табличныйДокумент, 1, Ложь, документСсылка.Метаданные().Синоним);
	
КонецПроцедуры

Процедура ТабличныйДокументПоказать(табличныйДокумент, заголовок, толькоПросмотр = Истина) Экспорт
	
	табличныйДокумент.ОриентацияСтраницы = ОриентацияСтраницы.Ландшафт;
	
	табличныйДокумент.ОтображатьСетку = Ложь;
	табличныйДокумент.ОтображатьЗаголовки = Истина;
	
	табличныйДокумент.ТолькоПросмотр = толькоПросмотр;// Расшифровка - Истина
	табличныйДокумент.РазрешитьПеретаскивание = Истина;
	
	табличныйДокумент.ПовторятьПриПечатиСтроки = табличныйДокумент.Область(1, 1, 1, табличныйДокумент.Ширина);
	
	// !!! Налаштування колонтитула безпосередньо перед викликом метода Показать():
	табличныйДокумент.ПолеСнизу = 7;
	табличныйДокумент.НижнийКолонтитул.Выводить = Истина;
	табличныйДокумент.НижнийКолонтитул.НачальнаяСтраница = 1;
	табличныйДокумент.НижнийКолонтитул.ВертикальноеПоложение = ВертикальноеПоложение.Низ;
	
	табличныйДокумент.НижнийКолонтитул.Шрифт = Новый Шрифт("Verdana", 6 ,, Истина);
	
	табличныйДокумент.НижнийКолонтитул.ТекстСлева = Формат(ТекущаяДата(), "ДФ='dd.MM.yyyy HH:mm'; ДЛФ=");
	табличныйДокумент.НижнийКолонтитул.ТекстСправа = ПараметрыСеанса.ТекущийПользователь.Наименование;
	табличныйДокумент.НижнийКолонтитул.ТекстВЦентре = заголовок;
	
	табличныйДокумент.Показать(заголовок, Строка(заголовок));
	
КонецПроцедуры

Функция ВычислитьИтогВыделенныхЯчеекТабличногоДокумента(полеТабличногоДокумента, итогКоличеством = Ложь, пропускатьПустыеЗначения = Истина) Экспорт
	Перем итог, значение, область, индексСтрока, индексКолонка, символПробелаОсновной;
	
	символПробелаОсновной = Символ(32);
	
	итог = 0;
	
	Для Каждого область из полеТабличногоДокумента.ВыделенныеОбласти цикл
		Если ТипЗнч(область) = Тип("ОбластьЯчеекТабличногоДокумента") Тогда
			Для индексСтрока = область.Верх по область.Низ цикл
				Для индексКолонка = Область.Лево по область.Право цикл
					
					Попытка
						значение = полеТабличногоДокумента.Область("R" + Формат(индексСтрока, "ЧГ=0") + "C" + Формат(индексКолонка, "ЧГ=0")).Текст;
						
						Если ПустаяСтрока(Строка(значение)) И пропускатьПустыеЗначения Тогда Продолжить конецЕсли;
						
						Если итогКоличеством Тогда
							итог = итог + 1;
							
						Иначе
							итогКоличеством = Ложь;
							итог = итог + Число(СтрЗаменить(значение, символПробелаОсновной, ""));
						КонецЕсли;
						
					Исключение
						
						Возврат ВычислитьИтогВыделенныхЯчеекТабличногоДокумента(полеТабличногоДокумента, Истина);
					КонецПопытки;
					
				КонецЦикла;
			КонецЦикла;
		КонецЕсли;
	КонецЦикла;
	
	Возврат итог;
КонецФункции

Функция ПолеВводаУстановитьОграничениеТипаСвязьПоВладельцу(элементУправленияПолеВвода, типСтрокой = "") Экспорт
	Перем описаниеТипов, значениеПоУмолчанию;
	
	Если ТипЗнч(элементУправленияПолеВвода) <> Тип("ПолеВвода") Тогда Возврат Неопределено конецЕсли;
	
	описаниеТипов = Новый ОписаниеТипов(Строка(типСтрокой));
		
	Если описаниеТипов = Неопределено Тогда
		элементУправленияПолеВвода.ВыбиратьТип = Истина;
		//элементУправленияПолеВвода.Доступность = Ложь;
		
		значениеПоУмолчанию = Неопределено;
		
	Иначе
		
		элементУправленияПолеВвода.ОграничениеТипа = описаниеТипов;
		элементУправленияПолеВвода.ВыбиратьТип = Ложь;
		элементУправленияПолеВвода.Доступность = Истина;
		
		значениеПоУмолчанию = элементУправленияПолеВвода.ОграничениеТипа.ПривестиЗначение();// ТипЗначениеПоУмолчаниюПолучить(Строка(типСтрокой))
		
	КонецЕсли;
	
	СписокВыбораЭлементаУправленияУстановитьПоТипу(элементУправленияПолеВвода, Тип(типСтрокой));
	элементУправленияПолеВвода.Значение = значениеПоУмолчанию;
	
	Возврат значениеПоУмолчанию
	
КонецФункции

Процедура ТабличноеПолеПодвалеИтогиОтобразить(табличноеПоле, структураКолонок, дополнительныйСимвол = "*") Экспорт
	
	Перем колонка, значение;
	
	Для Каждого колонка из табличноеПоле.Колонки цикл
		
		Если НЕ колонка.Видимость ИЛИ НЕ структураКолонок.Свойство(колонка.Имя) Тогда Продолжить конецЕсли;
		
		значение = структураКолонок[колонка.Имя];
		
		Если значение = Неопределено Тогда
			
			Если колонка.ЭлементУправления = Неопределено Тогда Продолжить конецЕсли;
			
			Если колонка.ЭлементУправления.ТипЗначения.Типы().Получить(0) = Тип("Число") Тогда
				значение = табличноеПоле.Значение.Итог(колонка.Имя);
			Иначе
				значение = ТаблицаВыгрузитьСвернутьКолонку(табличноеПоле.Значение, колонка.Имя).Количество();
			КонецЕсли;
			
		КонецЕсли;
		
		колонка.ТекстПодвала =
			?(ПустаяСтрока(дополнительныйСимвол),
			значение,
			СокрЛП(значение) + дополнительныйСимвол);
			
	КонецЦикла;
	
	табличноеПоле.Подвал = Истина;
	
КонецПроцедуры

Процедура ТабличноеПолеТолькоПросмотрЭлементУправленияУстановитьПередНачаломИзменения(табличноеПоле, толькоПросмотр = Истина) Экспорт
	Перем колонка;
	
	Для Каждого колонка из табличноеПоле.Колонки цикл
		Если колонка.ЭлементУправления = Неопределено Тогда Продолжить конецЕсли;
		колонка.ЭлементУправления.ТолькоПросмотр = толькоПросмотр;
	КонецЦикла;
	
КонецПроцедуры

Функция ТабличноеПолеДобавитьКолонку(форма, заголовокКолонки, имяКолонки = "", имяТаблицы, имяТабличногоПоля = "", подсказкаВШапке = "", описаниеТипов = Неопределено, типЭлементаУправления = Неопределено, индекс = 0, имяСобытияЭлементаУправления = "", имяПроцедурыОбработчикаСобытия = "") Экспорт
#Если Клиент Тогда
	Перем табличноеПоле, таблицаЗначений, колонкаТабличногоПоля;
	
	Если ПустаяСтрока(имяКолонки) Тогда
		имяКолонки = СтрокаУбратьНедопустимыеСимволы(заголовокКолонки);
	КонецЕсли;
	
	таблицаЗначений = форма[имяТаблицы];
	табличноеПоле =
		?(ПустаяСтрока(имяТабличногоПоля),
		форма.ЭлементыФормы[имяТаблицы],
		форма.ЭлементыФормы[имяТабличногоПоля]);
		
	Если Тип("ТаблицаЗначений") = ТипЗнч(таблицаЗначений) Тогда
		таблицаЗначений.Колонки.Вставить(индекс, имяКолонки, описаниеТипов, заголовокКолонки);//Новый ОписаниеТипов("ПользовательИнформационнойБазы")
	Иначе
		таблицаЗначений.Колонки.Добавить(имяКолонки);
	КонецЕсли;
	
	колонкаТабличногоПоля = табличноеПоле.Колонки.Вставить(индекс, имяКолонки);
	колонкаТабличногоПоля.Данные = имяКолонки;
	колонкаТабличногоПоля.Имя = имяКолонки;
	колонкаТабличногоПоля.ТекстШапки = заголовокКолонки;
	колонкаТабличногоПоля.ПодсказкаВШапке =
		?(ПустаяСтрока(подсказкаВШапке),
		заголовокКолонки,
		подсказкаВШапке);
		
	Если типЭлементаУправления <> Неопределено Тогда
		колонкаТабличногоПоля.УстановитьЭлементУправления(типЭлементаУправления);//Тип("ПолеВвода")
	КонецЕсли;
	
	Если НЕ (ПустаяСтрока(имяСобытияЭлементаУправления) И ПустаяСтрока(имяПроцедурыОбработчикаСобытия)) Тогда
		колонкаТабличногоПоля.ЭлементУправления.УстановитьДействие(имяСобытияЭлементаУправления, Новый Действие(имяПроцедурыОбработчикаСобытия));//"Открытие", "ПользовательИБОткрытие"
	КонецЕсли;
	
	Возврат колонкаТабличногоПоля;
#КонецЕсли
КонецФункции

Процедура ТабличноеПолеСтрокаУстановитьДоступностьЭлементаУправления(табличноеПоле, доступностьКнопкиВыбора) Экспорт
	Перем колонка;
	
	Для Каждого колонка из табличноеПоле.Колонки цикл
		
		Если колонка.ЭлементУправления = Неопределено Тогда Продолжить конецЕсли;
		Если "Комментарий" = колонка.Имя Тогда Продолжить конецЕсли;
		
		колонка.ЭлементУправления.ТолькоПросмотр = НЕ доступностьКнопкиВыбора;
		колонка.ЭлементУправления.КнопкаВыбора = доступностьКнопкиВыбора;
		
	КонецЦикла;
	
КонецПроцедуры

Функция ТабличноеПолеВыгрузитьВСтруктуруСтроку(табличноеПоле, структура = Неопределено, строка = Неопределено) Экспорт
	Перем колонка;
	
	Если строка = Неопределено Тогда
		строка = табличноеПоле.ТекущаяСтрока;
	КонецЕсли;
	
	Если структура = Неопределено ИЛИ структура.Количество() = 0 Тогда
		
		структура = Новый Структура();
		
		Для Каждого колонка из табличноеПоле.Колонки цикл
			структура.Вставить(колонка.Имя, строка[колонка.Имя]);
		КонецЦикла;
		
	Иначе
		
		Для Каждого колонка из табличноеПоле.Колонки цикл
			структура[колонка.Имя] = строка[колонка.Имя];
		КонецЦикла;
		
	КонецЕсли;
	
КонецФункции

Функция ТабличныйДокументСохранить(табличныйДокументОтчета, имяФайла, путьКПапке = Неопределено, показыватьОповещениеОРазмещенииФайла = Истина) Экспорт
	
	Перем полноеИмяФайла, описаниеОшибки;
	
	Если путьКПапке = Неопределено Тогда
		путьКПапке = ПапкаДляСохраненияФайловПользователяОпределить();
		
		Если путьКПапке = Неопределено Тогда
			путьКПапке = СистемнаяПапкаПолучить("Desktop");
		КонецЕсли;
	КонецЕсли;
	
	полноеИмяФайла = путьКПапке + "\" + имяФайла;
	
	Попытка
		
		табличныйДокументОтчета.Записать(полноеИмяФайла, ТипФайлаТабличногоДокумента.XLSX);
		
		#Если Клиент Тогда
		Если показыватьОповещениеОРазмещенииФайла Тогда
			ПоказатьОповещениеПользователя(НСтр("ru='Информация'; uk='Інформація'"), полноеИмяФайла,
				НСтр("ru = 'Таблица сохранена в файл:'; uk = 'Таблицю збережено у файл:'") + Символы.ПС + полноеИмяФайла, БиблиотекаКартинок.СохранитьФайл);
		КонецЕсли;
		#КонецЕсли
	
	Исключение
		
		ОтобразитьСообщениеОбОшибке(ОписаниеОшибки(), ИнформацияОбОшибке());
		
	КонецПопытки;
	
	Возврат полноеИмяФайла
	
КонецФункции

// ДеревоЗначений

//ОбщегоНазначения.ВыгрузитьСтрокиДереваВТаблицуЗначений(
Функция ДеревоЗначенийСтрокиПолучить(деревоЗначений, структураКолонок = Неопределено, вВидеТаблицыЗначений = Ложь) Экспорт
	
	Перем колекцияСтрок, параКлючЗначение;
	
	Если вВидеТаблицыЗначений Тогда
		колекцияСтрок = Новый ТаблицаЗначений;
		Для Каждого параКлючЗначение из структураКолонок цикл
			колекцияСтрок.Колонки.Добавить(параКлючЗначение.Ключ,, параКлючЗначение.Значение);
		КонецЦикла;
	Иначе
		колекцияСтрок = Новый Массив;
	КонецЕсли;
	
	дополнитьРекурсивноКоллекциюСтрокДереваЗначений(колекцияСтрок, деревоЗначений);
	
	Возврат колекцияСтрок
	
КонецФункции

#КонецОбласти

Функция ТаблицаЗначенийНабораЗаписейРегистраВыгрузить(регистрНаборЗаписей) Экспорт
	
	Перем таблицаЗначений, объектМетаданных, параметрОбъектаМетаданных;
	
	таблицаЗначений = Новый ТаблицаЗначений;
	таблицаЗначений.Колонки.Добавить("Период");
	
	объектМетаданных = регистрНаборЗаписей.Метаданные();
	
	Для Каждого параметрОбъектаМетаданных из объектМетаданных.Измерения цикл
		таблицаЗначений.Колонки.Добавить(параметрОбъектаМетаданных.Имя,, параметрОбъектаМетаданных.Синоним);
	КонецЦикла;
	
	Для Каждого параметрОбъектаМетаданных из объектМетаданных.Ресурсы цикл
		таблицаЗначений.Колонки.Добавить(параметрОбъектаМетаданных.Имя,, параметрОбъектаМетаданных.Синоним);
	КонецЦикла;
	
	Для Каждого параметрОбъектаМетаданных из объектМетаданных.Реквизиты цикл
		таблицаЗначений.Колонки.Добавить(параметрОбъектаМетаданных.Имя,, параметрОбъектаМетаданных.Синоним);
	КонецЦикла;
	
	Для Каждого строка из регистрНаборЗаписей цикл
		новаяСтрока = таблицаЗначений.Добавить();
		ЗаполнитьЗначенияСвойств(новаяСтрока, строка);
	КонецЦикла;
	
	Возврат таблицаЗначений
	
КонецФункции

Функция КоллекцияОбъектовЗначенияОтобрать(Знач коллекцияЗначений, имяРеквизита, значениеРеквизита, модифицироватьИсходнуюКоллекцию = Истина) Экспорт
	
	Перем итератор, удалениеЭлементовКоллекцииПоИндексу, элементКоллекции;
	
	Если НЕ модифицироватьИсходнуюКоллекцию Тогда
		коллекцияЗначений = СкопироватьКоллекцию(коллекцияЗначений);
	КонецЕсли;
	
	итератор = коллекцияЗначений.Количество();
	удалениеЭлементовКоллекцииПоИндексу =
		Тип("Массив") = ТипЗнч(коллекцияЗначений);
		
	Пока итератор > 0 цикл
		
		итератор = итератор - 1;
		
		элементКоллекции = коллекцияЗначений[итератор];
		
		Попытка
			
			Если элементКоллекции[имяРеквизита] = значениеРеквизита Тогда Продолжить конецЕсли;
			
			Если удалениеЭлементовКоллекцииПоИндексу Тогда
				коллекцияЗначений.Удалить(итератор);
			Иначе
				коллекцияЗначений.Удалить(элементКоллекции);
			КонецЕсли;
			
		Исключение// помилка доступу
		КонецПопытки;
		
	КонецЦикла;
	
	Возврат коллекцияЗначений
	
КонецФункции

Функция МассивОбъектовСоздатьСоответствиеРеквизита(имяРеквизитаОбъекта, массив) Экспорт
	
	Перем соответствиеРеквизитаОбъекту;
	
	соответствиеРеквизитаОбъекту = Новый Соответствие;
	
	Для Каждого элемент из массив цикл
		соответствиеРеквизитаОбъекту.Вставить(элемент[имяРеквизитаОбъекта], элемент);
	КонецЦикла;
	
	Возврат соответствиеРеквизитаОбъекту
	
КонецФункции

Функция РеквизитОбъектовВыгрузитьМассив(имяРеквизита, объекты, удалитьПовторяющиесяЗначения = Ложь, добавлятьПустыеЗначения = Истина) Экспорт
	
	Перем значениеРеквизита, значенияРеквизитовОбъектов, объект, пустоеЗначение;
	
	Если ПустаяСтрока(имяРеквизита) ИЛИ объекты = Неопределено Тогда возврат Неопределено конецЕсли;
	
	значенияРеквизитовОбъектов = Новый Массив;
	
	Для Каждого объект из объекты цикл
		
		Если объект = Неопределено Тогда Продолжить конецЕсли;
		
		значениеРеквизита = Неопределено;
		
		Попытка
			значениеРеквизита = объект[имяРеквизита]
		Исключение
		КонецПопытки;
		
		Если значениеРеквизита = Неопределено Тогда
			пустоеЗначение = Истина;
		Иначе
			Попытка
				пустоеЗначение = НЕ ЗначениеЗаполнено(значениеРеквизита);
			Исключение
				пустоеЗначение = Ложь; // Проверка мутабельных значений не поддерживается
			КонецПопытки;
		КонецЕсли;
		
		Если пустоеЗначение Тогда
			
			Если добавлятьПустыеЗначения Тогда
				значенияРеквизитовОбъектов.Добавить(Неопределено);
			Иначе
				Продолжить
			КонецЕсли;
			
		Иначе
			
			значенияРеквизитовОбъектов.Добавить(объект[имяРеквизита]);
			
		КонецЕсли;
		
	КонецЦикла;
	
	Если удалитьПовторяющиесяЗначения Тогда
		МассивУдалитьПовторяющиесяЭлементы(значенияРеквизитовОбъектов);
	КонецЕсли;
	
	Возврат значенияРеквизитовОбъектов
	
КонецФункции

Функция РеквизитОбъектовПросуммировать(объекты, имяРеквизита, имяРеквизитаКоличество = "Количество", имяРеквизитаЗнака = "ВидДвижения") Экспорт
	Перем суммаРеквизитовОбъектов, объект;
	
	Если ПустаяСтрока(имяРеквизита) ИЛИ объекты = Неопределено Тогда возврат Неопределено конецЕсли;
	
	суммаРеквизитовОбъектов = 0;
	
	Для Каждого объект из объекты цикл
		сумма =
			?(ПустаяСтрока(имяРеквизитаКоличество),
			объект[имяРеквизита],
			объект[имяРеквизита] * объект[имяРеквизитаКоличество]);
		
		суммаРеквизитовОбъектов =
			?(ПустаяСтрока(имяРеквизитаЗнака),
			суммаРеквизитовОбъектов + сумма,
				?(Строка(объект.ВидДвижения) = Строка(Перечисления.ВидыДвиженийПриходРасход.Приход),
				суммаРеквизитовОбъектов + сумма,
				суммаРеквизитовОбъектов - сумма));
	КонецЦикла;
	
	Возврат суммаРеквизитовОбъектов;
КонецФункции

Функция РеквизитОбъектовВыгрузитьВТаблицу(имяРеквизита, объекты, удалитьПовторяющиесяЗначения = Ложь, вставлятьНеопределеноЕслиОтсутствует = Истина) Экспорт
	Перем значенияРеквизитовОбъектов, объект, новаяСтрока;
	
	Если ПустаяСтрока(имяРеквизита) ИЛИ объекты = Неопределено Тогда возврат Неопределено конецЕсли;
		
		значенияРеквизитовОбъектов = Новый ТаблицаЗначений;
		
		значенияРеквизитовОбъектов.Колонки.Добавить("Объект");
		значенияРеквизитовОбъектов.Колонки.Добавить(имяРеквизита);
		
		Для Каждого объект из объекты цикл
			значениеРеквизита = Неопределено;
			
			Если объект.Метаданные().Реквизиты.Найти(имяРеквизита) = Неопределено Тогда
				Если НЕ вставлятьНеопределеноЕслиОтсутствует Тогда Продолжить конецЕсли;
			Иначе
				значениеРеквизита = объект[имяРеквизита];
			КонецЕсли;
			
			Если
				значенияРеквизитовОбъектов.НайтиСтроки(Новый Структура(имяРеквизита, значениеРеквизита)).Количество() > 0 И
				удалитьПовторяющиесяЗначения
				Тогда Продолжить
			КонецЕсли;
			
			новаяСтрока = значенияРеквизитовОбъектов.Добавить();
			
			новаяСтрока.Объект = объект;
			новаяСтрока[имяРеквизита] = значениеРеквизита;
		КонецЦикла;
	
	Возврат значенияРеквизитовОбъектов;
КонецФункции

Функция РеквизитТабличнойЧастиОбъектаПроверитьНаличие(объект, имяТабличнойЧасти, имяРеквизита) Экспорт
	
	Попытка
		Возврат объект.Метаданные().ТабличныеЧасти[имяТабличнойЧасти].Реквизиты.Найти(имяРеквизита) <> Неопределено
	Исключение
		Возврат Неопределено
	КонецПопытки;
	
КонецФункции

Функция РеквизитОбъектаПроверитьНаличие(объект, возможноеИмяРеквизита) Экспорт
	
	Перем именаРеквизитов, значение;
	
	именаРеквизитов = СтрокаРазбитьНаСоставляющие(возможноеИмяРеквизита);
	
	Если именаРеквизитов.Количество() = 1 Тогда
		
		имяРеквизита = именаРеквизитов.Получить(0);
		
		Попытка
			значение = объект[имяРеквизита];
			Возврат Истина
		Исключение
			Возврат Ложь
		КонецПопытки;
		
	Иначе
		
		Для Каждого имяРеквизита из именаРеквизитов цикл
			Попытка
				значение = объект[имяРеквизита];
				Возврат имяРеквизита
			Исключение
				Продолжить
			КонецПопытки;
		КонецЦикла;
		
		Возврат ""
		
	КонецЕсли;
	
КонецФункции

Процедура КраткийСоставДокументаРеквизитУстановить(объект, массивСоставляющих) Экспорт
	
	Перем краткийСоставДокумента;
	
	краткийСоставДокумента =
		?(массивСоставляющих.Количество() = 0,
		"",
		Лев(МассивСоздатьПредставлениеЗначений(массивСоставляющих, ","), объект.Метаданные().Реквизиты.КраткийСоставДокумента.Тип.КвалификаторыСтроки.Длина));
		
	Если объект.КраткийСоставДокумента <> краткийСоставДокумента Тогда
		объект.КраткийСоставДокумента = краткийСоставДокумента;
	КонецЕсли;
	
КонецПроцедуры

Функция IRRМетодомСекущихРассчитать(доходы, суммаИнвестирования, точностьВычисления = 0.00001, возвращатьПроцентноеВыражение = Истина) Экспорт
	Перем irr1, irr2, irr;
	Перем nvp1, nvp2, nvp;
	Перем текстШаблона0, текстШаблона1, текстШаблона2, текстШаблона;
	
	irr1 = -0.9;
	irr2 = 0.9999;
	
	текстШаблона0 = СтрЗаменить(Строка(-суммаИнвестирования), ",", ".");
	
	Для счетчик = 1 по доходы.Количество() цикл
		текстШаблона0 = текстШаблона0 + "+" +
			СтрЗаменить(Строка(Формат(доходы[счетчик - 1], "ЧДЦ=3")), ",", ".") +
			"/Pow((1+х)," + Строка(счетчик) + ")";
	КонецЦикла;
	
	текстШаблона0 = СтрЗаменить(текстШаблона0, Символы.НПП, "");
	
	текстШаблона1 = СтрЗаменить(текстШаблона0, "х", "(" + СтрЗаменить(СтрЗаменить(Строка(irr1), ",", "."), Символы.НПП, "") + ")");
	текстШаблона2 = СтрЗаменить(текстШаблона0, "х", "(" + СтрЗаменить(СтрЗаменить(Строка(irr2), ",", "."), Символы.НПП, "") + ")");
	
	nvp1 = Вычислить(текстШаблона1);
	nvp2 = Вычислить(текстШаблона2);
	
	#Если Клиент Тогда
	Состояние(НСтр("ru = 'Выполняется расчет...'; uk = 'Виконується розрахунок...'"));
	#КонецЕсли
	
	Пока ИСТИНА Цикл
		
		#Если Клиент Тогда
		ОбработкаПрерыванияПользователя();
		#КонецЕсли
		
		irr = irr1 + (irr2 - irr1) / 2;
		текстШаблона = СтрЗаменить(текстШаблона0, "х", "(" + СтрЗаменить(СтрЗаменить(Строка(irr), ",", "."), Символы.НПП, "") + ")");
		nvp = Вычислить(текстШаблона);
		
		Если nvp * nvp1 < 0 Тогда
			irr2 = irr;
		Иначе
			irr1 = irr;
		КонецЕсли;
		
		Если
			nvp > -точностьВычисления
			И nvp < точностьВычисления Тогда
			Возврат
				?(возвращатьПроцентноеВыражение,
				irr * 100,
				irr)
		КонецЕсли;
		
	КонецЦикла;
	
КонецФункции

#КонецОбласти


#Область РізніТипиДаних

Функция СсылкаЭто(это) Экспорт
	
	Возврат ОбщегоНазначения.ЗначениеСсылочногоТипа(это)
	
КонецФункции

Функция СсылкаТипаДокумент(ссылка) Экспорт
	
	Возврат СтрНачинаетсяС(
		ОбщегоНазначения.ИмяТаблицыПоСсылке(ссылка),
		"Документ.")
		
КонецФункции

Функция СсылкаТипаСправочник(ссылка) Экспорт
	
	Возврат СтрНачинаетсяС(
		ОбщегоНазначения.ИмяТаблицыПоСсылке(ссылка),
		"Справочник.")
		
КонецФункции

Функция ДокументПроведениеРазрешить(ссылка) Экспорт
	
	Возврат ссылка.Метаданные().Проведение =
		Метаданные.СвойстваОбъектов.Проведение.Разрешить // При удалении; При отмене проведения
		
КонецФункции

Функция ДокументУдалениеДвиженийАвтоматически(ссылка) Экспорт
	
	Возврат ссылка.Метаданные().УдалениеДвижений =
		Метаданные.СвойстваОбъектов.УдалениеДвижений
		
КонецФункции

Функция ЗапросТекстЧастьГдеПолучить(имяТаблицы, коллекцияОтборов) Экспорт
	
	Перем текстЗапроса, счетчик;
	
	Если коллекцияОтборов.Количество() = 0 Тогда Возврат "" конецЕсли;
	
	текстЗапроса = "
	               |ГДЕ";
	
	счетчик = 0;
	
	Для Каждого элементОтбора из коллекцияОтборов цикл
		
		счетчик = счетчик + 1;
		
		Если ВидСравнения.Равно = элементОтбора.ВидСравнения Тогда
			
			текстЗапроса = СтрШаблон(
	               "%1
	               |	%2%3.%4 = &%4",
				текстЗапроса,
				?(счетчик = 1, "", "И "),
				имяТаблицы,
				элементОтбора.ИмяПоля);
				
		ИначеЕсли ВидСравнения.ВСписке = элементОтбора.ВидСравнения Тогда
			
			текстЗапроса = СтрШаблон(
	               "%1
	               |	%2%3.%4 В (&%4)",
				текстЗапроса,
				?(счетчик = 1, "", "И "),
				имяТаблицы,
				элементОтбора.ИмяПоля);
			
		ИначеЕсли ВидСравнения.ВИерархии = элементОтбора.ВидСравнения Тогда
			
			текстЗапроса = СтрШаблон(
	               "%1
	               |	%2%3.%4 В ИЕРАРХИИ(&%4)",
				текстЗапроса,
				?(счетчик = 1, "", "И "),
				имяТаблицы,
				элементОтбора.ИмяПоля);
				
		Иначе
			
			ВызватьИсключениеОтсутствиеРеализации(СтрШаблон("Отсутствует реализация формирования части «ГДЕ» текста запроса для вида сравнения %1.", элементОтбора.ВидСравнения))
			
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат текстЗапроса
	
КонецФункции

Функция ОбъектВыбратьВФорме(владелецФормы, структураДанных,
	структураОтбора = Неопределено, приОтбореПолучатьПервыйЭлементУдовлетворяющийУсловиям = Истина, заголовокФормыВыбора = "") Экспорт
	
	Перем типОбъекта, возвращаемоеЗначение, форма, элементОтбора;
	Перем построительОтчета, количествоЭлементовВОтборе, списокОтбора;
	Перем символПробелаОсновной;
	
	символПробелаОсновной = Символ(32);
	
	Если структураДанных.Объект = Неопределено Тогда возврат Неопределено конецЕсли;
	
	типОбъекта = Тип(структураДанных.Объект);
	
	Если Найти(Строка(типОбъекта), символПробелаОсновной) > 0 Тогда
		типОбъекта = Лев(Строка(типОбъекта), Найти(Строка(типОбъекта), символПробелаОсновной) - 1);
	КонецЕсли;
	
	Попытка
		
		Если типОбъекта = "Справочник" Тогда
			форма = структураДанных.Объект.ПолучитьФорму("ФормаВыбора", владелецФормы, владелецФормы);
			списокОтбора = форма.ЭлементыФормы.СправочникСписок.Значение;
		ИначеЕсли типОбъекта = "Документ" Тогда
			форма = структураДанных.Объект.ПолучитьФорму("ФормаВыбора", владелецФормы, владелецФормы);
			списокОтбора = форма.ЭлементыФормы.ДокументСписок.Значение;
		КонецЕсли;
		
	Исключение
		
		СообщениеОтобразить(НСтр("ru='Ошибка во время получения формы выбора типа «'; uk='Помилка при спробі отриманні форми вибору типа «'") +
			Строка(Тип(структураДанных.Объект)) + "»", СтатусСообщения.Внимание);
			
		Возврат Неопределено
		
	КонецПопытки;
	
	формаУстановитьОтборДляВыбора(форма, структураДанных, структураОтбора);// ++++++++++++++++++++++++++++++++
	формаУстановитьПараметрыПросмотраДляВыбора(форма, заголовокФормыВыбора);
	
	построительОтчета = Новый ПостроительОтчета;
	построительОтчета.ИсточникДанных = Новый ОписаниеИсточникаДанных(списокОтбора);
	количествоЭлементовВОтборе = построительОтчета.Результат.Выгрузить().Количество();
	
	Если количествоЭлементовВОтборе = 1 Тогда
		
		возвращаемоеЗначение = построительОтчета.Результат.Выгрузить().Получить(0).Ссылка;
		
	ИначеЕсли количествоЭлементовВОтборе = 0 Тогда
		
		возвращаемоеЗначение = Неопределено;
		
	Иначе // однозначну відповідність встановити не вдалося
		
		Если НЕ приОтбореПолучатьПервыйЭлементУдовлетворяющийУсловиям Тогда
			возвращаемоеЗначение = Неопределено;
		Иначе
			СообщениеОтобразить(СтрШаблон(
				"%1 %2%3 - найдено %4 элемент. по заданных критериях отбора:
				|%5",
				типОбъекта,
				Прав(СокрЛП(Тип(структураДанных.Объект)), Найти(СокрЛП(Тип(структураДанных.Объект)), ":") + 2),
				?(структураДанных.Свойство("Наименование"),
					СтрШаблон(" (%1)", структураДанных.Наименование),
					""),
				количествоЭлементовВОтборе,
				списокОтбора.Отбор), СтатусСообщения.Внимание, Ложь);
			возвращаемоеЗначение = построительОтчета.Результат.Выгрузить().Получить(0).Ссылка;
		КонецЕсли;
		
	КонецЕсли;
	
	Если НЕ приОтбореПолучатьПервыйЭлементУдовлетворяющийУсловиям
		И количествоЭлементовВОтборе = Неопределено
		И НЕ форма.Открыта() Тогда
		возвращаемоеЗначение = форма.ОткрытьМодально();
	КонецЕсли;
	
	Возврат возвращаемоеЗначение
	
КонецФункции

Функция CсылкаОбъектаМетаданныхВыбратьПоПараметрах(менеджерОбъектаМетаданных, структураДанных, сруктураОтборов, пропускатьПомеченныеНаУдаление = Истина) Экспорт
	
	Перем таблицаПараметровОтбора, имяТаблицы, пустаяСсылка, запрос, ключЗначение, новыйПараметрОтбора;
	
	таблицаПараметровОтбора = Новый ТаблицаЗначений;
	таблицаПараметровОтбора.Колонки.Добавить("ИмяПоля");
	таблицаПараметровОтбора.Колонки.Добавить("Значение");
	таблицаПараметровОтбора.Колонки.Добавить("ВидСравнения");
	имяТаблицы = "ТаблицаОбъектаМетаданных";
	пустаяСсылка = менеджерОбъектаМетаданных.ПустаяСсылка();
	запрос = Новый Запрос;
	
	Если пропускатьПомеченныеНаУдаление Тогда
		
		запрос.Параметры.Вставить("ПометкаУдаления", Ложь);
		
		новыйПараметрОтбора = таблицаПараметровОтбора.Добавить();
		новыйПараметрОтбора.ИмяПоля = "ПометкаУдаления";
		новыйПараметрОтбора.Значение = Ложь;
		новыйПараметрОтбора.ВидСравнения = ВидСравнения.Равно;
		
	КонецЕсли;
	
	Для Каждого ключЗначение из сруктураОтборов цикл
		
		запрос.Параметры.Вставить(ключЗначение.Ключ, структураДанных[ключЗначение.Ключ]);
		
		новыйПараметрОтбора = таблицаПараметровОтбора.Добавить();
		новыйПараметрОтбора.ИмяПоля = ключЗначение.Ключ;
		новыйПараметрОтбора.Значение = структураДанных[ключЗначение.Ключ];
		новыйПараметрОтбора.ВидСравнения = ВидСравнения.Равно;
		
	КонецЦикла;
	
	запрос.Текст = СтрШаблон(
	               "ВЫБРАТЬ ПЕРВЫЕ 1
	               |	%1.Ссылка
	               |ИЗ
	               |	%2.%3 КАК %1%4",
		имяТаблицы,
		ОбщегоНазначения.ВидОбъектаПоСсылке(пустаяСсылка),
		Метаданные.НайтиПоТипу(Тип(менеджерОбъектаМетаданных)).Имя,
		ЗапросТекстЧастьГдеПолучить(имяТаблицы, таблицаПараметровОтбора));
		
	результатВыполненияЗапроса = запрос.Выполнить();
	
	Возврат
		?(результатВыполненияЗапроса.Пустой(),
		пустаяСсылка,
		результатВыполненияЗапроса.Выгрузить().Получить(0).Ссылка)
		
КонецФункции

Функция СсылкаПолучитьПоКоду(код, менеджер, сообщатьЕслиНеНайдено = Истина) Экспорт
	
	Перем ссылка, пустаяСсылка, этоСправочник, объектМетаданных, кодПриведенный;
	
	Если НЕ ЗначениеЗаполнено(код) Тогда Возврат Неопределено конецЕсли;
	
	кодПриведенный =
		?(ОбщегоНазначения.ЕстьНеЦифры(код),
		код,
		Число(код));
		
	пустаяСсылка = менеджер.ПустаяСсылка();
	этоСправочник =
		"Справочник" = ОбщегоНазначения.ВидОбъектаПоСсылке(пустаяСсылка);
	объектМетаданных = пустаяСсылка.Метаданные();
	ссылка =
		?(этоСправочник,
		менеджер.НайтиПоКоду(Формат(кодПриведенный, СтрШаблон("ЧЦ=%1; ЧВН=; ЧГ=", объектМетаданных.ДлинаКода))),
		менеджер.НайтиПоНомеру(Формат(кодПриведенный, СтрШаблон("ЧЦ=%1; ЧВН=; ЧГ=", объектМетаданных.ДлинаНомера))));
		
	Если НЕ ЗначениеЗаполнено(ссылка) И сообщатьЕслиНеНайдено Тогда
		СообщениеОтобразить(СтрШаблон(
			"Запись типа %1 с кодом «%2» НЕ найдена.",
			СтрЗаменить(Строка(Тип(менеджер)), " менеджер", "")), СтатусСообщения.Внимание, Ложь);
	КонецЕсли;
	
	Возврат ссылка
	
КонецФункции

Функция ОписаниеТиповЗначениеПоУмолчаниюПолучить(описаниеТипов) Экспорт
	
	Возврат описаниеТипов.ПривестиЗначение()
	
КонецФункции

Функция ОбъектСтруктураМетаданныхПолучить(объект) Экспорт
	
	Перем структураОбъектаМетаданных;
	
	структураОбъектаМетаданных = Новый Структура("Метаданные, Синоним, ТипПредставление, ТипСтрокой, ТипИмя, ТипВид, МенеджерВид, Менеджер, ЗначениеПоУмолчанию");
	
	структураОбъектаМетаданных.Метаданные = объект.Метаданные();
	структураОбъектаМетаданных.Синоним = Строка(ТипЗнч(объект));
	структураОбъектаМетаданных.ТипСтрокой = СсылкаТипСтрокойПолучить(объект);
	структураОбъектаМетаданных.ТипИмя = Прав(структураОбъектаМетаданных.ТипСтрокой, СтрДлина(структураОбъектаМетаданных.ТипСтрокой) - Найти(структураОбъектаМетаданных.ТипСтрокой, "."));
	структураОбъектаМетаданных.ТипВид = ТипВидПолучить(структураОбъектаМетаданных.ТипСтрокой);
	структураОбъектаМетаданных.МенеджерВид = МетаданныеИмяМенеджераВМножественномИЕдинственномЧислеСоответствиеПолучить(Ложь).НайтиПоЗначению(структураОбъектаМетаданных.ТипВид).Представление;
	структураОбъектаМетаданных.Менеджер = ТипМенеджерПолучить(структураОбъектаМетаданных.ТипСтрокой, структураОбъектаМетаданных.ТипВид, структураОбъектаМетаданных.МенеджерВид, структураОбъектаМетаданных.ТипИмя);
	структураОбъектаМетаданных.ЗначениеПоУмолчанию = ТипЗначениеПоУмолчаниюПолучить(структураОбъектаМетаданных.ТипСтрокой, структураОбъектаМетаданных.ТипИмя);
	структураОбъектаМетаданных.ТипПредставление = структураОбъектаМетаданных.ТипВид + "." + структураОбъектаМетаданных.ТипИмя;
	
	Если НЕ СтрНайти(структураОбъектаМетаданных.ТипПредставление, "Регистр") = 0 Тогда
		структураОбъектаМетаданных.ТипПредставление = СтрЗаменить(структураОбъектаМетаданных.ТипПредставление, ".", "НаборЗаписей.");
	КонецЕсли;
	
	Если структураОбъектаМетаданных.ЗначениеПоУмолчанию = Неопределено Тогда
		// = ПустаяСсылка()
		структураОбъектаМетаданных.ЗначениеПоУмолчанию = объект;
	КонецЕсли;
	
	Возврат структураОбъектаМетаданных
	
КонецФункции

Функция ОбъектТипаМенеджерПроверить(объект) Экспорт
	
	Перем параКлючИЗначение;
	
	Для Каждого параКлючИЗначение из МетаданныеИмяМенеджераВМножественномИЕдинственномЧислеСоответствиеПолучить() цикл
		Если СтрНайти(Строка(ТипЗнч(объект)), параКлючИЗначение.Представление + " менеджер: ") = 0 Тогда Продолжить конецЕсли;
		Возврат Истина
	КонецЦикла;
	
	Возврат Ложь
	
КонецФункции

Функция МетаданныеИмяМенеджераВМножественномИЕдинственномЧислеПолучить(имя) Экспорт
	
	Перем списокСоответствий, соответствие;
	
	списокСоответствий = МетаданныеИмяМенеджераВМножественномИЕдинственномЧислеСоответствиеПолучить();
	
	соответствие = списокСоответствий.НайтиПоЗначению(имя);
	
	Если соответствие = Неопределено Тогда
		соответствие = СписокЗначенийПодобратьЗначениеПоПредставлению(списокСоответствий, имя);
	КонецЕсли;
	
	Возврат соответствие
	
КонецФункции

Функция МетаданныеИмяМенеджераВМножественномИЕдинственномЧислеСоответствиеПолучить(воМножественномЧислеЗначения = Истина, сортировать = Истина, толькоОсновныеТипы = Ложь) Экспорт
	
	Перем списокСоответствий;
	
	списокСоответствий = Новый СписокЗначений();
	
	Если воМножественномЧислеЗначения Тогда
		
		списокСоответствий.Добавить("Справочники", "Справочник");
		списокСоответствий.Добавить("Документы", "Документ");
		списокСоответствий.Добавить("Отчеты", "Отчет");
		списокСоответствий.Добавить("РегистрыНакопления", "РегистрНакопления");
		списокСоответствий.Добавить("РегистрыСведений", "РегистрСведений");
		списокСоответствий.Добавить("Обработки", "Обработка");
		
		Если НЕ толькоОсновныеТипы Тогда
			списокСоответствий.Добавить("Константы", "Константа");
			списокСоответствий.Добавить("Перечисления", "Перечисление");
			списокСоответствий.Добавить("ПланыВидовХарактеристик", "ПланВидовХарактеристик");
			списокСоответствий.Добавить("ПланыСчетов", "ПланСчетов");
			списокСоответствий.Добавить("ПланыВидовРасчета", "ПланВидовРасчета");
			списокСоответствий.Добавить("РегистрыБухгалтерии", "РегистрБухгалтерии");
			списокСоответствий.Добавить("РегистрыРасчета", "РегистрРасчета");
			списокСоответствий.Добавить("БизнесПроцессы", "БизнесПроцесс");
			списокСоответствий.Добавить("Задачи", "Задача");
			списокСоответствий.Добавить("ЖурналыДокументов", "ЖурналДокументов");
		КонецЕсли;
		
	Иначе
		
		списокСоответствий.Добавить("Справочник", "Справочники");
		списокСоответствий.Добавить("Документ", "Документы");
		списокСоответствий.Добавить("Отчет", "Отчеты");
		списокСоответствий.Добавить("РегистрНакопления", "РегистрыНакопления");
		списокСоответствий.Добавить("РегистрСведений", "РегистрыСведений");
		списокСоответствий.Добавить("Обработка", "Обработки");
		
		Если НЕ толькоОсновныеТипы Тогда
			списокСоответствий.Добавить("Константа", "Константы");
			списокСоответствий.Добавить("Перечисление", "Перечисления");
			списокСоответствий.Добавить("ПланВидовХарактеристик", "ПланыВидовХарактеристик");
			списокСоответствий.Добавить("ПланСчетов", "ПланыСчетов");
			списокСоответствий.Добавить("ПланВидовРасчета", "ПланыВидовРасчета");
			списокСоответствий.Добавить("РегистрБухгалтерии", "РегистрыБухгалтерии");
			списокСоответствий.Добавить("РегистрРасчета", "РегистрыРасчета");
			списокСоответствий.Добавить("БизнесПроцесс", "БизнесПроцессы");
			списокСоответствий.Добавить("Задача", "Задачи");
			списокСоответствий.Добавить("ЖурналДокументов", "ЖурналыДокументов");
		КонецЕсли;
		
	КонецЕсли;
	
	Если сортировать Тогда
		списокСоответствий.СортироватьПоПредставлению();
	КонецЕсли;
	
	Для Каждого элемент из списокСоответствий цикл
		элемент.Картинка = БиблиотекаКартинок[
			?(воМножественномЧислеЗначения,
			элемент.Представление,
			элемент.Значение)];
	КонецЦикла;
	
	Возврат списокСоответствий
	
КонецФункции

//ОбщегоНазначения.ЭтоОбъектСсылочногоТипа(ссылка) {Истина}
//ОбщегоНазначения.ВидОбъектаПоСсылке(ссылка) {Справочник}
//ОбщегоНазначения.ИмяТаблицыПоСсылке(ссылка) {Справочник.Номенклатура}
Функция МетаданныеВидСсылкиПолучить(ссылка, вернутьИмяМенеджера = Истина) Экспорт
	
	соответствиеИменВМножественномИЕдинственномЧисле = МетаданныеИмяМенеджераВМножественномИЕдинственномЧислеСоответствиеПолучить();
	
	Для Каждого метаданныеВид из соответствиеИменВМножественномИЕдинственномЧисле цикл
		
		Если НЕ Метаданные[метаданныеВид.Значение].Содержит(ссылка.Метаданные()) Тогда Продолжить КонецЕсли;
		
		Возврат
			?(вернутьИмяМенеджера,
			метаданныеВид.Значение,
			метаданныеВид.Представление)
			
	КонецЦикла;
	
	Возврат Неопределено
	
КонецФункции

//ОбщегоНазначения.СтроковоеПредставлениеТипа(ссылка)
//ОбщегоНазначения.ВидОбъектаПоСсылкеВидОбъектаПоСсылке(ссылка)
//ОбщегоНазначения.ИмяТаблицыПоСсылке(ссылка)
Функция СсылкаТипСтрокойПолучить(ссылка) Экспорт
	
	Если НЕ ОбщегоНазначения.ЗначениеСсылочногоТипа(ссылка) Тогда Возврат "" конецЕсли;
	
	Если Справочники.ТипВсеСсылки().СодержитТип(ТипЗнч(ссылка)) Тогда
		
		Возврат "СправочникСсылка." + ссылка.Метаданные().Имя;
		
	ИначеЕсли Документы.ТипВсеСсылки().СодержитТип(ТипЗнч(ссылка)) Тогда
		
		Возврат "ДокументСсылка." + ссылка.Метаданные().Имя;
		
	ИначеЕсли Перечисления.ТипВсеСсылки().СодержитТип(ТипЗнч(ссылка)) Тогда
		
		Возврат "ПеречислениеСсылка." + ссылка.Метаданные().Имя;
		
	Иначе
		
		ВызватьИсключениеОтсутствиеРеализации();
		
	КонецЕсли;
	
КонецФункции

//Метаданные.НайтиПоТипу(ТипЗнч(значение))
//Метаданные.НайтиПоТипу(ТипЗнч(значение.ПривестиЗначение()))
Функция ТипМетаданныеПолучить(типСтрокой) Экспорт
	
	Перем имяТипа, имяМенеджера;
	
	Если ПустаяСтрока(типСтрокой) Тогда Возврат Неопределено конецЕсли;
	
	имяМенеджера = Лев(типСтрокой, Найти(типСтрокой, ".") - 1);
	имяТипа = Прав(типСтрокой, СтрДлина(типСтрокой) - СтрДлина(имяМенеджера) - 1);
	имяМенеджера = МетаданныеИмяМенеджераВМножественномИЕдинственномЧислеСоответствиеПолучить(Ложь).НайтиПоЗначению(имяМенеджера).Представление;
	
	Возврат Метаданные[имяМенеджера][имяТипа]
	
КонецФункции

Функция ОбъектПредставлениеТипаПолучить(объект) Экспорт
	
	Возврат ОбъектСтруктураМетаданныхПолучить(объект).ТипПредставление
	
КонецФункции

Функция ПустаяСсылкаДляЗапросаПолучить(ссылка) Экспорт
	
	Перем метаданныеВидСсылки, ссылкаТипСтрокой, типМетаданныеИмя;
	
	метаданныеВидСсылки = МетаданныеВидСсылкиПолучить(ссылка, Ложь);
	ссылкаТипСтрокой = СсылкаТипСтрокойПолучить(ссылка);
	типМетаданныеИмя = ТипМетаданныеИмяПолучить(ссылкаТипСтрокой);
	
	Возврат "ЗНАЧЕНИЕ(" + метаданныеВидСсылки + "." + типМетаданныеИмя + ".ПустаяСсылка)"
	
КонецФункции

Функция ТипОпределить(объект) Экспорт
	
	Перем тип, символПробелаОсновной;
	
	символПробелаОсновной = Символ(32);
	
	тип = "";
	
	Для Каждого слово из ОбщегоНазначения.РазложитьСтрокуВМассивПодстрок(Лев(ТипЗнч(объект), Найти(ТипЗнч(объект), ":") - 1), " ") цикл
		тип = тип + ТРег(слово);
	КонецЦикла;
	
	Попытка
		тип = тип + символПробелаОсновной + объект.Метаданные().Имя;
		типСтрокой = Тип(тип);
	Исключение
		тип = "";
		ОтобразитьСообщениеОбОшибке(ОписаниеОшибки(), ИнформацияОбОшибке());
	КонецПопытки;
	
	Возврат тип
	
КонецФункции

Функция ЗначениеПоУмолчаниюПолучить(значение) Экспорт
	
	Если ОбщегоНазначения.ЗначениеСсылочногоТипа(значение) Тогда
		Возврат ТипЗначениеПоУмолчаниюПолучить(СсылкаТипСтрокойПолучить(значение))
	КонецЕсли;
	
	Если Тип("Булево") = ТипЗнч(значение) Тогда
		
		Возврат Ложь
		
	ИначеЕсли Тип("Строка") = ТипЗнч(значение) Тогда
		
		Возврат ""
		
	ИначеЕсли Тип("Число") = ТипЗнч(значение) Тогда
		
		Возврат 0
		
	ИначеЕсли Тип("Дата") = ТипЗнч(значение) Тогда
		
		Возврат ДатаМинимальноеЗначение()
		
	Иначе
		
		ВызватьИсключениеОтсутствиеРеализации()
		
	КонецЕсли;
	
КонецФункции

// Не лише для простих типів, а також для Справочники та Документы
Функция ТипЗначениеПоУмолчаниюПолучить(типСтрокой, типМетаданныеИмя = Неопределено) Экспорт
	
	Перем значениеПоУмолчанию, информацияОбОшибке;
	
	Если типСтрокой = "Строка" Тогда
		значениеПоУмолчанию = "";
	ИначеЕсли типСтрокой = "Число" Тогда
		значениеПоУмолчанию = 0;
	ИначеЕсли типСтрокой = "Дата" Тогда
		значениеПоУмолчанию = Дата(1,1,1);
	ИначеЕсли типСтрокой = "Булево" Тогда
		значениеПоУмолчанию = Ложь;
	КонецЕсли;
	
	Если значениеПоУмолчанию <> Неопределено Тогда возврат значениеПоУмолчанию конецЕсли;
	
	Если типМетаданныеИмя = Неопределено Тогда
		типМетаданныеИмя = ТипМетаданныеИмяПолучить(типСтрокой);
	КонецЕсли;
	
	Попытка
		
		Если Найти(типСтрокой, "Справочник") > 0 Тогда
			значениеПоУмолчанию = Справочники[типМетаданныеИмя].ПустаяСсылка();
		ИначеЕсли Найти(типСтрокой, "Документ") > 0 Тогда
			значениеПоУмолчанию = Документы[типМетаданныеИмя].ПустаяСсылка();
		ИначеЕсли Найти(типСтрокой, "Перечисление") > 0 Тогда
			значениеПоУмолчанию = Перечисления[типМетаданныеИмя].ПустаяСсылка();
		Иначе
			ВызватьИсключениеОтсутствиеРеализации()
		КонецЕсли;
		
	Исключение
		
		информацияОбОшибке = ИнформацияОбОшибке();
		
		Если Найти(типСтрокой, "Справочник") > 0 Тогда
			информацияОбОшибке = "{" + информацияОбОшибке.ИмяМодуля + " (" + информацияОбОшибке.НомерСтроки + ")}: " + "Справочники" + ". " + информацияОбОшибке.Описание;
		ИначеЕсли Найти(типСтрокой, "Документ") > 0 Тогда
			информацияОбОшибке = "{" + информацияОбОшибке.ИмяМодуля + " (" + информацияОбОшибке.НомерСтроки + ")}: " + "Документы" + ". " + информацияОбОшибке.Описание;
		Иначе
			информацияОбОшибке = ОписаниеОшибки();
		КонецЕсли;
		
		СообщениеОтобразить(информацияОбОшибке);
	
		значениеПоУмолчанию = Неопределено;
		
	КонецПопытки;
	
	Возврат значениеПоУмолчанию
	
КонецФункции

// По синоніму - довше, ніж по типу стрічкою
Функция ТипМетаданныеИмяПолучить(типСтрокой, имяМенеджера = Неопределено) Экспорт
	
	Перем метаданныеИмя, объектМетаданных;
	
	метаданныеИмя = "";
	
	Если
		Найти(типСтрокой, ".") > 0
		И Найти(типСтрокой, " ") = 0 Тогда // ТипЗнч
		метаданыеИмя = Прав(типСтрокой, СтрДлина(типСтрокой) - Найти(типСтрокой, "."));
	ИначеЕсли
		Найти(типСтрокой, ":") > 0
		И Найти(типСтрокой, Символ(32)) > 0 Тогда // Синонім
		метаданыеИмя = Неопределено;
	КонецЕсли;
	
	Если метаданыеИмя <> Неопределено Тогда Возврат метаданыеИмя конецЕсли;
	
	Если имяМенеджера = Неопределено Тогда
		имяМенеджера = ТипИмяМенеджераПолучить(типСтрокой);
		Если имяМенеджера = Неопределено Тогда Возврат "" конецЕсли;
	КонецЕсли;
	
	метаданыеСиноним = Прав(типСтрокой, СтрДлина(типСтрокой) - Найти(типСтрокой, ":") - 1);
	
	Для Каждого объектМетаданных из Метаданные[имяМенеджера] цикл
		Если объектМетаданных.Синоним <> метаданыеСиноним Тогда Продолжить конецЕсли;
		метаданныеИмя = объектМетаданных.Имя;
		Прервать
	КонецЦикла;
	
	Возврат метаданныеИмя
	
КонецФункции

Функция ТипИмяМенеджераПолучить(типСтрокой, видОбъекта = Неопределено) Экспорт
	
	Перем списокСоответствий, имяМенеджера;
	
	Если видОбъекта = Неопределено Тогда
		видОбъекта = ТипВидПолучить(типСтрокой);
	КонецЕсли;
	
	Если ПустаяСтрока(видОбъекта) Тогда Возврат "" конецЕсли;
	
	имяМенеджера = МетаданныеИмяМенеджераВМножественномИЕдинственномЧислеСоответствиеПолучить().НайтиПоЗначению(видОбъекта);
	
	Если НЕ имяМенеджера = Неопределено Тогда
		Возврат имяМенеджера.Значение
	КонецЕсли;
	
	имяМенеджера = МетаданныеИмяМенеджераВМножественномИЕдинственномЧислеСоответствиеПолучить(Ложь).НайтиПоЗначению(видОбъекта);
	
	Если имяМенеджера = Неопределено Тогда
		СообщениеОтобразить(НСтр("ru = 'Отсутствует определение менеджера для типа: «'") + типСтрокой + "»", СтатусСообщения.Внимание);
	КонецЕсли;
	
	Возврат имяМенеджера.Значение
	
КонецФункции

Функция ТипМенеджерПолучить(типСтрокой, видОбъекта = Неопределено, имяМенеджера = Неопределено, метаданныеИмя = Неопределено) Экспорт
	
	Перем менеджер;
	
	Если видОбъекта = Неопределено Тогда
		видОбъекта = ТипВидПолучить(типСтрокой);
	КонецЕсли;
	
	Если имяМенеджера = Неопределено Тогда
		имяМенеджера = ТипИмяМенеджераПолучить(типСтрокой, видОбъекта);
	КонецЕсли;
	
	Если ПустаяСтрока(имяМенеджера) Тогда возврат "" конецЕсли;
	
	Если метаданныеИмя = Неопределено Тогда
		метаданныеИмя = ТипМетаданныеИмяПолучить(типСтрокой, имяМенеджера);
	КонецЕсли;
	
	менеджер = Вычислить(имяМенеджера + "[""" + метаданныеИмя + """]");
	
	Возврат менеджер
	
КонецФункции

Функция ТипВидПолучить(типСтрокой) Экспорт
	
	Перем типВид;
	
	//типВид = Лев(ТипЗнч(объект), Найти(ТипЗнч(объект), Символ(32)) - 1);
	
	Если
		Найти(типСтрокой, ".") > 0
		И Найти(типСтрокой, " ") = 0 Тогда
		типВид = Лев(типСтрокой, Найти(типСтрокой, ".") - 1);
	Иначе
		типВид = "";
		Для Каждого слово из ОбщегоНазначения.РазложитьСтрокуВМассивПодстрок(Лев(типСтрокой, Найти(типСтрокой, ":") - 1), Символ(32)) цикл
			типВид = типВид + ТРег(слово);
		КонецЦикла;
	КонецЕсли;
	
	Если
		Найти(типВид, "Объект") > 0
		ИЛИ Найти(типВид, "Ссылка") > 0 Тогда
		типВид = Лев(типВид, СтрДлина(типВид) - СтрДлина("Объект"));
	ИначеЕсли Найти(типВид, "НаборЗаписей") > 0 Тогда
		типВид = Лев(типВид, СтрДлина(типВид) - СтрДлина("НаборЗаписей"));
	ИначеЕсли Найти(типВид, "Запись") > 0 Тогда
		типВид = Лев(типВид, СтрДлина(типВид) - СтрДлина("Запись"));
	КонецЕсли;
	
	Возврат типВид
	
КонецФункции

//Новый ОписаниеТипов("СправочникСсылка.ФизическиеЛица")
Функция ПолучитьОписаниеТипов(тип = Неопределено) Экспорт
	
	Перем типы, описаниеТипов;
	
	типы = Новый Массив();
	
	Если ЗначениеЗаполнено(ТипЗнч(тип)) Тогда
		
		типы.Добавить(
			?(ТипЗнч(тип) = Тип("Тип"),
			тип,
			ТипЗнч(тип)));
		описаниеТипов = Новый ОписаниеТипов(типы)
		
	ИначеЕсли тип = Неопределено Тогда
		
		типы.Добавить(ТипЗнч(Константы));
		типы.Добавить(ТипЗнч(Справочники.ТипВсеСсылки().Типы()));
		типы.Добавить(ТипЗнч(Документы.ТипВсеСсылки().Типы()));
		типы.Добавить(ТипЗнч(Перечисления.ТипВсеСсылки().Типы()));
		типы.Добавить(ТипЗнч(Отчеты));
		типы.Добавить(ТипЗнч(Обработки));
		типы.Добавить(ТипЗнч(ПланыВидовХарактеристик.ТипВсеСсылки().Типы()));
		типы.Добавить(ТипЗнч(ПланыСчетов.ТипВсеСсылки().Типы()));
		типы.Добавить(ТипЗнч(ПланыВидовРасчета.ТипВсеСсылки().Типы()));
		типы.Добавить(ТипЗнч(РегистрыСведений));
		типы.Добавить(ТипЗнч(РегистрыНакопления));
		типы.Добавить(ТипЗнч(РегистрыБухгалтерии));
		типы.Добавить(ТипЗнч(РегистрыРасчета));
		типы.Добавить(ТипЗнч(БизнесПроцессы.ТипВсеСсылки().Типы()));
		типы.Добавить(ТипЗнч(Задачи.ТипВсеСсылки().Типы()));
		описаниеТипов = Новый ОписаниеТипов(типы);
		//описаниеТипов = ЭлементыФормы.ЛюбаяСсылка.ОграничениеТипа;// Ну, або так...
		
	ИначеЕсли тип = "Строка" Тогда
		описаниеТипов = Новый ОписаниеТипов("Строка");
		
		
	ИначеЕсли тип = "Число" Тогда
		
		описаниеТипов = Новый ОписаниеТипов("Число");
		
	ИначеЕсли тип = "Дата" Тогда
		
		описаниеТипов = Новый ОписаниеТипов("Дата");
		
	ИначеЕсли тип = "Время" Тогда
		
		квалификаторыДаты = Новый КвалификаторыДаты(ЧастиДаты.Дата);
		описаниеТипов = Новый ОписаниеТипов("Дата",,, квалификаторыДаты);
		
	ИначеЕсли тип = "Справочник" Тогда
		
		описаниеТипов = Новый ОписаниеТипов(Справочники.ТипВсеСсылки());
		
	Иначе
		
		СообщениеОтобразить(НСтр("ru='Отсутствуют предустановки для создания описания типа: '; uk='Відсутні налаштування для створення опису типу: '") + тип, СтатусСообщения.ОченьВажное);
		
	КонецЕсли;
	
	Возврат описаниеТипов
	
КонецФункции

Функция ДатаМинимальноеЗначение() Экспорт
	
	Возврат Дата(1, 1, 1)
	
КонецФункции

Функция ДатаМаксимальноеЗначение() Экспорт
	
	Возврат Дата(3999, 31, 12) //Дата(3999, 12, 31, 23, 59, 59)
	
КонецФункции

Функция ОпределитьКварталПоДате(дата) Экспорт
	Перем результат, квартал;
	
	квартал = Число(Формат(КонецКвартала(дата), "ДФ=" "к"));
	
	Если квартал = 1 Тогда
		результат = "I";
		
	ИначеЕсли квартал = 2 Тогда
		результат = "II";
		
	ИначеЕсли квартал = 3 Тогда
		результат = "III";
		
	ИначеЕсли квартал = 4 Тогда
		результат = "IV";
	КонецЕсли;
	
	Возврат результат;
КонецФункции

Функция ОпределитьМесяцПоДате(дата) Экспорт
	Перем месяц;
	
	месяц = Формат(дата, "ДФ=ММММ");
	
	Возврат месяц;
КонецФункции

Функция МесяцПредставлениеПолучитьПоНомеру(номерПорядковый, формат = "") Экспорт
	
	Возврат
		Формат(Дата("2000" + Формат(номерПорядковый, "ЧЦ=2; ЧВН=") + "01"),
			?(ПустаяСтрока(формат),
			НСтр("ru = 'Л=ru_UA; ДФ=MMMM'; uk = 'Л=uk_UA; ДФ=MMMM'"),
			формат))
			
КонецФункции

// ГОД КВАРТАЛ МЕСЯЦ ДЕНЬ ЧАС МИНУТА СЕКУНДА
Функция РазностьДатПолучить(датаНачала, датаОкончания, периодРазностиСтрокой = "ДЕНЬ") Экспорт
	
	Перем запрос, выборкаИзРезультатаЗапроса;
	
	запрос = Новый Запрос;
	
	запрос.Текст = "ВЫБРАТЬ
	              |	РАЗНОСТЬДАТ(&ДатаНачала, &ДатаОкончания, " + периодРазностиСтрокой + ") КАК РазностьДат";
	
	запрос.УстановитьПараметр("ДатаНачала", датаНачала);
	запрос.УстановитьПараметр("ДатаОкончания", датаОкончания);
	
	выборкаИзРезультатаЗапроса = Запрос.Выполнить().Выбрать();
	выборкаИзРезультатаЗапроса.Следующий();
	
	Возврат выборкаИзРезультатаЗапроса.РазностьДат
	
КонецФункции

Функция ДатыРазницаВМесяцахПолучить(датаНачала, датаОкончания = Неопределено) Экспорт
	перем дата1, дата2;
	
	Если датаОкончания = Неопределено Тогда
		датаОкончания = ТекущаяДата()
	КонецЕсли;
	
	дата2 = Макс(датаОкончания, датаНачала);
	дата1 = Мин(датаНачала, датаОкончания);
	
	Возврат Год(дата2) * 12 - Год(дата1) * 12 + Месяц(дата2) - Месяц(дата1)
	
КонецФункции

Функция ДатыРазницаВДнях(датаНачала, датаОкончания = Неопределено, включатьДатыВПериод = Истина) Экспорт
	
	Перем датыРазницаВДнях;
	
	Если датаОкончания = Неопределено Тогда
		датаОкончания = ТекущаяДата();
	КонецЕсли;
	
	датыРазницаВДнях = (НачалоДня(датаОкончания) - НачалоДня(датаНачала)) / 86400;
	
	Если включатьДатыВПериод Тогда
		датыРазницаВДнях = датыРазницаВДнях + 1;
	КонецЕсли;
	
	Возврат датыРазницаВДнях
	
КонецФункции

Функция ДатыИнтервалВДнях(датаНачала, датаОкончания = Неопределено, толькоРабочие = Истина, началоДня = Истина, включатьДатыВПериод = Истина) Экспорт
	
	Перем запрос, выборкаИзРезультатаЗапроса, счетчик;
	
	Если датаОкончания = Неопределено Тогда
		датаОкончания = ТекущаяДата();
	КонецЕсли;
	
	запрос = Новый Запрос();
	
	запрос.Текст = "ВЫБРАТЬ
	               |	РегламентированныйПроизводственныйКалендарь.ДатаКалендаря КАК ДатаКалендаря
	               |ИЗ
	               |	РегистрСведений.РегламентированныйПроизводственныйКалендарь КАК РегламентированныйПроизводственныйКалендарь
	               |ГДЕ
	               |	РегламентированныйПроизводственныйКалендарь.ДатаКалендаря >= &Дата";
	
	Если толькоРабочие Тогда
		запрос.Текст = запрос.Текст + "
					|	И (РегламентированныйПроизводственныйКалендарь.ВидДня = ЗНАЧЕНИЕ(Перечисление.ВидыДнейПроизводственногоКалендаря.Предпраздничный)
					|			ИЛИ РегламентированныйПроизводственныйКалендарь.ВидДня = ЗНАЧЕНИЕ(Перечисление.ВидыДнейПроизводственногоКалендаря.Рабочий))";
	КонецЕсли;
	
	запрос.Текст = запрос.Текст + "
					|
					|УПОРЯДОЧИТЬ ПО
					|	ДатаКалендаря";
	
	запрос.УстановитьПараметр("Дата",
		?(началоДня,
		НачалоДня(датаНачала),
		датаНачала));
		
	результатВыполненияЗапроса = запрос.Выполнить();
	
	Если результатВыполненияЗапроса.Пустой() Тогда
		#Если Клиент Тогда
		Предупреждение("Необходимо заполнение регистра сведений «Регламентированный производственный календарь» для текущего года!");
		РегистрыСведений.РегламентированныйПроизводственныйКалендарь.ПолучитьФорму("Форма").ОткрытьМодально();
		#Иначе
		Возврат Неопределено;
		#КонецЕсли
	КонецЕсли;
	
	выборкаИзРезультатаЗапроса = результатВыполненияЗапроса.Выбрать();
	
	счетчик = 0;
	
	Пока выборкаИзРезультатаЗапроса.Следующий() цикл
		
		Если выборкаИзРезультатаЗапроса.ДатаКалендаря >= датаОкончания Тогда
			
			Возврат
				?(включатьДатыВПериод,
				счетчик + 1,
				счетчик);
				
		КонецЕсли;
		
		счетчик = счетчик + 1;
		
	КонецЦикла;
	
КонецФункции

//ОбщегоНазначения.ДобавитьИнтервал
Функция ДатаДобавитьДни(количествоДней, толькоРабочие = Истина, началоДня = Истина, дата = Неопределено) Экспорт
	
	Перем запрос, выборкаИзРезультатаЗапроса, датаСмещенная, количествоСекундОтНачалаДня;
	
	Если дата = Неопределено Тогда
		дата = ТекущаяДата();
	КонецЕсли;
	
	Если количествоДней = 0 Тогда возврат дата конецЕсли;
	
	количествоСекундОтНачалаДня = дата - НачалоДня(дата);
	запрос = Новый Запрос();
	
	запрос.Текст = 
	"ВЫБРАТЬ
	|	РегламентированныйПроизводственныйКалендарь.ДатаКалендаря,
	|	РегламентированныйПроизводственныйКалендарь.Год,
	|	РегламентированныйПроизводственныйКалендарь.Пятидневка,
	|	РегламентированныйПроизводственныйКалендарь.Шестидневка,
	|	РегламентированныйПроизводственныйКалендарь.КалендарныеДни,
	|	РегламентированныйПроизводственныйКалендарь.ВидДня
	|ИЗ
	|	РегистрСведений.РегламентированныйПроизводственныйКалендарь КАК РегламентированныйПроизводственныйКалендарь
	|ГДЕ
	|	ВЫБОР
	|			КОГДА &ОтнятьДни
	|				ТОГДА РегламентированныйПроизводственныйКалендарь.ДатаКалендаря <= &ДатаНачала
	|						И РегламентированныйПроизводственныйКалендарь.ДатаКалендаря >= ДОБАВИТЬКДАТЕ(&ДатаНачала, ДЕНЬ, &КоличествоДней - 10)
	|			ИНАЧЕ РегламентированныйПроизводственныйКалендарь.ДатаКалендаря >= &ДатаНачала
	|					И РегламентированныйПроизводственныйКалендарь.ДатаКалендаря <= ДОБАВИТЬКДАТЕ(&ДатаНачала, ДЕНЬ, &КоличествоДней + 10)
	|		КОНЕЦ";
	
	Если толькоРабочие Тогда
		запрос.Текст = запрос.Текст + "
		|	И (РегламентированныйПроизводственныйКалендарь.ВидДня = ЗНАЧЕНИЕ(Перечисление.ВидыДнейПроизводственногоКалендаря.Предпраздничный)
		|			ИЛИ РегламентированныйПроизводственныйКалендарь.ВидДня = ЗНАЧЕНИЕ(Перечисление.ВидыДнейПроизводственногоКалендаря.Рабочий))";
	КонецЕсли;
	
	запрос.Текст = запрос.Текст + ?(КоличествоДней < 0,
		"
		|
		|УПОРЯДОЧИТЬ ПО
		|	ДатаКалендаря УБЫВ",
		"
		|
		|УПОРЯДОЧИТЬ ПО
		|	ДатаКалендаря");
	
	запрос.УстановитьПараметр("ДатаНачала", дата);
	
	запрос.УстановитьПараметр("ОтнятьДни",
		?(КоличествоДней < 0,
		Истина,
		Ложь));
		
	запрос.УстановитьПараметр("количествоДней", количествоДней);
	
	результатВыполненияЗапроса = запрос.Выполнить();
	
	Если результатВыполненияЗапроса.Пустой() Тогда
		#Если Клиент Тогда
			Предупреждение("Необходимо заполнение регистра сведений «РегламентированныйПроизводственныйКалендарь» для текущего года!");
			РегистрыСведений.РегламентированныйПроизводственныйКалендарь.ПолучитьФорму("Форма").ОткрытьМодально();
		#Иначе
			Возврат Неопределено;
		#КонецЕсли
	КонецЕсли;
	
	датаСмещенная =
		?(КоличествоДней < 0,
		результатВыполненияЗапроса.Выгрузить()[-КоличествоДней].ДатаКалендаря,
		результатВыполненияЗапроса.Выгрузить()[КоличествоДней - 1].ДатаКалендаря);
		
	Возврат
		?(началоДня,
		датаСмещенная,
		датаСмещенная + количествоСекундОтНачалаДня)
		
КонецФункции

Функция ДатаПредшествующаяВДнях(количествоДней, началоДня = Истина, дата = Неопределено) Экспорт
	
	Если дата = Неопределено Тогда
		дата = ТекущаяДата();
	КонецЕсли;
	
	Возврат
		?(началоДня,
		НачалоДня(дата) - (количествоДней * 24 * 60 * 60),
		дата - (количествоДней * 24 * 60 * 60));
КонецФункции

Функция ДатаИзСтроки(строка) Экспорт
	
	Перем значениеДата, месяц, год;
	Перем символПробелаОсновной;
	
	символПробелаОсновной = Символ(32);
	значениеДата = Дата("00010101000000");
	строка = СокрЛП(строка);
	
	Если ПустаяСтрока(строка) Тогда Возврат значениеДата конецЕсли;
	
	Если Найти(строка, ".") > 0 Тогда
		
		Если
			Найти(строка, ":") > 0
			И Найти(строка, символПробелаОсновной) > 0 Тогда
			месяц = ОбщегоНазначения.РазложитьСтрокуВМассивПодстрок(строка, символПробелаОсновной);
			Возврат ДатаИзСтроки(месяц[0])
		КонецЕсли;
		
		месяц = ОбщегоНазначения.РазложитьСтрокуВМассивПодстрок(строка, ".");
		
	ИначеЕсли Найти(строка, "/") > 0 Тогда
		
		месяц = ОбщегоНазначения.РазложитьСтрокуВМассивПодстрок(строка, "/");
		
	ИначеЕсли Найти(строка, ",") > 0 Тогда
		
		месяц = ОбщегоНазначения.РазложитьСтрокуВМассивПодстрок(строка, ",");
		
	ИначеЕсли Найти(строка, "-") > 0 Тогда
		
		месяц = ОбщегоНазначения.РазложитьСтрокуВМассивПодстрок(строка, "-");
		
	КонецЕсли;
	
	Попытка
		
		Если месяц.Количество() = 3 Тогда//"01.02.13" или "01.02.2013"
			год =
				?(СтрДлина(месяц[2]) = 2,
				2000 + месяц[2],
				месяц[2]);
			значениеДата = Дата(год, месяц[1], месяц[0]);
		ИначеЕсли месяц.Количество() = 2 Тогда//"02.13" или "02.2013";
			год =
				?(СтрДлина(месяц[1]) = 2,
				2000 + месяц[1],
				месяц[1]);
			значениеДата = Дата(год, месяц[0], 1);
		КонецЕсли;
		
	Исключение
	КонецПопытки;
	
	Возврат значениеДата
	
КонецФункции

Функция ДатаИнтервалСтрокойИзЧисла(числомКоличествоСекунд) Экспорт
	Перем числомКоличествоСуток, числомКоличествоЧасов, числомКоличествоМинут;
	Перем строкойДата, остатокСекунд, текущийОстаток;
	Перем числом1Минута, числом1Час, числом1Сутки;
	Перем символПробелаОсновной;
	
	символПробелаОсновной = Символ(32);
	
	числом1Минута = 60;
	числом1Час = 60 * 60;
	числом1Сутки = 24 * 60 * 60;
	
	остатокСекунд = числомКоличествоСекунд;
	
	текущийОстаток = остатокСекунд % числом1Сутки;
	числомКоличествоСуток = (остатокСекунд - текущийОстаток) / числом1Сутки;
	остатокСекунд = остатокСекунд - числомКоличествоСуток * числом1Сутки;
	
	текущийОстаток = остатокСекунд % числом1Час;
	числомКоличествоЧасов = (остатокСекунд - текущийОстаток) / числом1Час;
	остатокСекунд = остатокСекунд - числомКоличествоЧасов * числом1Час;
	
	текущийОстаток = остатокСекунд % числом1Минута;
	числомКоличествоМинут = (остатокСекунд - текущийОстаток) / числом1Минута;
	остатокСекунд = остатокСекунд - числомКоличествоМинут * числом1Минута;
	
	строкойДата =
		?(ЗначениеЗаполнено(числомКоличествоСуток),
		Формат(числомКоличествоСуток, "ЧРГ='") + символПробелаОсновной,
		"");
	строкойДата = строкойДата
	+ Формат(числомКоличествоЧасов, "ЧЦ=2; ЧН=00; ЧВН=") + ":"
	+ Формат(числомКоличествоМинут, "ЧЦ=2; ЧН=00; ЧВН=") + ":"
	+ Формат(остатокСекунд, "ЧЦ=2; ЧН=00; ЧВН=");
	
	Возврат строкойДата;
КонецФункции

Функция ДатаИнтервалПредставление(числомКоличествоСекунд) Экспорт
	Перем представлениеИнтервала;
	
	представлениеИнтервала = ДатаИнтервалСтрокойИзЧисла(числомКоличествоСекунд);
	
	дней = "";
	
	Если СтрДлина(представлениеИнтервала) > 8 Тогда
		дней = Лев(представлениеИнтервала, СтрДлина(представлениеИнтервала) - 9) + " дн.";
	КонецЕсли;
		
	представлениеИнтервала = Прав(представлениеИнтервала, 8);
	
	частьПредставления = Лев(представлениеИнтервала, 2);
	часов =
		?(частьПредставления = "00",
		"",
		?(Лев(частьПредставления, 1) = "0",
			Прав(частьПредставления, 1),
			частьПредставления));
	часов =
		?(ПустаяСтрока(часов),
		"",
		часов + " ч.");
	
	частьПредставления = Сред(представлениеИнтервала, 4, 2);
	минут =
		?(частьПредставления = "00",
		"", ?(Лев(частьПредставления, 1) = "0",
		Прав(частьПредставления, 1), частьПредставления));
	минут =
		?(ПустаяСтрока(минут),
		"",
		минут + " м.");
	
	частьПредставления = Прав(представлениеИнтервала, 2);
	секунд =
		?(частьПредставления = "00",
		"",
		?(Лев(частьПредставления, 1) = "0",
			Прав(частьПредставления, 1),
			частьПредставления));
	секунд =
		?(ПустаяСтрока(секунд),
		"",
		секунд + " с.");
	
	представлениеИнтервала = "";
	
	Если НЕ ПустаяСтрока(дней) Тогда
		представлениеИнтервала = дней;
	КонецЕсли;
	Если НЕ ПустаяСтрока(часов) Тогда
		представлениеИнтервала =
			?(ПустаяСтрока(представлениеИнтервала),
			часов,
			представлениеИнтервала + Символ(32) + часов);
	КонецЕсли;
	Если НЕ ПустаяСтрока(минут) Тогда
		представлениеИнтервала =
			?(ПустаяСтрока(представлениеИнтервала),
			минут,
			представлениеИнтервала + Символ(32) + минут);
	КонецЕсли;
	Если НЕ ПустаяСтрока(секунд) Тогда
		представлениеИнтервала =
			?(ПустаяСтрока(представлениеИнтервала),
			секунд,
			представлениеИнтервала + Символ(32) + секунд);
	КонецЕсли;
	
	Возврат представлениеИнтервала;
КонецФункции

Функция ВремяЧислом(строкойВремя) Экспорт
	
	часыВремя = Число(Лев(строкойВремя, 2));
	минутыВремя = Число(Сред(строкойВремя, 4, 2));
	
	числомВремя = (минутыВремя * 60) + (часыВремя * 60 * 60);
	
	Возврат числомВремя;
КонецФункции

Функция ВремяРазницаСтроками(значениеСлева, значениеСправа) Экспорт
	
	начальнаяДата = НачалоДня(ТекущаяДата());
	датаСлева = начальнаяДата + ВремяЧислом(значениеСлева);
	датаСправа = начальнаяДата + ВремяЧислом(значениеСправа);
	
	разница = датаСлева - датаСправа;
	
	Возврат разница;
КонецФункции

Функция ПроверитьЗначимостьСтрокиВПериодеДат(строка, числомМесяц) Экспорт
	
	Перем массивПодстрок, подстрокаДаты, строкаДаты;
	
	Для Каждого строкаДаты из СтрокаРазбитьНаСоставляющие(строка) цикл
		Если ПустаяСтрока(строкаДаты) Тогда Продолжить конецЕсли;
		подстрокаДаты = ДатаИзСтроки(строкаДаты);
		Если Число(Формат(подстрокаДаты, "ДФ=М")) = числомМесяц Тогда Возврат Истина конецЕсли;
	КонецЦикла;
	
	Возврат Ложь
	
КонецФункции

Функция ПериодВыбрать(началоПериода = Неопределено, конецПериода = Неопределено, редактироватьКакИнтервал = Истина, активироватьЗакладкуПериод = Истина) Экспорт
	
	#Если Клиент Тогда
	
	Если началоПериода = Неопределено Тогда
		началоПериода = НачалоМесяца(ТекущаяДата());
	КонецЕсли;
	
	Если конецПериода = Неопределено Тогда
		конецПериода = КонецМесяца(ТекущаяДата());
	КонецЕсли;
	
	настройкаПериода = Новый НастройкаПериода;
	
	настройкаПериода.УстановитьПериод(началоПериода, конецПериода);
	
	настройкаПериода.РедактироватьКакПериод = активироватьЗакладкуПериод;
	настройкаПериода.РедактироватьКакИнтервал = редактироватьКакИнтервал;
	
	настройкаПериода.ВариантНастройки =
		?(активироватьЗакладкуПериод,
		ВариантНастройкиПериода.Период,
		ВариантНастройкиПериода.Интервал);
		
	Если НЕ настройкаПериода.Редактировать() Тогда Возврат Неопределено конецЕсли;
	
	началоПериода = НастройкаПериода.ПолучитьДатуНачала();
	конецПериода = НастройкаПериода.ПолучитьДатуОкончания();
	
	Возврат Новый Структура("НачалоПериода, КонецПериода",
		началоПериода,
		конецПериода)
		
	#КонецЕсли
	
КонецФункции

Процедура УстановитьПериод(объект, пНачалоПериода, пКонецПериода, режимОперационныеСутки = Ложь, началоСуток = Ложь) Экспорт
	
	Перем полночьНачалоПериода, полночьКонецПериода;
	Перем числом1Секунда, числом8Часов, числом1Сутки;
	
	числом1Секунда = 1;
	числом8Часов = 8 * 60 * 60;
	числом1Сутки = 24 * 60 * 60;
	
	Попытка
		объект.НачалоПериода = пНачалоПериода;
		объект.КонецПериода = пКонецПериода;
	Исключение
		#Если Клиент Тогда
		Сообщить(НСтр("ru = 'У объекта отсутствуют реквизиты «НачалоПериода» и/или «КонецПериода».'"), СтатусСообщения.Внимание);
		#КонецЕсли
		Возврат
	КонецПопытки;
	
	полночьНачалоПериода = НачалоДня(пНачалоПериода);
	полночьКонецПериода = НачалоДня(пКонецПериода);
	
	Если началоСуток Тогда
		объект.НачалоПериода = полночьНачалоПериода;
		объект.КонецПериода = полночьКонецПериода + числом1Сутки - числом1Секунда;
	КонецЕсли;
	
	Если режимОперационныеСутки Тогда
		объект.НачалоПериода = полночьНачалоПериода + числом8Часов;
		объект.КонецПериода = полночьКонецПериода + числом1Сутки + числом8Часов - числом1Секунда;
	КонецЕсли;
	
КонецПроцедуры

Функция ПолучитьИменованиеКонтрагент(контрагент) Экспорт
	
	наименование =
		?(ПустаяСтрока(контрагент.НаименованиеПолное),
		контрагент.Наименование,
		контрагент.НаименованиеПолное);
		
	Возврат наименование;
КонецФункции

Функция ЧислоМодуль(число) Экспорт
	
	Возврат Макс(число, -число);
КонецФункции

Функция ЧислоПолучитьЦелуюЧастьОтДеленияНа(делитель, число, значениеВместоНуля = Неопределено) Экспорт
	Перем целаяЧасть;
	
	Если делитель = 0 Тогда возврат Неопределено конецЕсли;
	
	целаяЧасть = (число - число % делитель) / делитель;
	
	Возврат
		?(целаяЧасть = 0 И значениеВместоНуля <> Неопределено,
		значениеВместоНуля,
		целаяЧасть);
КонецФункции

Функция ЧислоПолучитьСтрокуЦифр(значение) Экспорт
	Попытка
	
		Возврат СтрокаУбратьНедопустимыеСимволы(Число(СтрокаУбратьНедопустимыеСимволы(значение, Символ(32))), Символ(32));
	
	Исключение
		Возврат 0;
	КонецПопытки;
КонецФункции

Функция ЧислоПолучитьРазрядность(значение) Экспорт
	Перем значениеЧислом, разрядностьЗначения;
	
	разрядностьЗначения = 0;
	
	Попытка
		
		значениеЧислом = Число(ЧислоПолучитьСтрокуЦифр(значение));
		разрядностьЗначения = СтрДлина(ЧислоПолучитьСтрокуЦифр(значениеЧислом));
	
	Исключение
		значение = 0;
	КонецПопытки;
	
	Возврат разрядностьЗначения;
КонецФункции

Функция БулевоNullableПроверитьНаИстину(значение) Экспорт
	
	Возврат
		?(значение = NULL,
		Ложь,
		значение);
КонецФункции

Функция БулевоТриСостоянияВернутьСостояние(значение, вернутьЛожьЕслиНеопределено = Ложь) Экспорт
	
	Если значение = 0 Тогда
		Возврат Ложь
	ИначеЕсли значение = 1 Тогда
		Возврат Истина
	Иначе
		Возврат
			?(вернутьЛожьЕслиНеопределено,
			Ложь,
			Неопределено)
	КонецЕсли;
	
КонецФункции

Функция БулевоТриСостоянияСравнитьСоЗначением(значение, сравниваемоеЗначение = Истина) Экспорт
	
	Возврат значение = сравниваемоеЗначение
	
КонецФункции

#КонецОбласти


#Область Форми

Процедура ФормаРазвернутьНаВесьЭкран() Экспорт
	
	wsShell = Новый COMОбъект("WScript.Shell");
	
	wsShell.SendKeys("%");
	wsShell.SendKeys("{LEFT}{LEFT}{ENTER}"); 
	
КонецПроцедуры

Процедура ВызватьИсключениеОтсутствиеРеализации(текстСообщения = "Обратиться в отдел технической поддержки для решения сложившейся ситуации!") Экспорт
	
	#Если Клиент Тогда
	Сигнал();
	#КонецЕсли
	
	ВызватьИсключение(текстСообщения);
	
КонецПроцедуры

Процедура ОтладочнаяИнформацияЗаписать(текстСообщения, объект = Неопределено, данные = Неопределено, записыватьВЖурналрегистрации = Ложь) Экспорт
	
	Если записыватьВЖурналрегистрации Тогда
		
		ЗаписьЖурналаРегистрации(
			"Сообщение",
			УровеньЖурналаРегистрации.Информация,
			объект,
			данные,
			текстСообщения);
			
	Иначе
		
		ОбщегоНазначенияКлиентСервер.СообщитьПользователю(текстСообщения);
		
	КонецЕсли;
	
КонецПроцедуры

// ToDo: переробити функції на немодальні виклики (ПоказатьВопрос)
Функция ВопросПолучитьПодтверждение(текстВопроса = "Подтверждаете выполнение выбранного действия?", даКнопкаПоУмолчанию = Истина, сигнал = Истина, текстЗаголовка = "Внимание") Экспорт
	
	#Если Клиент Тогда
		
		Если сигнал Тогда Сигнал() конецЕсли;
		
		ответ =
			?(даКнопкаПоУмолчанию,
			Вопрос(текстВопроса, РежимДиалогаВопрос.ДаНет, 30, КодВозвратаДиалога.Да, текстЗаголовка, КодВозвратаДиалога.Да),
			Вопрос(текстВопроса, РежимДиалогаВопрос.ДаНет, 30, КодВозвратаДиалога.Нет, текстЗаголовка, КодВозвратаДиалога.Нет));
			
		Возврат
			?(даКнопкаПоУмолчанию,
			(ответ = КодВозвратаДиалога.Да ИЛИ ответ = КодВозвратаДиалога.Таймаут),
			НЕ (ответ = КодВозвратаДиалога.Нет ИЛИ ответ = КодВозвратаДиалога.Таймаут))
			
	#Иначе
		
		Возврат Истина
		
	#КонецЕсли

КонецФункции

//ОбщегоНазначения.СообщитьОбОшибке
Функция ОтобразитьСообщениеОбОшибке(описаниеОшибки, информацияОбОшибке, статус = Неопределено, текстПредварительногоСообщения = "", отобразитьОписаниеОшибки = Ложь) Экспорт
	
	Перем текстСообщения;
	
	текстСообщения =
		?(информацияОбОшибке.Причина = Неопределено,
		описаниеОшибки,
		информацияОбОшибке.Причина.Описание);
		
	Если отобразитьОписаниеОшибки Тогда
		текстСообщения = СтрШаблон(
			"%1.
			|————————————————————————————————————————————————————————————————————————————————
			|%2%3",
			текстСообщения,
			?(НЕ ПустаяСтрока(информацияОбОшибке.ИсходнаяСтрока),
				СтрШаблон("Исходная строка: %1%2", информацияОбОшибке.ИсходнаяСтрока, Символы.ПС),
				""),
			?(информацияОбОшибке.Причина = Неопределено ИЛИ информацияОбОшибке.Причина.Причина = Неопределено,
				"",
				СтрШаблон("Причина:%1%2", Символы.ПС, информацияОбОшибке.Причина.Причина.Описание)));
				
	КонецЕсли;
	
	Если НЕ ПустаяСтрока(текстПредварительногоСообщения) Тогда
		текстСообщения = СтрШаблон(
			"%1.
			|%2",
			текстПредварительногоСообщения,
			текстСообщения);
	КонецЕсли;
	
	СообщениеОтобразить(
		текстСообщения,
		?(статус = Неопределено,
			СтатусСообщения.Важное,
			статус));
			
	Возврат текстСообщения
	
КонецФункции

//ОбщегоНазначения.СообщитьИнформацию(текст,, статус);
Процедура СообщениеОтобразить(текст, статус = Неопределено, сигнал = Истина) Экспорт
	
	#Если Клиент Тогда
		
		Если статус = Неопределено Тогда
			статус = СтатусСообщения.Информация;
		КонецЕсли;
		
		Если сигнал Тогда Сигнал() конецЕсли;
		
		Сообщить(текст, статус);
		
	#Иначе
		
		ОбщегоНазначенияКлиентСервер.СообщитьПользователю(текст)
		
	#КонецЕсли
	
КонецПроцедуры

Процедура ПредупреждениеОтобразить(текст, заголовок = "", сигнал = Истина) Экспорт
	
	#Если Клиент Тогда
	
	Если сигнал Тогда Сигнал() конецЕсли;
	
	Предупреждение(
		текст,,
		?(ПустаяСтрока(заголовок),
			"Внимание",
			заголовок));
			
	#КонецЕсли
	
КонецПроцедуры

Процедура СостояниеОтобразить(текст = "") Экспорт
	
	#Если Клиент Тогда
	
	Состояние(текст);
	
	#КонецЕсли
	
КонецПроцедуры

Процедура СигналВоспроизвести(количество = 1) Экспорт
	
	#Если Клиент Тогда
	
	Перем счетчик;
	
	Для счетчик = 1 по количество цикл
		Сигнал()
	КонецЦикла;
	
	#КонецЕсли
	
КонецПроцедуры

Функция ФормаОткрыть(форма, открытьМодально = Ложь, параметрыФормы = Неопределено) Экспорт
	
	Перем параметрФормы;
	
	Если параметрыФормы <> Неопределено Тогда
		Для Каждого параметрФормы из параметрыФормы цикл
			Попытка
				форма[параметрФормы.Ключ] = параметрФормы.Значение;
			Исключение
				Попытка
					форма.ЭлементыФормы[параметрФормы.Ключ].Значение = параметрФормы.Значение;
				Исключение
					СообщениеОтобразить(параметрФормы.Ключ + " - реквизит формы отсутствует.", СтатусСообщения.Внимание);
				КонецПопытки;
			КонецПопытки;
		КонецЦикла;
	КонецЕсли;
	
	#Если Клиент Тогда
	
	Если форма.Открыта() Тогда
		
		форма.Активизировать();
		
	Иначе
		
		Если открытьМодально Тогда
			Возврат форма.ОткрытьМодально();
		Иначе
			форма.Открыть();
		КонецЕсли;
		
	КонецЕсли;
	
	#КонецЕсли
	
КонецФункции

Процедура ФормаОтборУстановить(форма, элементФормыСписок, имяСвойства, видСравнения, значениеСвойства,
	значениеСвойстваС = Неопределено, значениеСвойстваПо = Неопределено,
	использование = Истина, доступность = Истина) Экспорт
	
	Перем элементОтбора;
	
	Попытка
		элементФормыСписок.НастройкаОтбораСтрок[имяСвойства].Доступность = доступность;
		элементОтборатбора = элементФормыСписок.ОтборСтрок[имяСвойства];
	Исключение
		элементФормыСписок.НастройкаОтбора[имяСвойства].Доступность = доступность;
		элементОтбора = форма.Отбор[имяСвойства];
	КонецПопытки;
	
	элементОтбора.ВидСравнения = видСравнения;
	элементОтбора.Использование = использование;
	
	Если ЗначениеЗаполнено(значениеСвойства) Тогда
		элементОтбора.Значение = значениеСвойства;
	КонецЕсли;
	
	Если ЗначениеЗаполнено(значениеСвойстваС) Тогда
		элементОтбора.ЗначениеС = значениеСвойстваС;
	КонецЕсли;
	
	Если ЗначениеЗаполнено(значениеСвойстваПо) Тогда
		элементОтбора.ЗначениеПо = значениеСвойстваПо;
	КонецЕсли;
	
КонецПроцедуры

Процедура ФормаОтборДополнить(форма, элементФормыСписок, имяСвойства, видСравнения, значениеСвойства,
	использование = Истина, доступность = Истина) Экспорт
	
	Перем коллекцияИспользуемыхОтборов, новыйЭлементОтбора, элементОтбора;
	
	коллекцияИспользуемыхОтборов = ФормаОтборПолучитьИспользуемые(форма, элементФормыСписок);
	
	новыйЭлементОтбора = коллекцияИспользуемыхОтборов.Добавить();
	
	новыйЭлементОтбора.Имя = имяСвойства;
	новыйЭлементОтбора.ВидСравнения = видСравнения;
	новыйЭлементОтбора.Значение = значениеСвойства;
	новыйЭлементОтбора.Использование = использование;
	
	новыйЭлементОтбора.Доступность = доступность;
	
	Для Каждого элементОтбора из коллекцияИспользуемыхОтборов цикл
		элементОтбора.Использование =
			?(элементОтбора.Имя = имяСвойства,
			использование,
			форма.Отбор[элементОтбора.Имя].Использование);
		ФормаОтборУстановить(форма, элементФормыСписок, элементОтбора.Имя, элементОтбора.ВидСравнения, элементОтбора.Значение, элементОтбора.ЗначениеС, элементОтбора.ЗначениеПо, элементОтбора.Использование, элементОтбора.Доступность);
	КонецЦикла;
	
КонецПроцедуры

Функция ФормаОтборПолучитьИспользуемые(форма, элементФормыСписок) Экспорт
	
	Перем коллекцияИспользуемыхОтборов, элементОтбора, новыйЭлементОтбора;
	
	коллекцияИспользуемыхОтборов = Новый ТаблицаЗначений();
	коллекцияИспользуемыхОтборов.Колонки.Добавить("Имя", Новый ОписаниеТипов("Строка"), "Имя");
	коллекцияИспользуемыхОтборов.Колонки.Добавить("ВидСравнения", Новый ОписаниеТипов("ВидСравнения"), "Вид сравнения");
	
	коллекцияИспользуемыхОтборов.Колонки.Добавить("Доступность", Новый ОписаниеТипов("Булево"), "Доступность");
	коллекцияИспользуемыхОтборов.Колонки.Добавить("Использование", Новый ОписаниеТипов("Булево"), "Использование");
	
	коллекцияИспользуемыхОтборов.Колонки.Добавить("Значение", Неопределено, "Значение");
	коллекцияИспользуемыхОтборов.Колонки.Добавить("ЗначениеС", Неопределено, "Значение с");
	коллекцияИспользуемыхОтборов.Колонки.Добавить("ЗначениеПо", Неопределено, "Значение по");
	
	Для Каждого элементОтбора из форма.Отбор цикл
		
		Если НЕ элементОтбора.Использование = Истина Тогда Продолжить конецЕсли;
		
		новыйЭлементОтбора = коллекцияИспользуемыхОтборов.Добавить();
		
		новыйЭлементОтбора.Имя = элементОтбора.Имя;
		новыйЭлементОтбора.ВидСравнения = элементОтбора.ВидСравнения;
		
		новыйЭлементОтбора.Значение = элементОтбора.Значение;
		новыйЭлементОтбора.ЗначениеС = элементОтбора.ЗначениеС;
		новыйЭлементОтбора.ЗначениеПо = элементОтбора.ЗначениеПо;
		
		новыйЭлементОтбора.Доступность = элементФормыСписок.НастройкаОтбора[новыйЭлементОтбора.Имя].Доступность;
		
	КонецЦикла;
	
	Возврат коллекцияИспользуемыхОтборов
	
КонецФункции

//ЗаполнениеДокументов.ПроверитьЗаполнениеРеквизитов(
Функция ОбъектНезаполненыеРеквизитыТекстСообщенияПолучить(объект, контролируемыеРеквизитыСтрокой, Знач представленияКонтролируемыхРеквизитов = Неопределено) Экспорт
	
	Перем символРазделителя, контролируемыеРеквизиты;
	Перем незаполненныеРеквизиты, реквизитНаименование;
	Перем текстСообщения, счетчик;
	
	Если ПустаяСтрока(контролируемыеРеквизитыСтрокой) Тогда Возврат "" конецЕсли;
	
	Если СтрНайти(контролируемыеРеквизитыСтрокой, ",") > 0 Тогда
		символРазделителя = ",";
	ИначеЕсли СтрНайти(контролируемыеРеквизитыСтрокой, ";") > 0 Тогда
		символРазделителя = ";";
	Иначе
		символРазделителя = Символ(32);
	КонецЕсли;
	
	незаполненныеРеквизиты = Новый Массив;
	контролируемыеРеквизиты = СтрокаРазбитьНаСоставляющие(контролируемыеРеквизитыСтрокой, символРазделителя, Истина);
	
	Если представленияКонтролируемыхРеквизитов <> Неопределено Тогда
		представленияКонтролируемыхРеквизитов = СтрокаРазбитьНаСоставляющие(представленияКонтролируемыхРеквизитов, символРазделителя, Истина);
	КонецЕсли;
	
	Для счетчик = 1 по контролируемыеРеквизиты.Количество() цикл
		
		реквизитНаименование = контролируемыеРеквизиты.Получить(счетчик - 1);
		
		Если ЗначениеЗаполнено(объект[реквизитНаименование]) Тогда Продолжить конецЕсли;
		
		незаполненныеРеквизиты.Добавить(
			?(представленияКонтролируемыхРеквизитов = Неопределено,
			реквизитНаименование,
			представленияКонтролируемыхРеквизитов.Получить(счетчик - 1)));
			
	КонецЦикла;
	
	Если незаполненныеРеквизиты.Количество() = 0 Тогда Возврат "" конецЕсли;
	
	текстСообщения = СтрШаблон("%1 - проверить заполнение реквизитов:", объект.Метаданные().Синоним);
	
	Для счетчик = 1 по незаполненныеРеквизиты.Количество() цикл
		текстСообщения = СтрШаблон(
			"%1
			|%2. %3",
			текстСообщения,
			счетчик,
			незаполненныеРеквизиты[счетчик - 1]);
	КонецЦикла;
	
	СообщениеОтобразить(текстСообщения, СтатусСообщения.Внимание);
	
	Возврат текстСообщения
	
КонецФункции

Функция ПроконтролироватьЗаполнениеРеквизитовФормы(форма, переченьКонтролируемыхРеквизитов) Экспорт
	
	Перем переченьНезаполненныхРеквизитов, счетчик, имяРеквизита, текстСообщения;
	
	Если переченьКонтролируемыхРеквизитов = Неопределено ИЛИ переченьКонтролируемыхРеквизитов.Количество() = 0 Тогда Возврат Ложь конецЕсли;
	
	переченьНезаполненныхРеквизитов = Новый Массив();
	
	Для счетчик = 1 по переченьКонтролируемыхРеквизитов.Количество() цикл
		
		имяРеквизита = переченьКонтролируемыхРеквизитов[счетчик - 1];
		
		Если НЕ ЗначениеЗаполнено(форма[имяРеквизита]) Тогда
			переченьНезаполненныхРеквизитов.Добавить(имяРеквизита);
		КонецЕсли;
		
	КонецЦикла;
	
	Если переченьНезаполненныхРеквизитов.Количество() > 0 Тогда
		
		текстСообщения = "Проверить заполнение реквизитов:" + Символы.ПС;
		
		Для счетчик = 1 по переченьНезаполненныхРеквизитов.Количество() цикл
			текстСообщения = текстСообщения + Символы.ПС + счетчик + "." + Символы.Таб + переченьНезаполненныхРеквизитов[счетчик - 1];
		КонецЦикла;
		
		ПредупреждениеОтобразить(текстСообщения);
		
	КонецЕсли;
	
	Возврат переченьНезаполненныхРеквизитов.Количество() = 0
	
КонецФункции

Функция ОбъектМодифицированностьВФормеПроверить(объект, форма, текстВопроса = "Объект модифицирован. Для выполнения выбранного действия необходимо записать изменения. Продолжить?") Экспорт

	#Если Клиент Тогда
	
	Если НЕ форма.Модифицированность Тогда Возврат Истина конецЕсли;
	
	Если НЕ ВопросПолучитьПодтверждение(текстВопроса, Ложь) Тогда Возврат Ложь конецЕсли;
	
	Если Метаданные.Документы.Содержит(объект.Метаданные())
		И объект.Проведен Тогда
		
		Попытка
			Возврат форма.ЗаписатьВФорме(РежимЗаписиДокумента.Проведение)
		Исключение
			Возврат Ложь
		КонецПопытки;
		
	Иначе
		
		Возврат форма.ЗаписатьВФорме()
		
	КонецЕсли;
	
	#КонецЕсли
	
КонецФункции

Функция ОбъектСсылкаСохраненная(объект, запрашиватьПодтверждение = Истина, текстВопроса = "Для выполнения выбранного действия объект необходимо записать. Продолжить?", проверятьМодифицированностьОбъекта = Истина) Экспорт
	
	Если НЕ ЗначениеЗаполнено(объект.Ссылка) // этоНовый
		ИЛИ (проверятьМодифицированностьОбъекта И НЕ СсылкаЭто(объект) И объект.Модифицированность()) Тогда
		
		Если запрашиватьПодтверждение
			И НЕ ВопросПолучитьПодтверждение(текстВопроса) Тогда
			Возврат Ложь
		КонецЕсли;
		
		Попытка
			объект.Записать();
		Исключение
			ОтобразитьСообщениеОбОшибке(ОписаниеОшибки(), ИнформацияОбОшибке());
		КонецПопытки;
	
	КонецЕсли;
	
	Возврат Истина
	
КонецФункции

Функция ОбъектЗаписатьПолучитьСсылку(объект, структураДанных,
	текстСообщенияПриОшибке = "", уведомлять = Истина, замещать = Неопределено) Экспорт
	
	Перем возвращаемоеЗначение, типОбъекта, представлениеОбъекта;
	Перем информацияОбОшибке;
	Перем символПробелаОсновной;
	
	символПробелаОсновной = Символ(32);
	
	типОбъекта = СтрЗаменить(ТРег(Лев(Строка(ТипЗнч(объект)), Найти(Строка(ТипЗнч(объект)), ":") - 1)), символПробелаОсновной, "");
	
	Если типОбъекта = "СправочникОбъект" ИЛИ типОбъекта = "ДокументОбъект" Тогда
		
		представлениеОбъекта = "«" + Строка(объект) + "»";
		
	ИначеЕсли типОбъекта = "РегистрСведенийНаборЗаписей" Тогда
		
		представлениеОбъекта = СтрЗаменить(ТРег(Прав(Строка(ТипЗнч(объект)), СтрДлина(Строка(ТипЗнч(объект))) - Найти(Строка(ТипЗнч(объект)), ":") - 1)), символПробелаОсновной, "");
		
		Если представлениеОбъекта = "КонтактнаяИнформация" Тогда
			представлениеОбъекта = Строка(объект.Отбор.Объект) + ": " + объект.Отбор.Вид;
		ИначеЕсли представлениеОбъекта = "Штрихкоды" Тогда
			представлениеОбъекта = Строка(объект.Отбор.Владелец) + ": " + объект.Отбор.Штрихкод;
		Иначе
			представлениеОбъекта = "";
		КонецЕсли;
		
	КонецЕсли;
	
	Попытка
		
		Если замещать = Неопределено
			ИЛИ типОбъекта = "СправочникОбъект"
			ИЛИ типОбъекта = "ДокументОбъект" Тогда
			
			Если "ДокументОбъект" = типОбъекта Тогда
				объект.Записать(
					?(структураДанных.Свойство("Проведен") И структураДанных.Проведен,
					РежимЗаписиДокумента.Проведение,
					РежимЗаписиДокумента.Запись));
			Иначе
				объект.Записать();
			КонецЕсли;
			
			возвращаемоеЗначение = объект.Ссылка;
			
		Иначе
			
			Если замещать
				И ТипЗнч(объект) = Тип("РегистрСведенийНаборЗаписей.КонтактнаяИнформация") Тогда
				объект.Записать(Истина);
			Иначе
				Если НЕ объект.Записывать Тогда
					объект.Записывать = Истина;
				КонецЕсли;
				объект.Записать(замещать);
			КонецЕсли;
			
		КонецЕсли;
		
		Если уведомлять Тогда
		#Если Клиент Тогда
			Сообщить(НСтр("ru='Успешная попытка записи объекта типа '; uk=""Успішна спроба запису об'єкта типу """) + ТипЗнч(объект) + " - " + представлениеОбъекта);
		#КонецЕсли
		КонецЕсли;
		
	Исключение
		
		#Если Клиент Тогда
		Сообщить(НСтр("ru='Ошибка при попытке записи объекта типа '; uk=""Помилка при спробі запису об'єкта типу """) + ТипЗнч(объект) + " - " + представлениеОбъекта, СтатусСообщения.Важное);
		ОтобразитьСообщениеОбОшибке(ОписаниеОшибки(), ИнформацияОбОшибке());
		#КонецЕсли
		
		Если НЕ ПустаяСтрока(текстСообщенияПриОшибке) Тогда
		#Если Клиент Тогда
			Сообщить(текстСообщенияПриОшибке, СтатусСообщения.Важное);
		#КонецЕсли
		КонецЕсли;
		
		возвращаемоеЗначение = Неопределено;
		
	КонецПопытки;
	
	Возврат возвращаемоеЗначение
	
КонецФункции

Процедура ОбъектОткрытьВФорме(владелецФормы, объект) Экспорт
	
	Перем форма;
	
	Если НЕ ЗначениеЗаполнено(объект) Тогда
		
		форма = ОбъектСтруктураМетаданныхПолучить(объект).Менеджер.ПолучитьФормуСписка(, владелецФормы, владелецФормы);
		
	Иначе
		
		Попытка
			форма = объект.ПолучитьФорму("CRM_ФормаЭлемента", владелецФормы, владелецФормы);
		Исключение
			форма = объект.ПолучитьФорму("ФормаЭлемента", владелецФормы, владелецФормы);
		КонецПопытки;
		
	КонецЕсли;
	
	ФормаОткрыть(форма);
	
КонецПроцедуры

Процедура ОчиститьРеквизитыОбъекта(переченьРеквизитовОбъекта) Экспорт
	
	Перем счетчик, значениеРеквизитаОбъекта;
	
	Для счетчик = 1 по переченьРеквизитовОбъекта.Количество() цикл
		значениеРеквизитаОбъекта = переченьРеквизитовОбъекта[счетчик - 1];
		значениеРеквизитаОбъекта = Неопределено;
	КонецЦикла;
	
КонецПроцедуры

Процедура ОчиститьРеквизитыФормы(форма, переченьРеквизитовФормы) Экспорт
	
	Перем счетчик, имяРеквизитаФормы;
	
	Для счетчик = 1 по переченьРеквизитовФормы.Количество() цикл
		имяРеквизитаФормы = переченьРеквизитовФормы[счетчик - 1];
		форма[имяРеквизитаФормы] = Неопределено;
	КонецЦикла;
	
КонецПроцедуры

Процедура УстановитьЗначенияРеквизитовФормы(форма, переченьРеквизитовФормы, структураДанных) Экспорт
	
	Перем счетчик, имяРеквизитаФормы;
	
	Для счетчик = 1 по переченьРеквизитовФормы.Количество() цикл
		имяРеквизитаФормы = переченьРеквизитовФормы[счетчик - 1];
		форма[имяРеквизитаФормы].Значение = структураДанных[имяРеквизитаФормы];
	КонецЦикла;
	
КонецПроцедуры

Процедура УстановитьРежимПросмотраЭлементовФормы(форма, переченьЭлементовФормы, толькоПросмотр) Экспорт
	
	Перем счетчик, имяЭлементаФормы;
	
	Если переченьЭлементовФормы = Неопределено ИЛИ переченьЭлементовФормы.Количество() = 0 Тогда Возврат конецЕсли;
	
	Для счетчик = 1 по переченьЭлементовФормы.Количество() цикл
		имяЭлементаФормы = переченьЭлементовФормы[счетчик - 1];
		форма.ЭлементыФормы[имяЭлементаФормы].ТолькоПросмотр = толькоПросмотр;
	КонецЦикла;
	
КонецПроцедуры

Процедура СписокВыбораЭлементаУправленияУстановитьПоТипу(элементУправления, тип) Экспорт
	
	Если Тип("Булево") = тип Тогда
		СписокВыбораЭлементаУправленияБулевоУстановить(элементУправления);
	Иначе
		;
	КонецЕсли;
	
КонецПроцедуры

Процедура СписокВыбораЭлементаУправленияБулевоУстановить(элементУправления, добавлятьНеопределено = Ложь) Экспорт
	
	Перем списокВыбора;
	
	списокВыбора = Новый СписокЗначений();
	
	списокВыбора.Добавить(Ложь);
	списокВыбора.Добавить(Истина);
	
	Если добавлятьНеопределено Тогда
		списокВыбора.Добавить(Неопределено);
	КонецЕсли;
	
	элементУправления.СписокВыбора = списокВыбора;
	элементУправления.КнопкаСпискаВыбора = списокВыбора.Количество() > 0;
	элементУправления.КнопкаВыбора = списокВыбора.Количество() = 0;
	
КонецПроцедуры

Процедура СписокВыбораЭлементаУправленияПеречислениеУстановить(элементУправления, перечисление, исключаемыеЗначения = Неопределено) Экспорт
	
	Перем счетчик, списокВыбора;
	
	Если СтрЧислоВхождений(ТипЗнч(перечисление), "Перечисление") = 0 Тогда Возврат конецЕсли;
	
	списокВыбора = Новый СписокЗначений();
	
	Для счетчик = 1 по перечисление.Количество() цикл
		Если исключаемыеЗначения <> Неопределено И исключаемыеЗначения.Найти(перечисление[счетчик - 1]) <> Неопределено Тогда Продолжить конецЕсли;
		списокВыбора.Добавить(перечисление[счетчик - 1]);
	КонецЦикла;
	
	элементУправления.СписокВыбора = списокВыбора;
	элементУправления.КнопкаСпискаВыбора = списокВыбора.Количество() > 0;
	элементУправления.КнопкаВыбора = списокВыбора.Количество() = 0;
	
КонецПроцедуры

Процедура СписокВыбораЭлементаУправленияСправочникУстановить(элементУправления, исключаемыеЗначения = Неопределено, прятатьКнопкуВыбораЕслиЕстьСписок = Истина) Экспорт
	
	Перем списокВыбора, имяСправочника, справочникВыборка, объектСправочника;
	
	Попытка
		списокВыбора = элементУправления.СписокВыбора;
		имяСправочника = элементУправления.Значение.Метаданные().Имя;
	Исключение
		Возврат
	КонецПопытки;
	
	списокВыбора.Очистить();
	справочникВыборка = Справочники[имяСправочника].Выбрать();
	
	Пока справочникВыборка.Следующий() цикл
		Если справочникВыборка.ЭтоГруппа ИЛИ справочникВыборка.ПометкаУдаления Тогда Продолжить конецЕсли;
		Если исключаемыеЗначения <> Неопределено И исключаемыеЗначения.Найти(справочникВыборка.Ссылка) <> Неопределено Тогда Продолжить конецЕсли;
		списокВыбора.Добавить(справочникВыборка.Ссылка, справочникВыборка.Наименование);
	КонецЦикла;
	
	элементУправления.КнопкаСпискаВыбора = списокВыбора <> Неопределено И списокВыбора.Количество() > 0;
	
	Если прятатьКнопкуВыбораЕслиЕстьСписок Тогда
		элементУправления.КнопкаВыбора = НЕ элементУправления.КнопкаСпискаВыбора;
	КонецЕсли;
	
КонецПроцедуры

Функция ЖирныйШрифтПолучить() Экспорт
	
	Возврат Новый Шрифт(,, Истина)
	
КонецФункции

#Если Клиент Тогда

//ЭтотОбъект.Метаданные().Имя
Процедура СохранитьЗначенияРеквизитовПередЗакрытиемФормы(имя, структураХранимыхЗначений) Экспорт
	
	Перем структура, ключИЗначение;
	
	структура = Новый Структура;
	
	Для Каждого ключИЗначение из структураХранимыхЗначений цикл
		структура.Вставить(ключИЗначение.Ключ, ключИЗначение.Значение);
	КонецЦикла;
	
	СохранитьЗначение(имя, структура);
	
КонецПроцедуры

Функция ВосстановитьЗначенияРеквизитовПередОткрытиемФормы(имя, структураХранимыхЗначений) Экспорт
	
	Перем структура, ключИЗначение;
	
	структура = ВосстановитьЗначение(имя);
	
	Если структура = Неопределено Тогда Возврат структураХранимыхЗначений конецЕсли;
	
	Для Каждого ключИЗначение из структураХранимыхЗначений цикл
		
		Если НЕ структура.Свойство(ключИЗначение.Ключ) Тогда Продолжить конецЕсли;
		
		структураХранимыхЗначений[ключИЗначение.Ключ] = структура[ключИЗначение.Ключ];
		
	КонецЦикла;
	
	Возврат структураХранимыхЗначений
	
КонецФункции

#КонецЕсли

#КонецОбласти


#Область Индикатор

Функция УстановитьВидимостьИндикатораПрогресса(форма, параметрОтображания = Неопределено, подсказка = "", отобразитьВСтрокеСостояния = Истина, элементФормыИндикатор = Неопределено) Экспорт
	Перем подсказкаПоУмолчанию;
	Перем символПробелаОсновной;
	
	#Если Клиент Тогда
		
	символПробелаОсновной = Символ(32);
	
	Если элементФормыИндикатор = Неопределено Тогда элементФормыИндикатор = форма.ЭлементыФормы.Индикатор конецЕсли;
	
	элементФормыИндикатор.Значение = 0;
	элементФормыИндикатор.Подсказка = подсказка;
	
	Если параметрОтображания = Неопределено Тогда
		элементФормыИндикатор.Видимость = Ложь;
		
	ИначеЕсли ТипЗнч(параметрОтображания) = ТипЗнч("Булево") Тогда
		элементФормыИндикатор.Индикатор.Видимость = Ложь;
		
	ИначеЕсли ТипЗнч(параметрОтображания) = ТипЗнч("Число") Тогда
		элементФормыИндикатор.МаксимальноеЗначение = параметрОтображания;
		элементФормыИндикатор.Видимость = Истина;
		
	Иначе
		
		Попытка
			элементФормыИндикатор.МаксимальноеЗначение = параметрОтображания.Количество();
		Исключение
		КонецПопытки;
		
		элементФормыИндикатор.Видимость = Истина;
	КонецЕсли;
	
	Если элементФормыИндикатор.Видимость Тогда
		подсказкаПоУмолчанию = НСтр("ru='Для прерывания нажать комбинацию клавиш <Ctrl + Break>...'; uk='Для припинення натиснути комбінацію клавіш <Ctrl + Break>...'");
		подсказка =
			?(ПустаяСтрока(подсказка),
			подсказкаПоУмолчанию,
			подсказка + символПробелаОсновной + подсказкаПоУмолчанию);
		элементФормыИндикатор.Подсказка = подсказка;
		
		Если отобразитьВСтрокеСостояния Тогда
			Состояние(подсказка);
		КонецЕсли;
	КонецЕсли;
	
	форма.ЭлементыФормы.ИнфНадписьОстаток.Видимость = НЕ элементФормыИндикатор.Видимость;//
	форма.ЭлементыФормы.ОсновныеДействияФормы.Видимость = НЕ элементФормыИндикатор.Видимость;//
	#КонецЕсли
	
	Возврат элементФормыИндикатор;
КонецФункции

Функция УстановитьЗначениеИндикатораПрогресса(форма, значение = Неопределено, элементФормыИндикатор = Неопределено) Экспорт
	
	Если элементФормыИндикатор = Неопределено Тогда индикаторПрогресса = форма.ЭлементыФормы.Индикатор конецЕсли;
	
	Если значение = Неопределено Тогда
		индикаторПрогресса.Значение = индикаторПрогресса.Значение + 1;
		
	Иначе
		индикаторПрогресса.Значение = значение;
	КонецЕсли;
	
	//Якщо перервано користувачем - приховати індикатор
	индикаторПрогресса.Видимость = Ложь;
	#Если Клиент Тогда
	ОбработкаПрерыванияПользователя();
	#КонецЕсли
	
	индикаторПрогресса.Видимость = индикаторПрогресса.Значение < индикаторПрогресса.МаксимальноеЗначение;
	
	Если
		индикаторПрогресса.Видимость ИЛИ
		индикаторПрогресса.Значение = индикаторПрогресса.МаксимальноеЗначение
		Тогда
		
		Возврат Истина;
	Иначе
		
		Возврат Ложь;//Перервано користувачем
	КонецЕсли;
КонецФункции

#КонецОбласти


#Область Залишки

Функция ПартииТоваровНаСкладахОстаткиПолучить(склад, организация, управленческийУчет = Истина, дата = Неопределено, счетЗатрат = Неопределено) Экспорт
	
	Перем запрос, результатВыполненияЗапроса;
	
	запрос = Новый Запрос;
	
	запрос.Текст = "ВЫБРАТЬ
	               |	Таблица.Номенклатура,
	               |	Таблица.КоличествоКонечныйОстаток КАК Количество,
	               |	Таблица.Номенклатура.ЕдиницаХраненияОстатков КАК ЕдиницаИзмерения,
	               |	Таблица.Номенклатура.ЕдиницаХраненияОстатков.Коэффициент КАК Коэффициент,
	               |	Таблица.Качество КАК Качество" +
		?(счетЗатрат = Неопределено,
		"",
	               ",
	               |	Таблица.СчетУчета КАК СчетЗатрат") +
		?(управленческийУчет,
		"",
	               ",
	               |	Таблица.НалоговоеНазначение КАК НалоговоеНазначение") + "
	               |ИЗ" + СтрШаблон("
	               |	%1(, &КонецПериода, , , Склад = &Склад И Организация = &Организация%2) КАК Таблица",
		?(управленческийУчет,
			"РегистрНакопления.ПартииТоваровНаСкладах.ОстаткиИОбороты",
			"РегистрНакопления.ПартииТоваровНаСкладахБухгалтерскийУчет.ОстаткиИОбороты"),
		?(счетЗатрат = Неопределено,
			"",
			" И СчетУчета = &СчетУчета"));
			
	Если счетЗатрат <> Неопределено Тогда
		запрос.УстановитьПараметр("СчетУчета", счетЗатрат);
	КонецЕсли;
	
	запрос.УстановитьПараметр("Организация", организация);
	запрос.УстановитьПараметр("Склад", склад);
	запрос.УстановитьПараметр("КонецПериода",
		?(дата = Неопределено,
		ТекущаяДата(),
		дата));
		
	результатВыполненияЗапроса = запрос.Выполнить();
	
	Возврат результатВыполненияЗапроса.Выгрузить()
	
КонецФункции

Функция ПартииТоваровНаСкладахБухгалтерскийУчетТекущийОстатокПоНоменклатуреВЕдиницахХраненияОстатковПолучить(номенклатура, склад = Неопределено, дата = Неопределено) Экспорт
	Перем запрос, результатВыполненияЗапроса;
	
	запрос = Новый Запрос;
	
	запрос.Текст = "ВЫБРАТЬ ПЕРВЫЕ 1
	               |	ПартииТоваровНаСкладахБухгалтерскийУчетОстаткиИОбороты.КоличествоКонечныйОстаток
	               |ИЗ
	               |	РегистрНакопления.ПартииТоваровНаСкладахБухгалтерскийУчет.ОстаткиИОбороты(, &КонецПериода, , , ) КАК ПартииТоваровНаСкладахБухгалтерскийУчетОстаткиИОбороты
	               |ГДЕ
	               |	ПартииТоваровНаСкладахБухгалтерскийУчетОстаткиИОбороты.Номенклатура = &Номенклатура";
	Если ЗначениеЗаполнено(склад) Тогда
		запрос.Текст = запрос.Текст + "
	               |	И ПартииТоваровНаСкладахБухгалтерскийУчетОстаткиИОбороты.Склад = &Склад";
		запрос.УстановитьПараметр("Склад", склад);
	КонецЕсли;
	
	запрос.УстановитьПараметр("Номенклатура", номенклатура);
	запрос.УстановитьПараметр("КонецПериода",
	?(дата = Неопределено,
		ТекущаяДата(),
		дата));
		
	результатВыполненияЗапроса = запрос.Выполнить();
	
	Возврат
		?(результатВыполненияЗапроса.Пустой(),
		0,
		результатВыполненияЗапроса.Выгрузить().Получить(0).КоличествоКонечныйОстаток)
		
КонецФункции

Функция ПартииТоваровНаСкладахТекущийОстатокПоНоменклатуреВЕдиницахХраненияОстатковПолучить(номенклатура, склад = Неопределено, дата = Неопределено) Экспорт
	Перем запрос, результатВыполненияЗапроса;
	
	запрос = Новый Запрос;
	
	запрос.Текст = "ВЫБРАТЬ ПЕРВЫЕ 1
	               |	ПартииТоваровНаСкладахОстаткиИОбороты.КоличествоКонечныйОстаток
	               |ИЗ
	               |	РегистрНакопления.ПартииТоваровНаСкладах.ОстаткиИОбороты(, &КонецПериода, , , ) КАК ПартииТоваровНаСкладахОстаткиИОбороты
	               |ГДЕ
	               |	ПартииТоваровНаСкладахОстаткиИОбороты.Номенклатура = &Номенклатура";
	Если ЗначениеЗаполнено(склад) Тогда
		запрос.Текст = запрос.Текст + "
	               |	И ПартииТоваровНаСкладахОстаткиИОбороты.Склад = &Склад";
		запрос.УстановитьПараметр("Склад", склад);
	КонецЕсли;
	
	запрос.УстановитьПараметр("Номенклатура", номенклатура);
	запрос.УстановитьПараметр("КонецПериода",
		?(дата = Неопределено,
		ТекущаяДата(),
		дата));
		
	результатВыполненияЗапроса = запрос.Выполнить();
	
	Возврат
		?(результатВыполненияЗапроса.Пустой(),
		0,
		результатВыполненияЗапроса.Выгрузить().Получить(0).КоличествоКонечныйОстаток)
		
КонецФункции

Функция ТоварыНаСкладахТекущийОстатокПоНоменклатуреВЕдиницахХраненияОстатковПолучить(номенклатура, склад = Неопределено, дата = Неопределено) Экспорт
	Перем запрос, результатВыполненияЗапроса;
	
	запрос = Новый Запрос;
	
	запрос.Текст = "ВЫБРАТЬ ПЕРВЫЕ 1
	               |	ТоварыНаСкладахОстаткиИОбороты.КоличествоКонечныйОстаток
	               |ИЗ
	               |	РегистрНакопления.ТоварыНаСкладах.ОстаткиИОбороты(, &КонецПериода, , , ) КАК ТоварыНаСкладахОстаткиИОбороты
	               |ГДЕ
	               |	ТоварыНаСкладахОстаткиИОбороты.Номенклатура = &Номенклатура";
	
	запрос.УстановитьПараметр("Номенклатура", номенклатура);
	запрос.УстановитьПараметр("КонецПериода",
		?(дата = Неопределено,
		ТекущаяДата(),
		дата));
		
	Если ЗначениеЗаполнено(склад) Тогда
		запрос.Текст = запрос.Текст + "
	               |	И ТоварыНаСкладахОстаткиИОбороты.Склад = &Склад";
		запрос.УстановитьПараметр("Склад", склад);
	КонецЕсли;
	
	результатВыполненияЗапроса = запрос.Выполнить();
	
	Возврат
		?(результатВыполненияЗапроса.Пустой(),
		0,
		результатВыполненияЗапроса.Выгрузить().Получить(0).КоличествоКонечныйОстаток)
		
КонецФункции

Процедура ТоварыНаСкладахТекущийОстатокПоНоменклатуреВЕдиницахХраненияОстатковОтобразитьВЭлементеУправления(элементУправления, номенклатура, склад = Неопределено, дата = Неопределено) Экспорт
	Перем текущийОстаток;
	
	текущийОстаток = ТоварыНаСкладахТекущийОстатокПоНоменклатуреВЕдиницахХраненияОстатковПолучить(номенклатура, склад, дата);
	элементУправления.Видимость = текущийОстаток > 0;
	
	Если НЕ элементУправления.Видимость Тогда Возврат конецЕсли;
	
	элементУправления.Заголовок =
		?(ЗначениеЗаполнено(склад),
		"Остаток на складе «" + склад + "» составляет: " + текущийОстаток + Символ(32) + номенклатура.БазоваяЕдиницаИзмерения,
		"Остаток на складах составляет: " + текущийОстаток + Символ(32) + номенклатура.БазоваяЕдиницаИзмерения);
		
КонецПроцедуры

Процедура ПартииТоваровНаСкладахБухгалтерскийУчетТекущийОстатокПоНоменклатуреВЕдиницахХраненияОстатковОтобразитьВЭлементеУправления(элементУправления, номенклатура, склад = Неопределено, дата = Неопределено) Экспорт
	Перем текущийОстаток;
	
	текущийОстаток = ПартииТоваровНаСкладахБухгалтерскийУчетТекущийОстатокПоНоменклатуреВЕдиницахХраненияОстатковПолучить(номенклатура, склад, дата);
	элементУправления.Видимость = текущийОстаток > 0;
	
	Если НЕ элементУправления.Видимость Тогда Возврат конецЕсли;
	
	элементУправления.Заголовок =
		?(ЗначениеЗаполнено(склад),
		"Остаток по партиях на складе «" + склад + "» составляет: " + текущийОстаток + Символ(32) + номенклатура.ЕдиницаХраненияОстатков,
		"Остаток по партиях на складах составляет: " + текущийОстаток + Символ(32) + номенклатура.ЕдиницаХраненияОстатков);
		
КонецПроцедуры

Процедура ПартииТоваровНаСкладахТекущийОстатокПоНоменклатуреВЕдиницахХраненияОстатковОтобразитьВЭлементеУправления(элементУправления, номенклатура, склад = Неопределено, дата = Неопределено) Экспорт
	Перем текущийОстаток;
	
	текущийОстаток = ПартииТоваровНаСкладахТекущийОстатокПоНоменклатуреВЕдиницахХраненияОстатковПолучить(номенклатура, склад, дата);
	элементУправления.Видимость = текущийОстаток > 0;
	
	Если НЕ элементУправления.Видимость Тогда Возврат конецЕсли;
	
	элементУправления.Заголовок =
		?(ЗначениеЗаполнено(склад),
		"Остаток по партиях на складе «" + склад + "» составляет: " + текущийОстаток + Символ(32) + номенклатура.ЕдиницаХраненияОстатков,
		"Остаток по партиях на складах составляет: " + текущийОстаток + Символ(32) + номенклатура.ЕдиницаХраненияОстатков);
		
КонецПроцедуры

#КонецОбласти


#Область ОбєктиКонфігурації

Функция НалогСтавкаНаПрибыльПолучить(дата = Неопределено, организация) Экспорт
	
	Если дата = Неопределено Тогда
		дата = ТекущаяДата();
	КонецЕсли;
	
	запрос = Новый Запрос;
	
	запрос.Текст = "ВЫБРАТЬ ПЕРВЫЕ 1
	               |	СтавкиНалогаНаПрибыльСрезПоследних.Ставка КАК Ставка
	               |ИЗ
	               |	РегистрСведений.СтавкиНалогаНаПрибыль.СрезПоследних(&Период, Организация = &Организация) КАК СтавкиНалогаНаПрибыльСрезПоследних";
	
	запрос.Параметры.Вставить("Период", дата);
	запрос.Параметры.Вставить("Организация", организация);
	
	результатВыполненияЗапроса = запрос.Выполнить();
	
	Возврат
		?(результатВыполненияЗапроса.Пустой(),
		Неопределено,
		результатВыполненияЗапроса.Выгрузить().Получить(0).Ставка)
		
КонецФункции

Функция НалогСтавкаНДФЛПолучить(дата = Неопределено, перечислениеВидыСтавокНДФЛ = Неопределено) Экспорт
	
	Если дата = Неопределено Тогда
		дата = ТекущаяДата();
	КонецЕсли;
	
	//Возврат РегистрыСведений.СтавкиНДФЛ.ПолучитьПоследнее(дата, Новый Структура("ВидСтавки", Перечисления.ВидыСтавокНДФЛ.Основная)).Ставка;
	
	Если перечислениеВидыСтавокНДФЛ = Неопределено Тогда
		перечислениеВидыСтавокНДФЛ = Перечисления.ВидыСтавокНДФЛ.Основная;
	КонецЕсли;
	
	запрос = Новый Запрос;
	
	запрос.Текст = "ВЫБРАТЬ ПЕРВЫЕ 1
	               |	СтавкиНДФЛСрезПоследних.Ставка КАК Ставка
	               |ИЗ
	               |	РегистрСведений.СтавкиНДФЛ.СрезПоследних(&Период, ВидСтавки = &ВидСтавки) КАК СтавкиНДФЛСрезПоследних";
	
	запрос.Параметры.Вставить("Период", дата);
	запрос.Параметры.Вставить("ВидСтавки", перечислениеВидыСтавокНДФЛ);
	
	результатВыполненияЗапроса = запрос.Выполнить();
	
	Возврат
		?(результатВыполненияЗапроса.Пустой(),
		Неопределено,
		результатВыполненияЗапроса.Выгрузить().Получить(0).Ставка)
		
КонецФункции

Функция НалогСтавкаВоенныйСборПолучить(дата = Неопределено) Экспорт
	
	//Возврат РегистрыСведений.СтавкиНДФЛ.ПолучитьПоследнее(дата, Новый Структура("ВидСтавки", Перечисления.ВидыСтавокНДФЛ.ВоенныйСбор)).Ставка
	
	Возврат НалогСтавкаНДФЛПолучить(дата, Перечисления.ВидыСтавокНДФЛ.ВоенныйСбор)
	
КонецФункции

Функция НалогСтавкаНДСПолучить(перечислениеСтавкаНДС = Неопределено, получитьПредставление = Ложь) Экспорт
	
	Если перечислениеСтавкаНДС = Неопределено
		ИЛИ ПредопределенноеЗначение("Перечисление.СтавкиНДС.НДС20") = перечислениеСтавкаНДС Тогда
		
		Возврат
			?(получитьПредставление,
			"20%",
			0.2)
			
	ИначеЕсли ПредопределенноеЗначение("Перечисление.СтавкиНДС.НДС7") = перечислениеСтавкаНДС Тогда
		
		Возврат
			?(получитьПредставление,
			"7%",
			0.07)
			
	ИначеЕсли ПредопределенноеЗначение("Перечисление.СтавкиНДС.БезНДС") = перечислениеСтавкаНДС
		ИЛИ ПредопределенноеЗначение("Перечисление.СтавкиНДС.НеНДС") = перечислениеСтавкаНДС
		ИЛИ ПредопределенноеЗначение("Перечисление.СтавкиНДС.НДС0") = перечислениеСтавкаНДС Тогда
		
		Возврат
			?(получитьПредставление,
			"Без НДС",
			0)
			
	КонецЕсли;
	
КонецФункции

Функция СуммаНДСПолучить(перечислениеСтавкаНДС = Неопределено, сумма) Экспорт
	
	Если перечислениеСтавкаНДС = Неопределено Тогда
		перечислениеСтавкаНДС = Перечисления.СтавкиНДС.НДС20;
	КонецЕсли;
	
	Возврат сумма - (сумма / (1 + НалогСтавкаНДСПолучить(перечислениеСтавкаНДС)))
	
КонецФункции

Функция СуммаСУчетомНДСПолучить(перечислениеСтавкаНДС = Неопределено, сумма, суммаВключаетНДС, расчетБазовойСуммы = Ложь) Экспорт
	
	Если перечислениеСтавкаНДС = Неопределено Тогда
		перечислениеСтавкаНДС = Перечисления.СтавкиНДС.НДС20;
	КонецЕсли;
	
	Если расчетБазовойСуммы Тогда
		
		Возврат
			?(суммаВключаетНДС,
			сумма,
			сумма / (1 + НалогСтавкаНДСПолучить(перечислениеСтавкаНДС)))
			
	Иначе
		
		Возврат
			?(суммаВключаетНДС,
			сумма,
			сумма * (1 - НалогСтавкаНДСПолучить(перечислениеСтавкаНДС)))
			
	КонецЕсли;
	
КонецФункции

Функция СвойствоОбъектаПолучить(объектСсылка, наименованиеСвойства) Экспорт
	
	Перем назначениеСвойства, планВидовХарактеристикВыборка;
	
	Если Тип("СправочникСсылка.Проекты") = ТипЗнч(объектСсылка) Тогда
		назначениеСвойства = ПланыВидовХарактеристик.НазначенияСвойствКатегорийОбъектов.Справочник_Проекты;
	Иначе
		ВызватьИсключениеОтсутствиеРеализации()
	КонецЕсли;
	
	планВидовХарактеристикВыборка = ПланыВидовХарактеристик.СвойстваОбъектов.Выбрать(
		назначениеСвойства,
		Новый Структура("Наименование", наименованиеСвойства));
		
	Пока планВидовХарактеристикВыборка.Следующий() цикл
		Возврат планВидовХарактеристикВыборка.Ссылка
	КонецЦикла;
	
	Возврат Неопределено
	
КонецФункции

Функция ЗначениеСвойстваОбъектаВыбрать(свойствоОбъекта, наименованиеЗначения = "") Экспорт
	
	Перем значениеСвойства, справочникВыборка, получитьСписокЗначений;
	
	получитьСписокЗначений = ПустаяСтрока(наименованиеЗначения);
	
	Если получитьСписокЗначений Тогда
		справочникВыборка = Справочники.ЗначенияСвойствОбъектов.Выбрать(, свойствоОбъекта);
		списокЗначенийСвойств = Новый СписокЗначений;
	Иначе
		справочникВыборка = Справочники.ЗначенияСвойствОбъектов.Выбрать(, свойствоОбъекта, Новый Структура("Наименование", наименованиеЗначения));
	КонецЕсли;
	
	Пока справочникВыборка.Следующий() цикл
		
		Если получитьСписокЗначений Тогда
			списокЗначенийСвойств.Добавить(справочникВыборка.Ссылка);
		Иначе
			Возврат справочникВыборка.Ссылка
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат списокЗначенийСвойств
	
КонецФункции

Функция ЗначениеСвойстваОбъектаПолучить(объектСсылка, наименованиеСвойства, наименованиеЗначения, значениеПоУмолчанию = Неопределено) Экспорт
	
	Перем свойствоОбъекта;
	
	свойствоОбъекта = СвойствоОбъектаПолучить(объектСсылка, наименованиеСвойства);
	
	Если свойствоОбъекта = Неопределено Тогда Возврат значениеПоУмолчанию конецЕсли;
	
	Возврат ЗначениеСвойстваОбъектаВыбрать(свойствоОбъекта, наименованиеЗначения)
	
КонецФункции

Функция ПеречислениеСписокЗначенийПолучить(перечислениеМенеджер) Экспорт
	
	Перем списокЗначений, объектМетаданных, подобъектМетаданных, имяПеречисления;
	
	списокЗначений = Новый СписокЗначений;
	
	//объектМетаданных = перечислениеСсылка.Метаданные();
	//имяПеречисления = объектМетаданных.Имя;
	//
	//Для Каждого подобъектМетаданных из объектМетаданных.ЗначенияПеречисления цикл
	//	списокЗначений.Добавить(Перечисления[имяПеречисления][подобъектМетаданных.Имя]);
	//КонецЦикла;
	
	Для Каждого элемент из перечислениеМенеджер цикл
		списокЗначений.Добавить(элемент, ПеречислениеПолучитьКомментарийДляЗначения(элемент));
	КонецЦикла;
	
	Возврат списокЗначений
	
КонецФункции

Функция ПеречислениеПолучитьКомментарийДляЗначения(значениеПеречисления) Экспорт
	
	Для Каждого элемент из значениеПеречисления.Метаданные().ЗначенияПеречисления цикл
		
		Если элемент.Синоним <> Строка(значениеПеречисления) Тогда Продолжить конецЕсли;
		
		Возврат
			?(ПустаяСтрока(элемент.Комментарий),
			элемент.Синоним,
			элемент.Комментарий)
			
	КонецЦикла;
	
	Возврат ""
	
КонецФункции

Функция ПеречислениеПолучитьИмяЗначения(значениеПеречисления) Экспорт
	
	Для Каждого элемент из значениеПеречисления.Метаданные().ЗначенияПеречисления цикл
		
		Если элемент.Синоним <> Строка(значениеПеречисления) Тогда Продолжить конецЕсли;
		
		Возврат элемент.Имя
		
	КонецЦикла;
	
	Возврат ""
	
КонецФункции

Функция ПеречислениеЗначениеПолучитьПоСиноним(перечислениеМенеджер, синонимЗначенияПеречисления, сообщатьЕслиОтсутствует = Ложь, кодЯзыка = Неопределено) Экспорт
	
	Если кодЯзыка = Неопределено Тогда
		кодЯзыка = КодЯзыкаПользователяПолучить();
	КонецЕсли;
	
	Если НЕ ЗначениеЗаполнено(синонимЗначенияПеречисления) Тогда Возврат перечислениеМенеджер.ПустаяСсылка() конецЕсли;
	
	Для Каждого элемент из ПеречислениеСписокЗначенийПолучить(перечислениеМенеджер) цикл
		
		Попытка
			синоним = перечислениеМенеджер.ЛокализацияПолучитьЛокализованноеПредставление(элемент.Значение, кодЯзыка);
		Исключение
			синоним = элемент.Представление;
		КонецПопытки;
		
		Если НЕ синоним = синонимЗначенияПеречисления Тогда Продолжить конецЕсли;
		
		Возврат элемент.Значение
		
	КонецЦикла;
	
	Если сообщатьЕслиОтсутствует Тогда
		СообщениеОтобразить(синонимЗначенияПеречисления + " - значение НЕ найдено в перечислении " + перечислениеМенеджер.ПустаяСсылка().Метаданные().Синоним, СтатусСообщения.Внимание);
	КонецЕсли;
	
	Возврат перечислениеМенеджер.ПустаяСсылка()
	
КонецФункции

Функция ПеречислениеСоответствиеПредставленийЗначенийПолучить(менеджерТипа, кодЯзыка = Неопределено) Экспорт
	
	Если кодЯзыка = Неопределено Тогда
		кодЯзыка = КодЯзыкаПользователяПолучить();
	КонецЕсли;
	
	соответствиеПредставленийЗначений = Новый Соответствие;
	
	Для Каждого ссылка из менеджерТипа цикл
		Попытка
			соответствиеПредставленийЗначений.Вставить(ссылка, менеджерТипа.ЛокализацияПолучитьЛокализованноеПредставление(ссылка, кодЯзыка));
		Исключение
			СообщениеОтобразить(Строка(менеджерТипа) + " - НЕ реализован метод для получения локализированного представления значений.", СтатусСообщения.Важное);
		КонецПопытки;
	КонецЦикла;
	
	Возврат соответствиеПредставленийЗначений
	
КонецФункции

Функция НоменклатураНайтиПоНаименованиеПолное(наименованиеПолное, выбратьПервуюЗапись = Истина) Экспорт
	
	Перем запрос;
	
	запрос = Новый Запрос;
	запрос.Текст = "ВЫБРАТЬ";
	Если выбратьПервуюЗапись Тогда
		запрос.Текст = запрос.Текст + " ПЕРВЫЕ 1";
	КонецЕсли;
	
	запрос.Текст = запрос.Текст + "
	               |	Номенклатура.Ссылка
	               |ИЗ
	               |	Справочник.Номенклатура КАК Номенклатура
	               |ГДЕ
	               |	Номенклатура.НаименованиеПолное ПОДОБНО &НаименованиеПолное";
	
	запрос.Параметры.Вставить("НаименованиеПолное", наименованиеПолное);
	
	результатВыполненияЗапроса = запрос.Выполнить();
	
	Если выбратьПервуюЗапись Тогда
		
		Возврат
			?(результатВыполненияЗапроса.Пустой(),
			Справочники.Номенклатура.ПустаяСсылка(),
			результатВыполненияЗапроса.Выгрузить().ВыгрузитьКолонку("Ссылка").Получить(0))
			
	Иначе
		
		Возврат
			?(результатВыполненияЗапроса.Пустой(),
			Новый Массив,
			результатВыполненияЗапроса.Выгрузить().ВыгрузитьКолонку("Ссылка"))
			
	КонецЕсли;
	
КонецФункции

Функция ОбъектРодительВерхнегоУровняПолучить(объект, вернутьИерархиюВВидеСтроки = Ложь) Экспорт
	
	Перем группаОбъекта, иерархияРазмещения, родительВерхнегоУровня;
	
	группаОбъекта = объект.Родитель;
	родительВерхнегоУровня = Неопределено;
	иерархияРазмещения = "";
	
	Пока ЗначениеЗаполнено(группаОбъекта) цикл
		
		родительВерхнегоУровня = группаОбъекта;
		иерархияРазмещения = СтрШаблон("%1\%2", группаОбъекта, иерархияРазмещения);
		
		группаОбъекта = группаОбъекта.Родитель;
		
	КонецЦикла;
	
	Возврат
		?(вернутьИерархиюВВидеСтроки,
		иерархияРазмещения,
		родительВерхнегоУровня)
		
КонецФункции

Функция СвязанныеДокументыПолучить(ссылка, пропускатьПомеченныеНаУдаление = Ложь) Экспорт
	
	Перем связанныеДокументы;
	// Общие-КритерииОтбора-СвязанныеДокументы-Состав
	// (ПодчиненныйДокумен)
	// х ДокументОснование
	
	связанныеДокументы = ПолныеПрава.ПолучитьВыборкуПоКритериюОтбора("СвязанныеДокументы", ссылка);
	
	Если связанныеДокументы.Количество() = 0 Тогда Возврат Новый Массив конецЕсли;
	
	связанныеДокументы = связанныеДокументы.ВыгрузитьКолонку("Ссылка");
	
	Если пропускатьПомеченныеНаУдаление Тогда
		КоллекцияОбъектовЗначенияОтобрать(связанныеДокументы, "ПометкаУдаления", Ложь);
	КонецЕсли;
	
	Возврат связанныеДокументы
	
КонецФункции

Функция СвязанныеДокументыПолучитьПоТипу(ссылка, типСвязанногоДокумента,
	получитьПервый = Ложь, оповеститьЕслиЕстьДокументы = Ложь, пропускатьПомеченныеНаУдаление = Ложь) Экспорт
	
	Перем массивДокументов;
	
	массивДокументов = Новый Массив;
	
	Для Каждого документ из СвязанныеДокументыПолучить(ссылка, пропускатьПомеченныеНаУдаление) цикл
		
		Если ТипЗнч(документ) <> типСвязанногоДокумента Тогда Продолжить конецЕсли;
		
		массивДокументов.Добавить(документ);
		
		Если получитьПервый Тогда Прервать конецЕсли;
		
	КонецЦикла;
	
	Если массивДокументов.Количество() = 0 Тогда
		Возврат
			?(получитьПервый,
			Неопределено,
			Новый Массив)
	КонецЕсли;
	
	МассивУдалитьПовторяющиесяЭлементы(массивДокументов);
	
	Если оповеститьЕслиЕстьДокументы Тогда
		
		СообщениеОтобразить(СтрШаблон("Связанные документы %1 для %2:", типСвязанногоДокумента, ссылка), СтатусСообщения.Внимание);
		
		Для счетчик = 1 по массивДокументов.Количество() цикл
			СообщениеОтобразить(СтрШаблон(
				"%1. %2",
				счетчик,
				массивДокументов.Получить(счетчик - 1)), СтатусСообщения.БезСтатуса, Ложь);
		КонецЦикла;
		
	КонецЕсли;
	
	Возврат
		?(получитьПервый,
		массивДокументов.Получить(0),
		массивДокументов)
		
КонецФункции

Процедура СвязанныеДокументыОткрытьВФорме(объектСсылка) Экспорт
	
	#Если Клиент Тогда
	
	Перем формаСвязанныеДокументы;
	
	Если объектСсылка = Неопределено ИЛИ НЕ ЗначениеЗаполнено(объектСсылка.Ссылка) Тогда Возврат конецЕсли;
	
	формаСвязанныеДокументы = КритерииОтбора.СвязанныеДокументы.ПолучитьФорму();
	
	формаСвязанныеДокументы.ПараметрОтборПоЗначению = объектСсылка.Ссылка;
	формаСвязанныеДокументы.Открыть();
	
	#КонецЕсли
	
КонецПроцедуры

Процедура СвязанныеДокументыОткрытьСтруктуруПодчиненностиВФорме(документСсылка) Экспорт
	
	#Если Клиент Тогда
	
	Если документСсылка = Неопределено ИЛИ НЕ ЗначениеЗаполнено(документСсылка.Ссылка) Тогда Возврат конецЕсли;
	
	РаботаСДиалогами.ПоказатьСтруктуруПодчиненностиДокумента(документСсылка);
	
	#КонецЕсли
	
КонецПроцедуры

Функция ПрочитатьНаборЗаписейКонтактнойИнформации(ссылка, перечислениеТипыКонтактнойИнформации = Неопределено) Экспорт
	
	Перем запрос, таблицаЗначений, строка;
	
	запрос = Новый Запрос;
	
	запрос.Текст = "ВЫБРАТЬ РАЗРЕШЕННЫЕ * ИЗ РегистрСведений.КонтактнаяИнформация ГДЕ Объект = &Объект";
	запрос.УстановитьПараметр("Объект", ссылка);
	
	таблицаЗначений = запрос.Выполнить().Выгрузить();
	
	Если перечислениеТипыКонтактнойИнформации <> Неопределено И Тип("ПеречислениеСсылка.ТипыКонтактнойИнформации") = ТипЗнч(перечислениеТипыКонтактнойИнформации) Тогда
		
		Для Каждого строка из таблицаЗначений цикл
			Если запрос.Тип = ТипЗнч(перечислениеТипыКонтактнойИнформации) Тогда Продолжить конецЕсли;
			таблицаЗначений.Удалить(строка);
		КонецЦикла;
		
	КонецЕсли;
	
	Возврат таблицаЗначений
	
КонецФункции

Функция КонтактныйТелефонФизЛицаПолучить(физЛицо, представлениеОтсутствующейИнформации = "", минимальнаяДлинаНомера = 4, получитьТолькоПервый = Ложь) Экспорт
	
	Перем контактныйТелефон, телефоны, контактнаяИнформация, строкаКонтактнойИнформации;
	
	контактныйТелефон = "";
	
	контактнаяИнформация = ПрочитатьНаборЗаписейКонтактнойИнформации(физЛицо);
	телефоны = контактнаяИнформация.НайтиСтроки(Новый Структура("Тип", Перечисления.ТипыКонтактнойИнформации.Телефон));
	
	Для Каждого строкаКонтактнойИнформации из телефоны цикл
		
		Если СтрДлина(СокрЛП(строкаКонтактнойИнформации.Представление)) <= минимальнаяДлинаНомера Тогда Продолжить конецЕсли;
		
		Если получитьТолькоПервый Тогда
			Возврат строкаКонтактнойИнформации.Представление
		КонецЕсли;
		
		контактныйТелефон =
			?(ПустаяСтрока(контактныйТелефон),
			строкаКонтактнойИнформации.Представление,
			контактныйТелефон + "; " + СокрЛП(строкаКонтактнойИнформации.Представление));
			
	КонецЦикла;
	
	Возврат
		?(ПустаяСтрока(контактныйТелефон),
		представлениеОтсутствующейИнформации,
		контактныйТелефон)
		
КонецФункции

Функция АдресЭлектроннойПочтыФизЛицаПолучить(физЛицо, представлениеОтсутствующейИнформации = "") Экспорт
	
	Перем адресЭлектроннойПочты;
	
	адресЭлектроннойПочты = представлениеОтсутствующейИнформации;
	
	Попытка
		адресЭлектроннойПочты = УправлениеКонтактнойИнформацией.ПолучитьEmailИзКонтактнойИнформации(физЛицо);
	Исключение
	КонецПопытки;
	
	Возврат СокрЛП(адресЭлектроннойПочты)
	
КонецФункции

Функция АдресПроживанияФизлицаПолучить(физЛицо, представлениеОтсутствующейИнформации = "") Экспорт
	
	Перем адресПроживания;
	
	адресПроживания = представлениеОтсутствующейИнформации;
	
	Попытка
		адресПроживания = УправлениеКонтактнойИнформацией.ПолучитьАдресИзКонтактнойИнформации(физЛицо);
	Исключение
	КонецПопытки;
	
	Возврат адресПроживания
	
КонецФункции

Функция ПолучитьПервуюЗаписьРегистраКонтактнойИнформации(объект, перечислениеТипыКонтактнойИнформации, справочникВидыКонтактнойИнформации, вВидеПредставления = Истина) Экспорт
	
	Перем структураДанных, структураОтбора;
	
	структураДанных = Новый Структура();
	структураДанных.Вставить("Объект", объект);
	структураДанных.Вставить("Тип", перечислениеТипыКонтактнойИнформации);
	структураДанных.Вставить("Вид", справочникВидыКонтактнойИнформации);
	
	структураОтбора = Новый Структура();
	структураОтбора.Вставить("Объект");
	структураОтбора.Вставить("Тип");
	структураОтбора.Вставить("Вид");
	
	Возврат ПолучитьПервыйНаборЗаписейРегистра(РегистрыСведений.КонтактнаяИнформация, структураДанных, структураОтбора, вВидеПредставления)
	
КонецФункции

Функция ПолучитьПервыйНаборЗаписейРегистра(объектМетаданных, структураДанных, структураОтбора = Неопределено, вВидеПредставления = Истина) Экспорт
	
	Перем регистрЗапись, регистрНаборЗаписей;
	
	регистрНаборЗаписей = РегистрНаборЗаписейПрочитать(объектМетаданных, структураДанных, структураОтбора);
	
	Если регистрНаборЗаписей.Количество() >= 1 Тогда
		регистрЗапись = регистрНаборЗаписей.Получить(0);
	КонецЕсли;
	
	Если вВидеПредставления Тогда
		
		Возврат
			?(регистрЗапись = Неопределено,
			"",
			регистрЗапись.Представление)
			
	Иначе
		
		Возврат регистрЗапись
		
	КонецЕсли
	
КонецФункции

Функция ПодчиненныеПодразделенияПолучить(подразделение) Экспорт
	
	Перем запрос, результатВыполненияЗапроса;
	
	запрос = Новый Запрос;
	
	запрос.Текст = "ВЫБРАТЬ
	               |	Подразделения.Ссылка КАК Ссылка
	               |ИЗ
	               |	Справочник.Подразделения КАК Подразделения
	               |ГДЕ
	               |	Подразделения.Ссылка В ИЕРАРХИИ(&Ссылка)
	               |	И НЕ Подразделения.ПометкаУдаления
	               |
	               |УПОРЯДОЧИТЬ ПО
	               |	Ссылка
	               |АВТОУПОРЯДОЧИВАНИЕ";
	
	запрос.Параметры.Вставить("Ссылка", подразделение);
	
	результатВыполненияЗапроса = запрос.Выполнить();
	
	Возврат
		?(результатВыполненияЗапроса.Пустой(),
		Новый Массив,
		результатВыполненияЗапроса.Выгрузить().ВыгрузитьКолонку("Ссылка"))
		
КонецФункции

Функция ОбъектСтавкиНДСТабличныхЧастейПолучить(Знач объекты, добавлятьНезаполненныеЗначения = Истина) Экспорт
	
	Перем объект, типОбъекта, метаданныеОбъекта, объектМетаданных, ставкиНДС;
	
	Если Тип("Массив") <> ТипЗнч(объекты) Тогда
		объект = объекты;
		объекты = Новый Массив;
	КонецЕсли;
	
	ставкиНДС = Новый Массив;
	типОбъекта = Неопределено;
	
	Для Каждого объект из объекты цикл
		
		Если НЕ ЗначениеЗаполнено(объект) Тогда Продолжить конецЕсли;
		
		Если типОбъекта <> ТипЗнч(объект) Тогда
			метаданныеОбъекта = объект.Метаданные();
		КонецЕсли;
		
		Для Каждого объектМетаданных из метаданныеОбъекта.ТабличныеЧасти цикл
			
			Если объектМетаданных.Реквизиты.Найти("СтавкаНДС") = Неопределено Тогда Продолжить конецЕсли;
			
			Для Каждого ставкаНДС из ТаблицаВыгрузитьСвернутьКолонку(объект[объектМетаданных.Имя], "СтавкаНДС") цикл
				
				Если ставкиНДС.Найти(ставкаНДС) <> Неопределено Тогда Продолжить конецЕсли;
				
				Если НЕ ЗначениеЗаполнено(ставкаНДС) И НЕ добавлятьНезаполненныеЗначения Тогда Продолжить конецЕсли;
				
				ставкиНДС.Добавить(ставкаНДС);
				
			КонецЦикла;
			
		КонецЦикла;
		
	КонецЦикла;
	
	Возврат ставкиНДС
	
КонецФункции

Процедура ДвиженияДокументаУдалить(ссылка) Экспорт
	
	документОбъект = ссылка.ПолучитьОбъект();
	
	Для Каждого движение из документОбъект.Движения цикл
		
		СостояниеОтобразить(СтрШаблон("Удаление движений %1 - %2...", ссылка, движение));
		
		Если движение.Количество() > 0 Тогда
			
			позицияТочки = Найти(Строка(движение), ".");
			регистраВид = Лев(Строка(движение), позицияТочки - 13);
			регистрИмя = СокрП(Сред(Строка(движение), позицияТочки + 1));
			
			Если "РегистрНакопления" = регистраВид Тогда
				
				регистрНаборЗаписей = РегистрыНакопления[регистрИмя].СоздатьНаборЗаписей();
				
			ИначеЕсли "РегистрБухгалтерии" = регистраВид Тогда
				
				регистрНаборЗаписей = РегистрыБухгалтерии[регистрИмя].СоздатьНаборЗаписей();
				
			ИначеЕсли "РегистрСведений" = регистраВид Тогда
				
				регистрНаборЗаписей = РегистрыСведений[регистрИмя].СоздатьНаборЗаписей();
				
			ИначеЕсли "РегистрРасчета" = регистраВид Тогда
				
				регистрНаборЗаписей = РегистрыРасчета[регистрИмя].СоздатьНаборЗаписей();
				
			КонецЕсли;
			
			регистрНаборЗаписей.Отбор.Регистратор.Установить(документОбъект.Ссылка);
			
		Иначе
			
			регистрНаборЗаписей = движение;
			
		КонецЕсли;
		
		Попытка
			регистрНаборЗаписей.Записать();
		Исключение
			Сообщить(ОписаниеОшибки());
		КонецПопытки;
		
	КонецЦикла;
	
КонецПроцедуры

#Область Довідники

Функция ВернутьСсылкуКонтрагента(владелецФормы, структураДанных,
	структураОтбора = Неопределено, текстСообщенияПриОшибке = "",
	запросСозданияНового = Ложь, модифицироватьДанные = Ложь) Экспорт
	
	Перем объектМетаданных, наименованиеТипа, представлениеОбъекта;
	
	объектМетаданных = Справочники.Контрагенты;
	наименованиеТипа = "«Контрагент»";
	представлениеОбъекта = структураДанных.Наименование;
	
	Возврат вернутьСсылкуОбъекта(владелецФормы, объектМетаданных, наименованиеТипа, структураДанных,
		структураОтбора, текстСообщенияПриОшибке, представлениеОбъекта,
		запросСозданияНового, модифицироватьДанные, модифицироватьДанные,, модифицироватьДанные)
		
КонецФункции

Функция ВернутьСсылкуВидДоговораПоГК(владелецФормы, структураДанных,
	структураОтбора = Неопределено, текстСообщенияПриОшибке = "",
	запросСозданияНового = Ложь, модифицироватьДанные = Ложь) Экспорт
	
	Перем объектМетаданных, наименованиеТипа, представлениеОбъекта;
	
	объектМетаданных = Справочники.ВидыДоговоровПоГК;
	наименованиеТипа = "«Виды договоров по ГК»";
	представлениеОбъекта = структураДанных.Наименование;
	
	Возврат вернутьСсылкуОбъекта(владелецФормы, объектМетаданных, наименованиеТипа, структураДанных,
		структураОтбора, текстСообщенияПриОшибке, представлениеОбъекта,
		запросСозданияНового, модифицироватьДанные, модифицироватьДанные,, модифицироватьДанные)
		
КонецФункции

Функция ВернутьСсылкуСхемаНалоговогоУчетаПоДоговорамКонтрагентов(владелецФормы, структураДанных,
	структураОтбора = Неопределено, текстСообщенияПриОшибке = "",
	запросСозданияНового = Ложь, модифицироватьДанные = Ложь) Экспорт
	
	Перем объектМетаданных, наименованиеТипа, представлениеОбъекта;
	
	объектМетаданных = Справочники.СхемыНалоговогоУчетаПоДоговорамКонтрагентов;
	наименованиеТипа = "«Схемы налогового учета по договорам контрагентов»";
	представлениеОбъекта = структураДанных.Наименование;
	
	Возврат вернутьСсылкуОбъекта(владелецФормы, объектМетаданных, наименованиеТипа, структураДанных,
		структураОтбора, текстСообщенияПриОшибке, представлениеОбъекта,
		запросСозданияНового, модифицироватьДанные, модифицироватьДанные,, модифицироватьДанные)
		
КонецФункции

Функция ВернутьСсылкуДоговорКонтрагента(владелецФормы, структураДанных,
	структураОтбора = Неопределено, текстСообщенияПриОшибке = "",
	запросСозданияНового = Ложь, модифицироватьДанные = Ложь) Экспорт
	
	Перем объектМетаданных, наименованиеТипа, представлениеОбъекта;
	
	объектМетаданных = Справочники.ДоговорыКонтрагентов;
	наименованиеТипа = "«Договоры Контрагентов»";
	представлениеОбъекта = структураДанных.Наименование;
	
	Возврат вернутьСсылкуОбъекта(владелецФормы, объектМетаданных, наименованиеТипа, структураДанных,
		структураОтбора, текстСообщенияПриОшибке, представлениеОбъекта,
		запросСозданияНового, модифицироватьДанные, модифицироватьДанные,, модифицироватьДанные)
		
КонецФункции

Функция ВернутьСсылкуКонтактногоЛицаКонтрагента(владелецФормы, структураДанных,
	структураОтбора = Неопределено, текстСообщенияПриОшибке = "",
	запросСозданияНового = Ложь, записать = Истина, заменять = Ложь) Экспорт
	
	Перем объектМетаданных, наименованиеТипа, представлениеОбъекта;
	
	объектМетаданных = Справочники.КонтактныеЛицаКонтрагентов;
	наименованиеТипа = "«Контактное лицо контрагента»";
	представлениеОбъекта = структураДанных.Наименование;
	
	Возврат вернутьСсылкуОбъекта(владелецФормы, объектМетаданных, наименованиеТипа, структураДанных,
		структураОтбора, текстСообщенияПриОшибке, представлениеОбъекта,
		запросСозданияНового, записать, заменять)
		
КонецФункции

Функция ВернутьСсылкуКонтактногоЛица(владелецФормы, структураДанных,
	структураОтбора = Неопределено, текстСообщенияПриОшибке = "",
	запросСозданияНового = Ложь, записать = Истина, заменять = Ложь) Экспорт
	
	Перем объектМетаданных, наименованиеТипа, представлениеОбъекта;
	
	объектМетаданных = Справочники.КонтактныеЛица;
	наименованиеТипа = "«Контактное лицо»";
	представлениеОбъекта = структураДанных.Наименование;
	
	Возврат вернутьСсылкуОбъекта(владелецФормы, объектМетаданных, наименованиеТипа, структураДанных,
		структураОтбора, текстСообщенияПриОшибке, представлениеОбъекта,
		запросСозданияНового, записать, заменять)
		
КонецФункции

Функция ВернутьСсылкаФизЛица(владелецФормы, структураДанных,
	структураОтбора = Неопределено, текстСообщенияПриОшибке = "",
	запросСозданияНового = Ложь, записать = Истина, заменять = Ложь,
	режимДиалогаТолькоПриНеобходимости = Истина, создаватьОбъектыЕслиОтсутствуют = Истина, перемещатьВГруппуЕслиУказана = Ложь) Экспорт
	
	Перем объектМетаданных, наименованиеТипа, представлениеОбъекта, физЛицо;
	
	объектМетаданных = Справочники.ФизическиеЛица;
	наименованиеТипа = "«Физическое лицо»";
	представлениеОбъекта = структураДанных.Наименование;
	
	Если структураДанных.Свойство("ЭтоГруппа") Тогда
		Возврат вернутьСсылкуГруппыОбъектов(объектМетаданных, структураДанных, создаватьОбъектыЕслиОтсутствуют);
	КонецЕсли;
	
	ПроверитьДублиФизЛиц(,
		?(структураДанных.Свойство("ДокументВид") И структураДанных.Свойство("ДокументСерия") И структураДанных.Свойство("ДокументНомер") И структураДанных.Свойство("ДокументДатаВыдачи"),
			Новый Структура("ДокументВид, ДокументСерия, ДокументНомер, ДокументДатаВыдачи",
			структураДанных.ДокументВид,
			структураДанных.ДокументСерия,
			структураДанных.ДокументНомер,
			структураДанных.ДокументДатаВыдачи),
			Неопределено),
		?(структураДанных.Свойство("ИНН"),
			структураДанных.ИНН,
			""),
		?(структураДанных.Свойство("ДРФО"),
			структураДанных.ДРФО,
			""),
		структураДанных.Наименование);
		
	Если структураДанных.Свойство("ИНН") Тогда
		
		физЛицо = ФизЛицоПодборПоИнн(структураДанных.ИНН, заменять);
		
		Если ЗначениеЗаполнено(физЛицо) Тогда
			
			Если создаватьОбъектыЕслиОтсутствуют Тогда
				
				физЛицоОбъект = физЛицо.ПолучитьОбъект();
				
				Если перемещатьВГруппуЕслиУказана Тогда
					ЗаполнитьЗначенияСвойств(физЛицоОбъект, структураДанных,, "ПЕК_НаходитсяВЧерномСписке, ПЕК_ПричинаЗанесенияВЧерныйСписок");
				Иначе
					ЗаполнитьЗначенияСвойств(физЛицоОбъект, структураДанных,, "Родитель, ПЕК_НаходитсяВЧерномСписке, ПЕК_ПричинаЗанесенияВЧерныйСписок");
				КонецЕсли;
				
				Если структураДанных.Свойство("ПЕК_НаходитсяВЧерномСписке") И структураДанных.ПЕК_НаходитсяВЧерномСписке Тогда// тільки додавання у список
					физЛицоОбъект.ПЕК_НаходитсяВЧерномСписке = Истина;
					физЛицоОбъект.ПЕК_ПричинаЗанесенияВЧерныйСписок =
						?(структураДанных.Свойство("ПЕК_ПричинаЗанесенияВЧерныйСписок"),
						структураДанных.ПЕК_ПричинаЗанесенияВЧерныйСписок,
						"");
				КонецЕсли;
				
				Попытка
					физЛицоОбъект.Записать()
				Исключение
				КонецПопытки;
				
			КонецЕсли;
			
			ФИОФизЛицЗаписьРегистраНаличиеПроконтролировать(физЛицо, режимДиалогаТолькоПриНеобходимости, создаватьОбъектыЕслиОтсутствуют);
			
			Возврат физЛицо
			
		КонецЕсли;
		
	КонецЕсли;
	
	физЛицо = вернутьСсылкуОбъекта(владелецФормы, объектМетаданных, наименованиеТипа, структураДанных,
		структураОтбора, текстСообщенияПриОшибке, представлениеОбъекта,
		запросСозданияНового, записать, заменять,
		режимДиалогаТолькоПриНеобходимости, создаватьОбъектыЕслиОтсутствуют);
		
	ФИОФизЛицЗаписьРегистраНаличиеПроконтролировать(физЛицо, режимДиалогаТолькоПриНеобходимости, создаватьОбъектыЕслиОтсутствуют);
	
	Возврат физЛицо
	
КонецФункции

Функция ФИОФизЛицЗаписьРегистраНаличиеПроконтролировать(физЛицо, режимДиалогаТолькоПриНеобходимости, создаватьОбъектыЕслиОтсутствуют) Экспорт
	
	Перем наименованиеТипа;
	Перем естьВалиднаяЗаписьРегистра, регистрЗапись;
	
	Если НЕ ЗначениеЗаполнено(физЛицо) Тогда Возврат Истина конецЕсли;
	
	естьВалиднаяЗаписьРегистра = Ложь;
	
	Для Каждого регистрЗапись из РегистрНаборЗаписейПрочитать(
			РегистрыСведений.ФИОФизЛиц,
			Новый Структура("ФизЛицо", физЛицо),
			Новый Структура("ФизЛицо")) цикл
		Если ПустаяСтрока(регистрЗапись.Фамилия) Тогда Продолжить конецЕсли;
		естьВалиднаяЗаписьРегистра = Истина;
	КонецЦикла;
	
	Если естьВалиднаяЗаписьРегистра Тогда Возврат Истина конецЕсли;
	
	наименованиеТипа = "«Фамилия, имя, отчество физического лица»";
	
	Если НЕ режимДиалогаТолькоПриНеобходимости И НЕ создаватьОбъектыЕслиОтсутствуют Тогда
		#Если Клиент Тогда
		Сообщить(СтрШаблон(
			"%1 - отсутствует запись регистра сведений %2.",
			СокрЛП(физЛицо),
			наименованиеТипа), СтатусСообщения.Важное);
		#КонецЕсли
	КонецЕсли;
	
	Если НЕ создаватьОбъектыЕслиОтсутствуют Тогда Возврат Ложь конецЕсли;
	
	структураФамилияИмяОтчество = ФизлицоФамилияИмяОтчествоСтруктураПолучить(физЛицо);
	
	Возврат РегистрЗаписьПолучить(
		РегистрыСведений.ФИОФизЛиц,
		наименованиеТипа,
		Новый Структура("Период, ФизЛицо, Фамилия, Имя, Отчество",
			НачалоГода(ТекущаяДата()),
			физЛицо,
			структураФамилияИмяОтчество.Фамилия,
			структураФамилияИмяОтчество.Имя,
			структураФамилияИмяОтчество.Отчество),
		Новый Структура("ФизЛицо"),,,,,
		Истина,// замінювати запис, так як він пустий
		Ложь) <> Неопределено
		
КонецФункции

Функция ФизЛицоПодборПоНаименование(наименвоание) Экспорт
	
	Перем запрос, результатВыполненияЗапроса, физЛицо, физЛицоОбъект, текстСообщения;
	
	Если ПустаяСтрока(наименвоание) Тогда Возврат Неопределено конецЕсли;
	
	запрос = Новый Запрос;
	
	запрос.Текст = "ВЫБРАТЬ РАЗРЕШЕННЫЕ ПЕРВЫЕ 1
	               |	ФизическиеЛица.Ссылка КАК ФизЛицо
	               |ИЗ
	               |	Справочник.ФизическиеЛица КАК ФизическиеЛица
	               |ГДЕ
	               |	ФизическиеЛица.Наименование = &Наименование
	               |	И НЕ ФизическиеЛица.ПометкаУдаления
	               |
	               |УПОРЯДОЧИТЬ ПО
	               |	ФизическиеЛица.Код
	               |АВТОУПОРЯДОЧИВАНИЕ";
	
	запрос.Параметры.Вставить("Наименование", наименвоание);
	
	результатВыполненияЗапроса = запрос.Выполнить();
	
	Возврат
		?(результатВыполненияЗапроса.Пустой(),
		Справочники.ФизическиеЛица.ПустаяСсылка(),
		результатВыполненияЗапроса.Выгрузить().Получить(0).ФизЛицо)
		
КонецФункции

Функция ФизЛицоПодборПоИнн(иннСтрокой, сниматьПометкуУдаления) Экспорт
	
	Перем запрос, результатВыполненияЗапроса, физЛицо, физЛицоОбъект, текстСообщения;
	
	Если ПустаяСтрока(иннСтрокой) Тогда Возврат Неопределено конецЕсли;
	
	запрос = Новый Запрос;
	
	запрос.Текст = "ВЫБРАТЬ ПЕРВЫЕ 1
	               |	ФизическиеЛица.Ссылка КАК ФизЛицо,
	               |	ФизическиеЛица.Код КАК Код
	               |ИЗ
	               |	Справочник.ФизическиеЛица КАК ФизическиеЛица
	               |ГДЕ
	               |	ФизическиеЛица.ИНН = &ИНН
	               |	И НЕ ФизическиеЛица.ПометкаУдаления
	               |
	               |УПОРЯДОЧИТЬ ПО
	               |	Код";
	
	запрос.Параметры.Вставить("ИНН", иннСтрокой);
	
	результатВыполненияЗапроса = запрос.Выполнить();
	
	Возврат
		?(результатВыполненияЗапроса.Пустой(),
		Справочники.ФизическиеЛица.ПустаяСсылка(),
		результатВыполненияЗапроса.Выгрузить().Получить(0).ФизЛицо)
	
КонецФункции

// Процедура осуществляет проверку дублей в справочнике ФизическиеЛица
// Проверка происходит по паспортным данным, ИНН, ПФР и ФИО
//
//записьПаспортныхДанных = Новый Структура("ДокументВид, ДокументСерия, ДокументНомер, ДокументДатаВыдачи");
Функция ПроверитьДублиФизЛиц(ссылка = Неопределено, записьПаспортныхДанных = Неопределено, ИНН, ДРФО, ФИО, выдаватьСообщения = Истина) Экспорт
	
	Перем естьДублиПаспортныхДанных, естьДублиИНН, естьДублиДРФО;
	Перем запрос, выборкаИзРезультатаЗапроса, текстСообщения;
	
	естьДублиПаспортныхДанных = Ложь;
	естьДублиИНН = Ложь;
	естьДублиДРФО = Ложь;
	естьДублиФИО = Ложь;
	запрос = Новый Запрос;
	
	// паспортні дані
	Если записьПаспортныхДанных <> Неопределено
		И (ЗначениеЗаполнено(записьПаспортныхДанных.ДокументВид) ИЛИ
		ЗначениеЗаполнено(записьПаспортныхДанных.ДокументСерия) ИЛИ
		ЗначениеЗаполнено(записьПаспортныхДанных.ДокументНомер) ИЛИ
		ЗначениеЗаполнено(записьПаспортныхДанных.ДокументДатаВыдачи)) Тогда
		
		запрос.УстановитьПараметр("ДокументВид", записьПаспортныхДанных.ДокументВид);
		запрос.УстановитьПараметр("ДокументСерия", записьПаспортныхДанных.ДокументСерия);
		запрос.УстановитьПараметр("ДокументНомер", записьПаспортныхДанных.ДокументНомер);
		запрос.УстановитьПараметр("ДокументДатаВыдачи", записьПаспортныхДанных.ДокументДатаВыдачи);
		
		запрос.Текст = "ВЫБРАТЬ РАЗЛИЧНЫЕ
		               |	ПаспортныеДанныеФизЛиц.ФизЛицо КАК ФизЛицо
		               |ИЗ
		               |	РегистрСведений.ПаспортныеДанныеФизЛиц КАК ПаспортныеДанныеФизЛиц
		               |ГДЕ
		               |	ПаспортныеДанныеФизЛиц.ДокументВид = &ДокументВид
		               |	И ПаспортныеДанныеФизЛиц.ДокументСерия = &ДокументСерия
		               |	И ПаспортныеДанныеФизЛиц.ДокументНомер = &ДокументНомер
		               |	И ПаспортныеДанныеФизЛиц.ДокументДатаВыдачи = &ДокументДатаВыдачи";
		Если ЗначениеЗаполнено(ссылка) Тогда
			запрос.УстановитьПараметр("Ссылка", ссылка);
			запрос.Текст = запрос.Текст + "
		               |	И ПаспортныеДанныеФизЛиц.ФизЛицо <> &Ссылка";
		КонецЕсли;
		
		текстСообщения = "Паспортные данные «" + СтруктураПредставлениеПолучить(записьПаспортныхДанных) + "» владеют физические лица:";
		
		Если ЗначениеЗаполнено(ссылка) Тогда
			текстСообщения = текстСообщения + " " + ссылка + ";";
		КонецЕсли;
		
		выборкаИзРезультатаЗапроса = запрос.Выполнить().Выбрать();
		
		Пока выборкаИзРезультатаЗапроса.Следующий() цикл
			естьДублиПаспортныхДанных = Истина;
			текстСообщения = текстСообщения + " " + выборкаИзРезультатаЗапроса.ФизЛицо + ";";
		КонецЦикла;
		
	КонецЕсли;
	
	// ІПН
	Если ЗначениеЗаполнено(ИНН) Тогда
		
		запрос.УстановитьПараметр("ИНН", ИНН);
		
		запрос.Текст = "ВЫБРАТЬ РАЗЛИЧНЫЕ
		               |	ФизическиеЛица.Наименование,
		               |	ФизическиеЛица.Ссылка КАК ФизЛицо
		               |ИЗ
		               |	Справочник.ФизическиеЛица КАК ФизическиеЛица
		               |ГДЕ
		               |	ФизическиеЛица.ИНН = &ИНН";
		Если ЗначениеЗаполнено(ссылка) Тогда
			запрос.УстановитьПараметр("Ссылка", ссылка);
			запрос.Текст = запрос.Текст + "
		               |	ФизическиеЛица.Ссылка <> &Ссылка";
		КонецЕсли;
		
		текстСообщения = "ИНН «" + ИНН + "» владеют физические лица:";
		
		Если ЗначениеЗаполнено(ссылка) Тогда
			текстСообщения = текстСообщения + " " + ссылка + ";";
		КонецЕсли;
		
		выборкаИзРезультатаЗапроса = запрос.Выполнить().Выбрать();
		
		Пока выборкаИзРезультатаЗапроса.Следующий() цикл
			естьДублиИНН = Истина;
			текстСообщения = текстСообщения + " " + выборкаИзРезультатаЗапроса.ФизЛицо + ";";
		КонецЦикла;
		
	КонецЕсли;
	
	// ДРФО
	Если ЗначениеЗаполнено(ДРФО) Тогда
		
		запрос.УстановитьПараметр("ДРФО", ДРФО);
		
		запрос.Текст = "ВЫБРАТЬ РАЗЛИЧНЫЕ
		               |	ФизическиеЛица.Наименование,
		               |	ФизическиеЛица.Ссылка КАК Физлицо
		               |ИЗ
		               |	Справочник.ФизическиеЛица КАК ФизическиеЛица
		               |ГДЕ
		               |	ФизическиеЛица.КодПоДРФО = &ДРФО";
		Если ЗначениеЗаполнено(ссылка) Тогда
			запрос.УстановитьПараметр("Ссылка", ссылка);
			запрос.Текст = запрос.Текст + "
		               |	ФизическиеЛица.Ссылка <> &Ссылка";
		КонецЕсли;
		
		текстСообщения = "ИНН «" + ИНН + "» владеют физические лица:";
		
		Если ЗначениеЗаполнено(ссылка) Тогда
			текстСообщения = текстСообщения + " " + ссылка + ";";
		КонецЕсли;
		
		выборкаИзРезультатаЗапроса = запрос.Выполнить().Выбрать();
		
		Пока выборкаИзРезультатаЗапроса.Следующий() цикл
			естьДублиДРФО = Истина;
			текстСообщения = текстСообщения + " " + выборкаИзРезультатаЗапроса.ФизЛицо + ";";
		КонецЦикла;
		
	КонецЕсли;
	
	// ПІБ
	Если ЗначениеЗаполнено(ФИО)
		И НЕ естьДублиДРФО
		И НЕ естьДублиПаспортныхДанных
		И НЕ естьДублиДРФО Тогда
		
		запрос.УстановитьПараметр("ФИО", СтрЗаменить(ФИО, " ", ""));
		
		запрос.Текст = "ВЫБРАТЬ РАЗЛИЧНЫЕ
		               |	ФИОФизЛиц.ФизЛицо
		               |ИЗ
		               |	РегистрСведений.ФИОФизЛиц КАК ФИОФизЛиц
		               |ГДЕ
		               |	ФИОФизЛиц.Фамилия + ФИОФизЛиц.Имя + ФИОФизЛиц.Отчество = &ФИО";
		Если ЗначениеЗаполнено(ссылка) Тогда
			запрос.УстановитьПараметр("Ссылка", ссылка);
			запрос.Текст = запрос.Текст + "
		               |	ФИОФизЛиц.ФизЛицо <> &Ссылка";
		КонецЕсли;
		
		текстСообщения = "ФИО «" + ФИО + "» владеют физические лица:";
		
		Если ЗначениеЗаполнено(ссылка) Тогда
			текстСообщения = текстСообщения + " " + ссылка + ";";
		КонецЕсли;
		
		выборкаИзРезультатаЗапроса = запрос.Выполнить().Выбрать();
		
		Пока выборкаИзРезультатаЗапроса.Следующий() цикл
			естьДублиФИО = Истина;
			текстСообщения = текстСообщения + " " + выборкаИзРезультатаЗапроса.ФизЛицо + ";";
		КонецЦикла;
		
	КонецЕсли;
	
	Возврат
		НЕ естьДублиПаспортныхДанных
		И НЕ естьДублиИНН
		И НЕ естьДублиДРФО
		И НЕ естьДублиФИО
		
КонецФункции

Функция ВернутьСсылкаСотрудникаОрганизации(владелецФормы, структураДанных,
	структураОтбора = Неопределено, текстСообщенияПриОшибке = "",
	запросСозданияНового = Ложь, записать = Истина, заменять = Ложь,
	режимДиалогаТолькоПриНеобходимости = Истина, создаватьОбъектыЕслиОтсутствуют = Истина, перемещатьВГруппуЕслиУказана = Ложь) Экспорт
	
	Перем объектМетаданных, наименованиеТипа, представлениеОбъекта;
	
	объектМетаданных = Справочники.СотрудникиОрганизаций;
	наименованиеТипа = "«Сотрудник организации»";
	представлениеОбъекта = структураДанных.Наименование;
	
	Если структураДанных.Свойство("ЭтоГруппа") Тогда
		Возврат вернутьСсылкуГруппыОбъектов(объектМетаданных, структураДанных, создаватьОбъектыЕслиОтсутствуют);
	КонецЕсли;
	
	// в типовій конфігурації табельний номер присвоюється новим на формі елемента
	//Если создаватьОбъектыЕслиОтсутствуют И НЕ структураДанных.Свойство("Код") Тогда
	//	структураДанных.Вставить("Код", объектМетаданных.СоздатьЭлемент().ПолучитьОчереднойТабельныйНомер());
	//КонецЕсли;
	
	Возврат вернутьСсылкуОбъекта(владелецФормы, объектМетаданных, наименованиеТипа, структураДанных,
		структураОтбора, текстСообщенияПриОшибке, представлениеОбъекта,
		запросСозданияНового, записать, заменять,
		режимДиалогаТолькоПриНеобходимости, создаватьОбъектыЕслиОтсутствуют, перемещатьВГруппуЕслиУказана)
		
КонецФункции

Функция ВернутьСсылкуИнформационнойКарты(владелецФормы, структураДанных,
	структураОтбора = Неопределено, текстСообщенияПриОшибке = "",
	запросСозданияНового = Ложь, записать = Истина, заменять = Ложь) Экспорт
	
	Перем объектМетаданных, наименованиеТипа, объектСсылка, текстСообщения;
	Перем режимДиалогаТолькоПринеобходимости, представлениеОбъекта;
	
	режимДиалогаТолькоПринеобходимости = Истина;
	
	объектМетаданных = Справочники.ИнформационныеКарты;
	наименованиеТипа = "«Информационная карта»";
	представлениеОбъекта = структураДанных.Наименование;
	
	объектСсылка = вернутьСсылкуОбъекта(владелецФормы, объектМетаданных, наименованиеТипа, структураДанных,
		структураОтбора, текстСообщенияПриОшибке, представлениеОбъекта,
		запросСозданияНового, записать, заменять, режимДиалогаТолькоПринеобходимости);
		
	Если объектСсылка = Неопределено Тогда Возврат Неопределено конецЕсли;
	
	Если структураДанных.ВладелецКарты <> объектСсылка.ВладелецКарты Тогда
		СообщениеОтобразить(НСтр("ru='Владельцем типа '; uk='Власником типа '") + наименованиеТипа + НСтр("ru=' является «'; uk=' є «'") +
			объектСсылка.ВладелецКарты.Наименование + "» (" + Строка(объектСсылка.ВладелецКарты.Код) + ")." + Символы.ПС +
			НСтр("ru='Требуемый владелец: «'; uk='Потрібний власник: «'") +
			структураДанных.ВладелецКарты.Наименование + "» (" + Строка(структураДанных.ВладелецКарты.Код) + ").", СтатусСообщения.Внимание);
	КонецЕсли;
	
	Если структураДанных.ВидКарты = Перечисления.ВидыИнформационныхКарт.Штриховая
		И ЗначениеЗаполнено(объектСсылка.Ссылка) Тогда
		
		структураДанных.Вставить("Владелец", объектСсылка.Ссылка);
		структураДанных.Вставить("Штрихкод", Формат(Число(структураДанных.КодКарты), "ЧГ="));
		
		текстСообщения = НСтр("ru='Отсутствуют необходимые данные объекта'; uk=""Відсутні необхідні дані об'єкта""") + " типа " + наименованиеТипа;
		
		результат = ШтрихкодЗаписатьВРегистр(владелецФормы, структураДанных,
			"", Ложь, записать, заменять);
			
		Если НЕ результат Тогда
			СообщениеОтобразить(текстСообщения, СтатусСообщения.Внимание);
		КонецЕсли;
		
	КонецЕсли;
	
	Возврат объектСсылка
	
КонецФункции

Функция ВернутьСсылкуСклад(владелецФормы, структураДанных,
	структураОтбора = Неопределено, текстСообщенияПриОшибке = "",
	запросСозданияНового = Ложь, записать = Истина, заменять = Ложь) Экспорт
	
	Перем новыйОбъект, ответ, текстСообщения;
	Перем объектСсылка, объектМетаданных, наименованиеТипа, представлениеОбъекта;
	
	объектМетаданных = Справочники.Склады;
	наименованиеТипа = "«Склад»";
	представлениеОбъекта = структураДанных.Наименование;
	
	Возврат вернутьСсылкуОбъекта(владелецФормы, объектМетаданных, наименованиеТипа, структураДанных,
		структураОтбора, текстСообщенияПриОшибке, представлениеОбъекта,
		запросСозданияНового, записать, заменять)
		
КонецФункции

Функция ВернутьСсылкуВидНоменклатуры(владелецФормы, структураДанных,
	структураОтбора = Неопределено, текстСообщенияПриОшибке = "",
	запросСозданияНового = Ложь, записать = Истина, заменять = Ложь) Экспорт
	
	Перем новыйОбъект, ответ, текстСообщения;
	Перем объектСсылка, объектМетаданных, наименованиеТипа, представлениеОбъекта;
	
	объектМетаданных = Справочники.ВидыНоменклатуры;
	наименованиеТипа = "«Вид номенклатуры»";
	представлениеОбъекта = структураДанных.Наименование;
	
	Возврат вернутьСсылкуОбъекта(владелецФормы, объектМетаданных, наименованиеТипа, структураДанных,
		структураОтбора, текстСообщенияПриОшибке, представлениеОбъекта,
		запросСозданияНового, записать, заменять)
		
КонецФункции

Функция ВернутьСсылкуБанки(владелецФормы, структураДанных,
	структураОтбора = Неопределено, текстСообщенияПриОшибке = "",
	запросСозданияНового = Ложь, модифицироватьДанные = Ложь) Экспорт
	
	Перем объектМетаданных, наименованиеТипа, представлениеОбъекта;
	
	объектМетаданных = Справочники.Банки;
	наименованиеТипа = "«Банки»";
	представлениеОбъекта = структураДанных.Наименование;
	
	Возврат вернутьСсылкуОбъекта(владелецФормы, объектМетаданных, наименованиеТипа, структураДанных,
		структураОтбора, текстСообщенияПриОшибке, представлениеОбъекта,
		запросСозданияНового, модифицироватьДанные, модифицироватьДанные,, модифицироватьДанные)
		
КонецФункции

Функция ВернутьСсылкуБанковскийСчет(владелецФормы, структураДанных,
	структураОтбора = Неопределено, текстСообщенияПриОшибке = "",
	запросСозданияНового = Ложь, модифицироватьДанные = Ложь) Экспорт
	
	Перем объектМетаданных, наименованиеТипа, представлениеОбъекта;
	
	объектМетаданных = Справочники.БанковскиеСчета;
	наименованиеТипа = "«Банковский счет»";
	
	Если НЕ структураДанных.Свойство("ВидСчета") Тогда
		структураДанных.Вставить("ВидСчета", "Расчетный");
	КонецЕсли;
	
	Если НЕ структураДанных.Свойство("Наименование") Тогда
		структураДанных.Вставить("Наименование", СтрШаблон("%1 @ %2 (%3)", структураДанных.НомерСчета, структураДанных.Банк, структураДанных.ВалютаДенежныхСредств));
	КонецЕсли;
	
	представлениеОбъекта = структураДанных.Наименование;
	
	Возврат вернутьСсылкуОбъекта(владелецФормы, объектМетаданных, наименованиеТипа, структураДанных,
		структураОтбора, текстСообщенияПриОшибке, представлениеОбъекта,
		запросСозданияНового, модифицироватьДанные, модифицироватьДанные,, модифицироватьДанные)
		
КонецФункции

#КонецОбласти

#Область РегістриВідомостей

Функция РегистрНакопленияСоздатьСтруктуруТаблицыПоРеквизитах(имяРегистра) Экспорт
	
	Перем таблицаЗначений, объектМетаданных, элемент;
	
	таблицаЗначений = Новый ТаблицаЗначений;
	объектМетаданных = Метаданные.РегистрыНакопления[имяРегистра];
	
	Для Каждого элемент из объектМетаданных.СтандартныеРеквизиты цикл
		таблицаЗначений.Колонки.Добавить(элемент.Имя,, элемент.Синоним);
	КонецЦикла;
	
	Для Каждого элемент из объектМетаданных.Измерения цикл
		таблицаЗначений.Колонки.Добавить(элемент.Имя,, элемент.Синоним);
	КонецЦикла;
	
	Для Каждого элемент из объектМетаданных.Ресурсы цикл
		таблицаЗначений.Колонки.Добавить(элемент.Имя,, элемент.Синоним);
	КонецЦикла;
	
	Для Каждого элемент из объектМетаданных.Реквизиты цикл
		таблицаЗначений.Колонки.Добавить(элемент.Имя,, элемент.Синоним);
	КонецЦикла;
	
	Возврат таблицаЗначений
	
КонецФункции

Функция РегистрНакопленияСоздатьСтруктуруПоРеквизитах(имяРегистра) Экспорт
	
	Перем структура, объектМетаданных, элемент;
	
	структура = Новый ТаблицаЗначений;
	объектМетаданных = Метаданные.РегистрыНакопления[имяРегистра];
	
	Для Каждого элемент из объектМетаданных.СтандартныеРеквизиты цикл
		структура.Вставить(элемент.Имя);
	КонецЦикла;
	
	Для Каждого элемент из объектМетаданных.Измерения цикл
		структура.Вставить(элемент.Имя);
	КонецЦикла;
	
	Для Каждого элемент из объектМетаданных.Ресурсы цикл
		структура.Вставить(элемент.Имя);
	КонецЦикла;
	
	Возврат структура
	
КонецФункции

Функция РегистрСведенийСоздатьСтруктуруТаблицыПоРеквизитах(имяРегистра) Экспорт
	
	Перем таблицаЗначений, объектМетаданных, элемент;
	
	таблицаЗначений = Новый ТаблицаЗначений;
	объектМетаданных = Метаданные.РегистрыСведений[имяРегистра];
	
	Для Каждого элемент из объектМетаданных.СтандартныеРеквизиты цикл
		таблицаЗначений.Колонки.Добавить(элемент.Имя,, элемент.Синоним);
	КонецЦикла;
	
	Для Каждого элемент из объектМетаданных.Измерения цикл
		таблицаЗначений.Колонки.Добавить(элемент.Имя,, элемент.Синоним);
	КонецЦикла;
	
	Для Каждого элемент из объектМетаданных.Ресурсы цикл
		таблицаЗначений.Колонки.Добавить(элемент.Имя,, элемент.Синоним);
	КонецЦикла;
	
	Для Каждого элемент из объектМетаданных.Реквизиты цикл
		таблицаЗначений.Колонки.Добавить(элемент.Имя,, элемент.Синоним);
	КонецЦикла;
	
	Возврат таблицаЗначений
	
КонецФункции

Функция РегистрСведенийСоздатьСтруктуруПоРеквизитах(имяРегистра, включитьРеквизиты = Ложь) Экспорт
	
	Перем структура, объектМетаданных, элемент;
	
	структура = Новый Структура;
	объектМетаданных = Метаданные.РегистрыСведений[имяРегистра];
	
	Для Каждого элемент из объектМетаданных.СтандартныеРеквизиты цикл
		структура.Вставить(элемент.Имя);
	КонецЦикла;
	
	Для Каждого элемент из объектМетаданных.Измерения цикл
		структура.Вставить(элемент.Имя);
	КонецЦикла;
	
	Для Каждого элемент из объектМетаданных.Ресурсы цикл
		структура.Вставить(элемент.Имя);
	КонецЦикла;
	
	Для Каждого элемент из объектМетаданных.Реквизиты цикл
		структура.Вставить(элемент.Имя);
	КонецЦикла;
	
	Возврат структура
	
КонецФункции

Функция РегистрЗаписьПолучить(объектМетаданных, наименованиеТипа, структураДанных,
	структураОтбора = Неопределено, текстСообщенияПриОшибке = "", представлениеОбъекта = "",
	запросСозданияНового = Ложь, записать = Истина, заменять = Ложь, необходимостьСуществованиеТолькоОднойЗаписи = Истина) Экспорт
	
	Перем регистрЗапись, регистрНаборЗаписей, текстСообщения;
	Перем форма, ответ, регистрСведенийВыборка;
	Перем символПробелаОсновной;
	
	символПробелаОсновной = Символ(32);
	
	// Перевірка заповненості даних, необхідних для ідентифікації об`єкта
	текстСообщения = НСтр("ru = 'Отсутствуют необходимые данные регистра '; uk = 'Відсутні необхідні дані регістра '") + наименованиеТипа;
	
	Если НЕ проверитьЗаполнениеОбязательныхРеквизитовОбъекта(наименованиеТипа, структураДанных, текстСообщения) Тогда Возврат Неопределено конецЕсли;
	
	регистрНаборЗаписей = РегистрНаборЗаписейПрочитать(объектМетаданных, структураДанных, структураОтбора);
	
	Если регистрНаборЗаписей.Количество() = 0 Тогда
		
		// Створення нового, якщо не знайдено
		Если НЕ получитьПодтверждениеПользователяОСозданияНовогоОбъектаВИнформационнойБазе(запросСозданияНового, наименованиеТипа, представлениеОбъекта, заменять) Тогда Возврат Неопределено конецЕсли;
		
		регистрЗапись = регистрНаборЗаписей.Добавить();
		
	ИначеЕсли регистрНаборЗаписей.Количество() = 1 ИЛИ НЕ необходимостьСуществованиеТолькоОднойЗаписи Тогда
		
		регистрЗапись = регистрНаборЗаписей.Получить(0);
		
		Если НЕ заменять Тогда Возврат регистрЗапись конецЕсли;
		
	ИначеЕсли регистрНаборЗаписей.Количество() > 1 Тогда
		
		#Если Клиент Тогда
		
		текстСообщения = НСтр("ru = 'По заданому отбору в информационной базе обнаружено несколько записей регистра '; uk = 'По заданому відбору в інформаційній базі знадено декілька записів регістра '") + наименованиеТипа + ".";
		
		//Сообщить(текстСообщения, СтатусСообщения.Внимание);
		
		Если НЕ ВопросПолучитьПодтверждение(
			текстСообщения + Символы.ПС +
			НСтр("ru='Подтвержаете удаление записей ('; uk='Підтверджуєте видаленя записів ('") + Строка(регистрНаборЗаписей.Количество()) +
			НСтр("ru=') перед созданием новой?'; uk=') перед створенням нового?'"), Ложь) Тогда
			
			// Надати користувачу форму із наявними записами
			форма = регистрНаборЗаписей.ПолучитьФорму("ФормаСписка");
			
			формаУстановитьОтборДляВыбора(форма, структураДанных, структураОтбора);
			
			//Предупреждение(НСтр("ru = ''"));
			
			форма.ОткрытьМодально();
			
			Возврат Неопределено
			
		Иначе
			
			регистрНаборЗаписей.Очистить();
			регистрНаборЗаписей.Записать();
			
			Возврат РегистрЗаписьПолучить(объектМетаданных, наименованиеТипа, структураДанных,
				структураОтбора, текстСообщенияПриОшибке, представлениеОбъекта,
				запросСозданияНового, записать, заменять);
				
		КонецЕсли;
		
		#КонецЕсли
		
		Возврат регистрНаборЗаписей
		
	КонецЕсли;
	
	Попытка
		ЗаполнитьЗначенияСвойств(регистрЗапись, структураДанных);
	Исключение
		СообщениеОтобразить(НСтр("ru='Ошибка во время заполнения свойств типа '; uk='Помилка під час заповнення властивостей типу '") + наименованиеТипа, СтатусСообщения.Внимание);
		Если ИнформацияОбОшибке().Причина <> Неопределено Тогда
			СообщениеОтобразить(ИнформацияОбОшибке().Причина.Описание, СтатусСообщения.Информация);
		КонецЕсли;
	КонецПопытки;
	
	Если записать Тогда
		ответ = ОбъектЗаписатьПолучитьСсылку(регистрНаборЗаписей, структураДанных, текстСообщенияПриОшибке,
			запросСозданияНового, Истина);
	КонецЕсли;
	
	Возврат регистрЗапись
	
КонецФункции

Функция ШтрихкодЗаписатьВРегистр(владелецФормы, структураДанных,
	текстСообщенияПриОшибке = "",
	запросСозданияНового = Ложь, записать = Истина, заменять = Ложь) Экспорт
	
	Перем объектМетаданных, наименованиеТипа, структураОтбора, результат;
	Перем регистрСведенийЗапись, регистрНаборЗаписей, регистрСведенийВыборка, форма, элементОтбора, ответ;
	
	объектМетаданных = РегистрыСведений.Штрихкоды;
	наименованиеТипа = "«Штрихкод»";
	
	структураОтбора = Новый Структура();
	структураОтбора.Вставить("Владелец", Ложь);
	структураОтбора.Вставить("Штрихкод");
	
	результат = РегистрЗаписьПолучить(объектМетаданных, наименованиеТипа, структураДанных,
		структураОтбора, текстСообщенияПриОшибке,
		запросСозданияНового, записать, заменять);
		
	Если результат = Неопределено
		ИЛИ "РегистрСведенийНаборЗаписей" = Лев(Строка(результат), Найти(Строка(результат), ".") - 1) Тогда
		
		результат = Ложь;
		
	ИначеЕсли "РегистрСведенийЗапись" = Лев(Строка(результат), Найти(Строка(результат), ".") - 1) Тогда
		
		регистрСведенийЗапись = результат;
		
		Если регистрСведенийЗапись.Владелец = структураДанных.Владелец Тогда
			
			Возврат Истина
			
		Иначе
			
			#Если Клиент Тогда
			
			Сообщить(НСтр("ru='Владельцем типа '; uk='Власником типа '") + наименованиеТипа + НСтр("ru=' является «';uk=' є «'") +
				регистрСведенийЗапись.Владелец.Наименование + "» (" + Строка(регистрСведенийЗапись.Владелец.Код) + ")." + Символы.ПС +
				НСтр("ru='Требуемый владелец: «'; uk='Потрібний власник: «'") +
				структураДанных.Владелец.Наименование + "» (" + Строка(структураДанных.Владелец.Код) + ").", СтатусСообщения.Внимание);
				
			Если заменять Тогда
				
				ответ = Вопрос(
					НСтр("ru='Изменить владельца?'; uk='Змінити власника?'"),
					РежимДиалогаВопрос.ДаНет, 15, КодВозвратаДиалога.Нет, "Внимание", КодВозвратаДиалога.Нет);
				
				Если ответ = КодВозвратаДиалога.Да Тогда
					структураДанных.Владелец = структураДанных.ВладелецКарты.Ссылка;
				КонецЕсли;
				
			КонецЕсли;
			
			#КонецЕсли
			
		КонецЕсли;
		
		результат = РегистрЗаписьПолучить(объектМетаданных, наименованиеТипа, структураДанных,
			структураОтбора, текстСообщенияПриОшибке,
			запросСозданияНового, записать, заменять);
			
		Если результат = Неопределено
			ИЛИ "РегистрСведенийНаборЗаписей" = Лев(Строка(результат), Найти(Строка(результат), ".") - 1) Тогда
			результат = Ложь;
		ИначеЕсли "РегистрСведенийЗапись" = Лев(Строка(результат), Найти(Строка(результат), ".") - 1) Тогда
			результат = Истина;
		КонецЕсли;
		
	КонецЕсли;
	
	Возврат результат
	
КонецФункции

Функция ПаспортныеДанныеФизлицаПолучить(физЛицо) Экспорт
	
	Перем возвращаемоеЗначение, запрос, результатВыполненияЗапроса;
	
	возвращаемоеЗначение = РегистрСведенийСоздатьСтруктуруПоРеквизитах("ПаспортныеДанныеФизЛиц", Истина);
	
	запрос = Новый Запрос;
	
	запрос.Текст = "ВЫБРАТЬ ПЕРВЫЕ 1
	               |	ПаспортныеДанныеФизЛиц.Период,
	               |	ПаспортныеДанныеФизЛиц.ФизЛицо,
	               |	ПаспортныеДанныеФизЛиц.ДокументВид,
	               |	ПаспортныеДанныеФизЛиц.ДокументСерия,
	               |	ПаспортныеДанныеФизЛиц.ДокументНомер,
	               |	ПаспортныеДанныеФизЛиц.ДокументДатаВыдачи,
	               |	ПаспортныеДанныеФизЛиц.ДокументКемВыдан
	               |ИЗ
	               |	РегистрСведений.ПаспортныеДанныеФизЛиц КАК ПаспортныеДанныеФизЛиц
	               |ГДЕ
	               |	ПаспортныеДанныеФизЛиц.ФизЛицо = &ФизЛицо";
	
	запрос.Параметры.Вставить("ФизЛицо", физЛицо);
	
	результатВыполненияЗапроса = запрос.Выполнить();
	
	Возврат
		?(результатВыполненияЗапроса.Пустой(),
		возвращаемоеЗначение,
		результатВыполненияЗапроса.Выгрузить().Получить(0))
		
КонецФункции

Функция ПаспортныеДанныеФизлицаЗаписатьВРегистр(структураДанных,
	текстСообщенияПриОшибке = "",
	запросСозданияНового = Ложь, записать = Истина, заменять = Ложь) Экспорт
	
	Перем объектМетаданных, наименованиеТипа, представлениеОбъекта, структураОтбора, результат;
	
	объектМетаданных = РегистрыСведений.ПаспортныеДанныеФизЛиц;
	наименованиеТипа = "«Паспортные данные физических лиц»";
	
	представлениеОбъекта = СтрШаблон(
		"%1 %2 Виданий %3 %4 р.",
		структураДанных.ДокументВид.Наименование,
		?(ПустаяСтрока(структураДанных.ДокументСерия),
			СтрШаблон("№ %1", структураДанных.ДокументНомер),
			СтрШаблон("Серія %1 № %2", структураДанных.ДокументСерия, структураДанных.ДокументНомер)),
		структураДанных.ДокументКемВыдан,
		Формат(структураДанных.ДокументДатаВыдачи, "Л=uk_UA; ДФ=dd.MM.yyyy"));
		
	структураОтбора = Новый Структура("ФизЛицо, Период");
	
	Если НЕ структураДанных.Свойство("Период") Тогда
		структураДанных.Вставить("Период", структураДанных.ДокументДатаВыдачи);
	КонецЕсли;
	
	результат = РегистрЗаписьПолучить(объектМетаданных, наименованиеТипа, структураДанных,
		структураОтбора, текстСообщенияПриОшибке, представлениеОбъекта,
		запросСозданияНового, записать, заменять);
		
	Если результат = Неопределено
		ИЛИ "РегистрСведенийНаборЗаписей" = Лев(Строка(результат), Найти(Строка(результат), ".") - 1) Тогда
		результат = Ложь;
	ИначеЕсли "РегистрСведенийЗапись" = Лев(Строка(результат), Найти(Строка(результат), ".") - 1) Тогда
		результат = Истина;
	КонецЕсли;
	
	Возврат результат
	
КонецФункции

//e_ОбщегоНазначения.КонтактнаяИнформацияЗаписатьВРегистр(Новый Структура("Объект, Тип, Вид, Представление", строка.Физлицо, Перечисления.ТипыКонтактнойИнформации.Телефон, Справочники.ВидыКонтактнойИнформации.ТелефонФизЛицаДомашний, строка.КонтактнаяИнформацияТелефон));
Функция КонтактнаяИнформацияЗаписатьВРегистр(структураДанных,
	текстСообщенияПриОшибке = "",
	запросСозданияНового = Ложь, записать = Истина, заменять = Ложь) Экспорт
	
	Перем объектМетаданных, наименованиеТипа, структураОтбора, результат;
	
	Если ПустаяСтрока(структураДанных.Представление) Тогда Возврат Истина конецЕсли;
	
	объектМетаданных = РегистрыСведений.КонтактнаяИнформация;
	наименованиеТипа = "«Контактная информация»";
	
	структураОтбора = Новый Структура("Объект, Тип, Вид");
	
	результат = РегистрЗаписьПолучить(объектМетаданных, наименованиеТипа, структураДанных,
		структураОтбора, текстСообщенияПриОшибке, структураДанных.Представление,
		запросСозданияНового, записать, заменять);
		
	Если результат = Неопределено
		ИЛИ Тип("РегистрСведенийНаборЗаписей.КонтактнаяИнформация") = ТипЗнч(результат) Тогда
		результат = Ложь;
	ИначеЕсли Тип("РегистрСведенийЗапись.КонтактнаяИнформация") = ТипЗнч(результат) Тогда
		результат = Истина;
	КонецЕсли;
	
	Возврат результат
	
КонецФункции

Функция РегистрНаборЗаписейПрочитать(объектМетаданных, структураДанных, структураОтбора) Экспорт
	
	Перем регистрНаборЗаписей;
	
	регистрНаборЗаписей = объектМетаданных.СоздатьНаборЗаписей();
	
	регистрУстановитьОтбор(регистрНаборЗаписей, структураДанных, структураОтбора);
	
	регистрНаборЗаписей.Прочитать();
	
	Возврат регистрНаборЗаписей
	
КонецФункции

#КонецОбласти

#Область Документи

Функция ВернутьСсылкаДоговорНаВыполнениеРаботСФизЛицом(владелецФормы, структураДанных,
	структураОтбора = Неопределено, текстСообщенияПриОшибке = "",
	запросСозданияНового = Ложь, записать = Истина, заменять = Ложь,
	режимДиалогаТолькоПриНеобходимости = Истина, создаватьОбъектыЕслиОтсутствуют = Истина) Экспорт
	
	Перем объектМетаданных, наименованиеТипа, представлениеОбъекта;
	
	объектМетаданных = Документы.ДоговорНаВыполнениеРаботСФизЛицом;
	наименованиеТипа = "«Договор ГПХ»";
	представлениеОбъекта = наименованиеТипа + структураДанных.Физлицо;
	
	Возврат вернутьСсылкуОбъекта(владелецФормы, объектМетаданных, наименованиеТипа, структураДанных,
		структураОтбора, текстСообщенияПриОшибке, представлениеОбъекта,
		запросСозданияНового, записать, заменять,
		режимДиалогаТолькоПриНеобходимости, создаватьОбъектыЕслиОтсутствуют)
		
КонецФункции

#КонецОбласти

#КонецОбласти


#Область ОбєктиCOM

Функция WordCOMШаблонДокументаЗаполнитьПараметры(полноеИмяФайлаШаблона, структураДанных, диалогСПользователем = Ложь, пустоеЗначение = " ") Экспорт
	
	Перем wordCOM, documentWordCOM, структураЗаполняемыхПараметров, индекс, параКлючИЗначение, имяПараметраПолноеИмяФайла, полноеИмяФайла, возвращаемоеЗначение;
	
	Если НЕ ФайлПроверитьСуществуетНаСервере(полноеИмяФайлаШаблона, диалогСПользователем) Тогда Возврат Ложь конецЕсли;
	
	имяПараметраПолноеИмяФайла = "ПолноеИмяФайла";
	
	Если Тип("Структура") = ТипЗнч(структураДанных) Тогда
		структураЗаполняемыхПараметров = Новый Массив;
		структураЗаполняемыхПараметров.Добавить(структураДанных);
	Иначе
		структураЗаполняемыхПараметров = структураДанных;
	КонецЕсли;
	
	Попытка // COM
		
		СостояниеОтобразить(НСтр("ru='Подключение к Microsoft Office Word...'; uk='Підключення до Microsoft Office Word...'"));
		wordCOM = Новый COMОбъект("Word.Application");
		
		wordCOM.Application.Visible = Ложь;
		wordCOM.Application.DisplayAlerts = Ложь;
		
		Для Каждого структураЗаполняемыхПолей из структураЗаполняемыхПараметров цикл
			
			Если НЕ структураЗаполняемыхПолей.Свойство(имяПараметраПолноеИмяФайла) Тогда Продолжить конецЕсли;
			
			полноеИмяФайла = структураЗаполняемыхПолей[имяПараметраПолноеИмяФайла];
			возможностьЗаписи = ФайлВозможностьЗаписиПроверить(полноеИмяФайла, диалогСПользователем, диалогСПользователем);
			
			Если НЕ возможностьЗаписи Тогда
				
				Если диалогСПользователем Тогда Продолжить конецЕсли;
				
				СообщениеОтобразить("Во время заполнения шаблона документа возникли ошибки", СтатусСообщения.Важное);
				Возврат Ложь
				
			КонецЕсли;
			
			Попытка // ActiveDocument
				
				СостояниеОтобразить(НСтр("ru='Заполнение шаблона документа Word: '; uk='Заповення шаблона документа Word: '") + полноеИмяФайла + "...");
				wordCOM.Documents.Add(полноеИмяФайлаШаблона);
				documentWordCOM = wordCOM.ActiveDocument;
				
				Для Каждого параКлючИЗначение из структураЗаполняемыхПолей цикл
					
					#Если Клиент Тогда
					ОбработкаПрерыванияПользователя();
					#КонецЕсли
					
					Если параКлючИЗначение.Ключ = имяПараметраПолноеИмяФайла Тогда Продолжить конецЕсли;
					
					Попытка // Bookmarks.Select
						documentWordCOM.Bookmarks(параКлючИЗначение.Ключ).Select();
					Исключение
						СообщениеОтобразить(параКлючИЗначение.Ключ + " - закладка не найдена в шаблоне документа " + полноеИмяФайла, СтатусСообщения.Важное, Ложь);
						Продолжить
					КонецПопытки; // Bookmarks.Select
					
					Попытка // Selection.TypeText
						documentWordCOM.Application.Selection.TypeText(
							?(ЗначениеЗаполнено(параКлючИЗначение.Значение),
							параКлючИЗначение.Значение,
							пустоеЗначение));
					Исключение
						documentWordCOM.Application.Selection.TypeText(
							?(НЕ ПустаяСтрока(Строка(параКлючИЗначение.Значение)),
							Строка(параКлючИЗначение.Значение),
							пустоеЗначение));
					КонецПопытки; // Selection.TypeText
					
				КонецЦикла;
				
				Попытка // SaveAs
					
					СостояниеОтобразить(НСтр("ru='Сохранение заполненного шаблона документа Word: '; uk='Сохранение заполненного шаблона документа Word: '") + полноеИмяФайла + "...");
					documentWordCOM.SaveAs(полноеИмяФайла);
					
				Исключение
					
					ОтобразитьСообщениеОбОшибке(ОписаниеОшибки(), ИнформацияОбОшибке());
					
					структураЗаполняемыхПолей[имяПараметраПолноеИмяФайла] = "";
					
					Если НЕ диалогСПользователем Тогда Возврат Ложь конецЕсли;
					
				КонецПопытки; // SaveAs
				
			Исключение
				
				СообщениеОтобразить(НСтр("ru='Не удается создать документ Microsoft Office Word: '; uk='Не вдається створити документ Microsoft Office Word: '") + полноеИмяФайлаШаблона, СтатусСообщения.Важное, Ложь);
				ОтобразитьСообщениеОбОшибке(ОписаниеОшибки(), ИнформацияОбОшибке());
				структураЗаполняемыхПолей[имяПараметраПолноеИмяФайла] = "";
				
				WordCOMЗакрыть(wordCOM);
				Возврат Ложь
				
			КонецПопытки; // ActiveDocument
			
		КонецЦикла;
		
		WordCOMЗакрыть(wordCOM);
		Возврат Истина
		
	Исключение
		
		СообщениеОтобразить(НСтр("ru='Не удается открыть Microsoft Office Word.'; uk='Не вдається відкрити Microsoft Office Word.'"), СтатусСообщения.Важное, Ложь);
		ОтобразитьСообщениеОбОшибке(ОписаниеОшибки(), ИнформацияОбОшибке());
		
		WordCOMЗакрыть(wordCOM);
		Возврат Ложь
		
	КонецПопытки; // COM
	
КонецФункции

Функция ExcelCOMШаблонКнигиЗаполнитьПараметры(полноеИмяФайлаШаблона, структураДанных, диалогСПользователем = Ложь, пустоеЗначение = " ") Экспорт
	
	Перем excelCOM, книгаExcel, листExcel, структураЗаполняемыхПараметров, структураУстановкиЯчеек;
	Перем имяПараметраПолноеИмяФайла, имяПараметраНомерЛиста, имяПараметраУстановкиЯчеек, полноеИмяФайла, номерЛиста;
	
	excelCOM = ExcelCOMКнигаПолучить(полноеИмяФайлаШаблона,, диалогСПользователем);
	
	Если excelCOM = Неопределено Тогда Возврат Ложь конецЕсли;
	
	имяПараметраПолноеИмяФайла = "ПолноеИмяФайла";
	имяПараметраНомерЛиста = "НомерЛиста";
	имяПараметраУстановкиЯчеек = "УстановкиЯчеек";
	имяПараметраНомерСтроки = "НомерСтроки";
	имяПараметраНомерКолонки = "НомерКолонки";
	имяПараметраЗначениеВЯчейке = "ЗначениеВЯчейке";
	
	Если Тип("Структура") = ТипЗнч(структураДанных) Тогда
		структураЗаполняемыхПараметров = Новый Массив;
		структураЗаполняемыхПараметров.Добавить(структураДанных);
	Иначе
		структураЗаполняемыхПараметров = структураДанных;
	КонецЕсли;
	
	Попытка // COM
		
		Для Каждого структураЗаполняемыхПолей из структураЗаполняемыхПараметров цикл
			
			Если НЕ структураЗаполняемыхПолей.Свойство(имяПараметраПолноеИмяФайла)
				ИЛИ НЕ структураЗаполняемыхПолей.Свойство(имяПараметраНомерЛиста)
				ИЛИ НЕ структураЗаполняемыхПолей.Свойство(имяПараметраУстановкиЯчеек) Тогда
				Продолжить
			КонецЕсли;
			
			полноеИмяФайла = структураЗаполняемыхПолей[имяПараметраПолноеИмяФайла];
			номерЛиста = структураЗаполняемыхПолей[имяПараметраНомерЛиста];
			
			Если НЕ ФайлВозможностьЗаписиПроверить(полноеИмяФайла, диалогСПользователем, диалогСПользователем) Тогда Продолжить конецЕсли;
			
			Попытка // WorkSheets
				
				СостояниеОтобразить(НСтр("ru='Заполнение шаблона книги Excel: '; uk='Заповнення шаблона книги Excel: '") + полноеИмяФайлаШаблона + "...");
				
				Если книгаExcel = Неопределено Тогда
					книгаExcel = excelCOM.WorkBooks.Open(полноеИмяФайлаШаблона);
				КонецЕсли;
				
				Если листExcel = Неопределено Тогда
					листExcel = книгаExcel.WorkSheets(номерЛиста);
				КонецЕсли;
				
				#Область ЗаповненняДаних
				
				Для Каждого структураУстановкиЯчеек из структураЗаполняемыхПолей[имяПараметраУстановкиЯчеек] цикл
				
					#Если Клиент Тогда
					ОбработкаПрерыванияПользователя();
					#КонецЕсли
					
					Попытка // Cells.Value
						листExcel.Cells(
							структураУстановкиЯчеек[имяПараметраНомерСтроки],
							структураУстановкиЯчеек[имяПараметраНомерКолонки]
							).Value =
								?(ЗначениеЗаполнено(структураУстановкиЯчеек[имяПараметраЗначениеВЯчейке]),
								структураУстановкиЯчеек[имяПараметраЗначениеВЯчейке],
								пустоеЗначение);
					Исключение
						листExcel.Cells(
							структураУстановкиЯчеек[имяПараметраНомерСтроки],
							структураУстановкиЯчеек[имяПараметраНомерКолонки]
							).Value =
								?(НЕ ПустаяСтрока(Строка(структураУстановкиЯчеек[имяПараметраЗначениеВЯчейке])),
								Строка(структураУстановкиЯчеек[имяПараметраЗначениеВЯчейке]),
								пустоеЗначение);
					КонецПопытки; // Cells.Value
					
				КонецЦикла;
				
				#КонецОбласти
				
			Исключение
				
				СообщениеОтобразить(НСтр("ru='Ошибка во время заполнения в шаблоне книги Excel листа №'; uk='Помилка під час заповнення в шаблоні книги Excel листа №'") + номерЛиста, СтатусСообщения.Важное, Ложь);
				структураЗаполняемыхПолей[имяПараметраПолноеИмяФайла] = "";
				
			КонецПопытки; // WorkSheets
			
			Если НЕ ExcelКнигаСохранить(excelCOM, книгаExcel, полноеИмяФайла, диалогСПользователем, Ложь) Тогда
				структураЗаполняемыхПолей[имяПараметраПолноеИмяФайла] = "";
			КонецЕсли;
			
		КонецЦикла;
		
		Если книгаExcel <> Неопределено Тогда
			excelCOM.WorkBooks.Close();
			книгаExcel = Неопределено;
		КонецЕсли;
		
		ExcelCOMЗакрыть(excelCOM);
		
		Возврат Истина
		
	Исключение
		
		СообщениеОтобразить(НСтр("ru='Не удается открыть Microsoft Office Excel.'; uk='Не вдається відкрити Microsoft Office Excel.'"), СтатусСообщения.Важное, Ложь);
		ОтобразитьСообщениеОбОшибке(ОписаниеОшибки(), ИнформацияОбОшибке());
		
		ExcelCOMЗакрыть(excelCOM);
		
		Возврат Ложь
		
	КонецПопытки; // COM
	
КонецФункции

Функция ExcelCOMКнигаПолучить(полноеИмяФайла, номерЛиста = Неопределено, диалогСПользователем = Ложь, видимостьПриложения = Ложь) Экспорт
	
	Перем excelCOM;
	
	Если НЕ ФайлПроверитьСуществуетНаСервере(полноеИмяФайла, диалогСПользователем) Тогда Возврат Неопределено конецЕсли;
	
	Попытка // COM
		
		СостояниеОтобразить(НСтр("ru='Подключение к Microsoft Office Excel...'; uk='Підключення до Microsoft Office Excel...'"));
		excelCOM = Новый COMОбъект("Excel.Application");
		
		Попытка // WorkBooks.Open
			
			СостояниеОтобразить(НСтр("ru='Открытие книги Excel: '; uk='Відкриття книги Excel: '") + полноеИмяФайла + "...");
			excelCOM.Visible =
				?(видимостьПриложения,
				1,
				0);
			excelCOM.WorkBooks.Open(полноеИмяФайла);// имя не может совпадать со встроенным именем
			
			Если НЕ ЗначениеЗаполнено(номерЛиста) Тогда Возврат excelCOM конецЕсли;
			
			Попытка // Sheets.Select
				excelCOM.Sheets(номерЛиста).Select();
			Исключение
				СообщениеОтобразить(НСтр("ru='Ошибка во время открытия в книге Excel листа №'; uk='Помилка під час відкриття в книзі Excel листа №'") + номерЛиста, СтатусСообщения.Важное);
				excelCOM.ActiveWorkbook.Close();
				excelCOM.Application.Quit();
				Возврат Неопределено
			КонецПопытки // Sheets.Select
			
		Исключение
			
			СообщениеОтобразить(НСтр("ru='Не удается открыть книгу Microsoft Office Excel: '; uk='Не вдається відкрити книгу Microsoft Office Ecxel: '") + полноеИмяФайла, СтатусСообщения.Важное);
			ОтобразитьСообщениеОбОшибке(ОписаниеОшибки(), ИнформацияОбОшибке());
			
			excelCOM.Application.Quit();
			
			Возврат Неопределено
			
		КонецПопытки; // WorkBooks.Open
		
		Возврат excelCOM
		
	Исключение
		
		СообщениеОтобразить(НСтр("ru='Не удается открыть Microsoft Office Excel.'; uk='Не вдається відкрити Microsoft Office Ecxel.'"), СтатусСообщения.Важное);
		
		Если НЕ excelCOM = Неопределено Тогда
			excelCOM.Application.Quit();
		КонецЕсли;
		
		Возврат Неопределено
		
	КонецПопытки; // COM
	
КонецФункции

Функция ExcelКнигаСохранить(excelCOM, книгаExcel, полноеИмяФайла, запросНаСохранение = Ложь, закрывать = Истина) Экспорт
	
	Перем сохранениеУспешно;
	
	excelCOM.Workbooks.Application.DisplayAlerts = запросНаСохранение;
	
	Попытка
		
		книгаExcel.SaveAs(полноеИмяФайла);
		сохранениеУспешно = Истина;
		
	Исключение
		
		сохранениеУспешно = Ложь;
		
		Если ИнформацияОбОшибке().Причина = Неопределено Тогда
			ExcelCOMЗакрыть(excelCOM);
			ВызватьИсключение
		Иначе
			СообщениеОтобразить(ИнформацияОбОшибке().Причина.Описание, СтатусСообщения.Важное);
		КонецЕсли;
		
	КонецПопытки;
	
	Если закрывать Тогда
		ExcelCOMЗакрыть(excelCOM);
	КонецЕсли;
	
	Возврат сохранениеУспешно
	
КонецФункции

Процедура WordCOMЗакрыть(wordCOM) Экспорт
	
	СостояниеОтобразить(НСтр("ru='Закрытие приложения Microsof Office Word...'; uk='Закриття додатка Microsoft Office Word...'"));
	
	Если wordCOM = Неопределено Тогда Возврат конецЕсли;
	
	wordCOM.Application.Quit();
	
	wordCOM = Неопределено;
	
КонецПроцедуры

Процедура ExcelCOMЗакрыть(excelCOM) Экспорт
	
	СостояниеОтобразить(НСтр("ru='Закрытие приложения Microsof Office Excel...'; uk='Закриття додатка Microsoft Office Excel...'"));
	
	Если excelCOM = Неопределено Тогда Возврат конецЕсли;
	
	excelCOM.Application.Quit();
	
	excelCOM = Неопределено;
	
КонецПроцедуры

Функция XMLПроверитьВозможностьЧтения(имяФайла) Экспорт
	
	Перем файл, файлВФорматеFastInfoSet, чтениеXML;
	
	Если СтрДлина(имяФайла) = 0 Тогда
		#Если Клиент Тогда
		Предупреждение("Не задано имя файла выгрузки");
		#КонецЕсли
		Возврат Неопределено
	КонецЕсли;
	
	файл = Новый Файл(имяФайла);
	
	Если НЕ файл.Существует() Тогда
		#Если Клиент Тогда
		Предупреждение("Не найден файл для загрузки данных: " + имяФайла);
		#КонецЕсли
		Возврат Неопределено
	КонецЕсли;
	
	файлВФорматеFastInfoSet = (файл.Расширение = ".fi");
	
	чтениеXML =
		?(файлВФорматеFastInfoSet,
		Новый ЧтениеFastInfoset,// распаковка файла правил
		Новый ЧтениеXML);
		
	чтениеXML.ОткрытьФайл(имяФайла);
	
	// проверка формата файла обмена
	
	Если
		НЕ чтениеXML.Прочитать()
		ИЛИ чтениеXML.ТипУзла <> ТипУзлаXML.НачалоЭлемента
		ИЛИ чтениеXML.ЛокальноеИмя <> "_1CV8DtUD"
		ИЛИ чтениеXML.URIПространстваИмен <> "http://www.1c.ru/V8/1CV8DtUD/" Тогда
		#Если Клиент Тогда
		Предупреждение("Неверный формат файла выгрузки", 10, "Ошибка загрузки!!!");
		#КонецЕсли
		Возврат Неопределено
	КонецЕсли;
	
	Если
		НЕ чтениеXML.Прочитать()
		ИЛИ чтениеXML.ТипУзла <> ТипУзлаXML.НачалоЭлемента
		ИЛИ чтениеXML.ЛокальноеИмя <> "Data"
		ИЛИ чтениеXML.URIПространстваИмен <> "http://www.1c.ru/V8/1CV8DtUD/" Тогда
		#Если Клиент Тогда
		Предупреждение("Неверный формат файла выгрузки", 10, "Ошибка загрузки!!!");
		#КонецЕсли
		Возврат Неопределено
	КонецЕсли;
	
	// чтение и запись в ИБ записанных в выгрузке объектов
	
	Если Не чтениеXML.Прочитать() Тогда
		#Если Клиент Тогда
		Предупреждение("Неверный формат файла выгрузки", 10, "Ошибка загрузки!!!");
		#КонецЕсли
		Возврат Неопределено
	КонецЕсли;
	
	Возврат чтениеXML
	
КонецФункции

Функция ФайлПолучитьКоличествоСтрок(имяФайла) Экспорт
	
	Перем файл, строкаФайла, количествоСтрок;
	
	Если ПустаяСтрока(имяФайла) Тогда Возврат 0 конецЕсли;
	
	файл = Новый ЧтениеТекста(имяФайла);
	
	строкаФайла = файл.ПрочитатьСтроку();
	
	Если строкаФайла = Неопределено Тогда Возврат 0 конецЕсли;
	
	количествоСтрок = 1;
	
	Пока строкаФайла <> Неопределено цикл
		строкаФайла = файл.ПрочитатьСтроку();
		количествоСтрок = количествоСтрок + 1;
	КонецЦикла;
	
	файл.Закрыть();
	
	Возврат количествоСтрок
	
КонецФункции

Процедура ПриложениеЗапустить(путьКИсполняемомуФайлу, рабочийКаталог = Неопределено) Экспорт
	
	#Если Клиент Тогда
	ЗапуститьПриложение(путьКИсполняемомуФайлу, рабочийКаталог);
	#КонецЕсли
	
КонецПроцедуры

Функция ВнешняяКомпонентаПодключить(идентефикаторОбъекта, путьКИсполняемомуФайлу = Неопределено) Экспорт
	Попытка
		
		ПодключитьВнешнююКомпоненту(идентефикаторОбъекта);
		
		Возврат Истина;
		
	Исключение
		Возврат Ложь;
	КонецПопытки;
КонецФункции

Функция Ожидание(длительностьОжиданияВСекундах, текстСостояния = "", диалогСПользователемНаКлиенте = Истина) Экспорт
	
	Перем wScript;
	
	#Если Клиент Тогда
		
		Если текстСостояния <> Неопределено Тогда
			Состояние(
				?(ПустаяСтрока(текстСостояния),
				СтрШаблон("Ожидание %1 секунд...", длительностьОжиданияВСекундах),
				текстСостояния));
		КонецЕсли;
		
		Если диалогСПользователемНаКлиенте Тогда
			
			Возврат ВопросПолучитьПодтверждение("Прервать?", Ложь, Ложь, "Ожидание")
			
		Иначе
			
			wScript = Новый COMОбъект("WScript.Shell");
			
			Попытка
				
				wScript.Run(СтрШаблон("timeout %1", Формат(1 + длительностьОжиданияВСекундах, "ЧДЦ=0; ЧГ=")), 0, 1);
				
			Исключение
				
				ОтобразитьСообщениеОбОшибке(ОписаниеОшибки(), ИнформацияОбОшибке());
				
			КонецПопытки;
			
		КонецЕсли;
		
	#Иначе
		
		wScript = Новый COMОбъект("WScript.Shell");
		
		Попытка
			
			wScript.Run(СтрШаблон("timeout %1", Формат(1 + длительностьОжиданияВСекундах, "ЧДЦ=0; ЧГ=")), 0, 1);
			
		Исключение
			
			ОтобразитьСообщениеОбОшибке(ОписаниеОшибки(), ИнформацияОбОшибке());
			
		КонецПопытки;
		
	#КонецЕсли
	
КонецФункции

Процедура ОжиданиеПингом(длительностьОжиданияВСекундах, текстСостояния = "") Экспорт
	
	Перем системнаяИнформация;
	
	системнаяИнформация = Новый СистемнаяИнформация();
	
	#Если Клиент Тогда
	Если текстСостояния <> Неопределено Тогда
		Состояние(
			?(ПустаяСтрока(текстСостояния),
			СтрШаблон("Ожидание %1 секунд...", длительностьОжиданияВСекундах),
			текстСостояния));
		КонецЕсли;
	#КонецЕсли
	
	Если ТипПлатформы.Windows_x86 = системнаяИнформация.ТипПлатформы ИЛИ ТипПлатформы.Windows_x86_64 = системнаяИнформация.ТипПлатформы Тогда
		
		ЗапуститьПриложение(СтрШаблон(
			"ping -n %1 127.0.0.1",
			Формат(1 + длительностьОжиданияВСекундах, "ЧДЦ=0; ЧГ=")),, Истина)
			
	Иначе
		
		ЗапуститьПриложение(СтрШаблон(
			"ping -c %1 127.0.0.1",
			Формат(1 + длительностьОжиданияВСекундах, "ЧДЦ=0; ЧГ=")),, Истина)
			
	КонецЕсли;
	
КонецПроцедуры

Функция WSПроксиПопытатьсяПолучить(адресВебСервиса, индексСервиса = 0, индексТочкиПодключения = 0) Экспорт
	
	Перем wsОпределения, wsСервис;
	
	Попытка
		
		wsОпределения = Новый WSОпределения(СтрШаблон("%1?WSDL", адресВебСервиса));
		wsСервис = wsОпределения.Сервисы.Получить(индексСервиса);
		
		Возврат Новый WSПрокси(
			wsОпределения,
			wsСервис.URIПространстваИмен,
			wsСервис.Имя,
			wsСервис.ТочкиПодключения.Получить(индексТочкиПодключения).Имя)
			
	Исключение
		
		ОбщегоНазначения.СообщитьОбОшибке(ОписаниеОшибки());
		
		Возврат Неопределено
		
	КонецПопытки;
	
КонецФункции

Функция WinHttpGET(адрес, соответствиеRequestHeader = Неопределено, структураLoginPassword = Неопределено, текстСостояния = "") Экспорт
	
	Перем winHttpRequest, ответ, элемент;
	
	ответ = Неопределено;
	
	Попытка
		
		// https://msdn.microsoft.com/ru-ru/library/windows/desktop/aa384106(v=vs.85).aspx
		winHttpRequest = Новый COMОбъект("WinHttp.WinHttpRequest.5.1");
		
		winHttpRequest.Open("GET", адрес, 0);// Async - 0
		winHttpRequest.SetTimeouts(0, 60000, 30000, 120000);// ResolveTimeout, ConnectTimeout, SendTimeout, ReceiveTimeout
		
		winHttpRequest.Option(2, "utf-8");// WinHttpRequestOption_URLCodePage
		
		Если структураLoginPassword <> Неопределено
			И структураLoginPassword.Свойство("Login") И структураLoginPassword.Свойство("Password")
			И НЕ ПустаяСтрока(структураLoginPassword.Login) И НЕ ПустаяСтрока(структураLoginPassword.Password) Тогда
			winHttpRequest.SetCredentials(
				структураLoginPassword.Login,
				структураLoginPassword.Password,
				0);//HTTPREQUEST_SETCREDENTIALS_FOR_SERVER = 0 / HTTPREQUEST_SETCREDENTIALS_FOR_PROXY = 1
		КонецЕсли;
		
		//winHttpRequest.SetRequestHeader ("Accept-Language", "ru");
		//winHttpRequest.SetRequestHeader ("Accept-Charset", "Windows-1251");
		//winHttpRequest.SetRequestHeader ("Content-Language", "ru");
		//winHttpRequest.SetRequestHeader ("Content-Charset", "Windows-1251");
		Если соответствиеRequestHeader <> Неопределено Тогда
			Для Каждого элемент из соответствиеRequestHeader цикл
				winHttpRequest.SetRequestHeader(элемент.Ключ, элемент.Значение);
			КонецЦикла;
		КонецЕсли;
		
		СостояниеОтобразить(
			?(ПустаяСтрока(текстСостояния),
			СтрШаблон("Ожидание ответа от сервера «%1»...", адрес),
			текстСостояния));
			
		winHttpRequest.Send();
		
		Если winHttpRequest.Status = 200 Тогда// status indicates that the resource was retrieved
			ответ = winHttpRequest.ResponseText();
		Иначе
			СообщениеОтобразить(СтрШаблон("HTTP %1 %2", winHttpRequest.Status, winHttpRequest.StatusText));
		КонецЕсли;
		
	Исключение
		
		ОтобразитьСообщениеОбОшибке(ОписаниеОшибки(), ИнформацияОбОшибке());
		
	КонецПопытки;
	
	Возврат ответ
	
КонецФункции

Функция WinHttpPOST(строкаPOST, адрес, соответствиеRequestHeader = Неопределено, структураLoginPassword = Неопределено) Экспорт
	
	Перем winHttpRequest, ответ, элемент;
	
	ответ = Неопределено;
	
	Попытка
		
		// https://msdn.microsoft.com/ru-ru/library/windows/desktop/aa384106(v=vs.85).aspx
		winHttpRequest = Новый COMОбъект("WinHttp.WinHttpRequest.5.1");
		
		winHttpRequest.Open("POST", адрес, 0);// Async - 0
		winHttpRequest.SetTimeouts(0, 60000, 30000, 120000);// ResolveTimeout, ConnectTimeout, SendTimeout, ReceiveTimeout
		
		winHttpRequest.Option(2, "utf-8");// WinHttpRequestOption_URLCodePage
		
		Если структураLoginPassword <> Неопределено
			И структураLoginPassword.Свойство("Login") И структураLoginPassword.Свойство("Password") Тогда
			winHttpRequest.SetCredentials(
				структураLoginPassword.Login,
				структураLoginPassword.Password,
				0);//HTTPREQUEST_SETCREDENTIALS_FOR_SERVER = 0 / HTTPREQUEST_SETCREDENTIALS_FOR_PROXY = 1
		КонецЕсли;
		
		//winHttpRequest.SetRequestHeader ("Accept-Language", "ru");
		//winHttpRequest.SetRequestHeader ("Accept-Charset", "Windows-1251");
		//winHttpRequest.SetRequestHeader ("Content-Language", "ru");
		//winHttpRequest.SetRequestHeader ("Content-Charset", "Windows-1251");
		Если соответствиеRequestHeader <> Неопределено Тогда
			Для Каждого элемент из соответствиеRequestHeader цикл
				winHttpRequest.SetRequestHeader(элемент.Ключ, элемент.Значение);
			КонецЦикла;
		КонецЕсли;
		
		СостояниеОтобразить(СтрШаблон("Ожидание ответа от сервера «%1»...", адрес));
		
		winHttpRequest.Send(строкаPOST);
		
		Если winHttpRequest.Status = 200 Тогда
			ответ = winHttpRequest.ResponseText();
		Иначе
			СообщениеОтобразить(СтрШаблон("HTTP %1: %2", winHttpRequest.Status, winHttpRequest.StatusText), СтатусСообщения.Внимание);
		КонецЕсли;
		
	Исключение
		
		СообщениеОтобразить(ОписаниеОшибки());
		
	КонецПопытки;
	
	Возврат ответ
	
КонецФункции

Функция JSONЗаписатьДанные(данные) Экспорт
	
	Перем чтениеJSON, ответ, элемент;
	
	записьJSON = Новый ЗаписьJSON;
	записьJSON.УстановитьСтроку();
	
	ЗаписатьJSON(записьJSON, данные);
	
	Возврат записьJSON.Закрыть()
	
КонецФункции

Функция JSONПрочитатьСтруктуруДанных(строка) Экспорт
	
	Перем чтениеJSON, ответ, элемент;
	
	Если строка = Неопределено ИЛИ строка = Null ИЛИ ПустаяСтрока(строка) Тогда Возврат Неопределено конецЕсли;
	
	чтениеJSON = Новый ЧтениеJSON;
	чтениеJSON.УстановитьСтроку(строка);
	
	Возврат ПрочитатьJSON(чтениеJSON)
	
КонецФункции

Функция ПроверитьВозможностьОтправкиПочты(пользователь = Неопределено) Экспорт
	
	Если Константы.ИспользованиеВстроенногоПочтовогоКлиента.Получить() Тогда
		
		Если пользователь = Неопределено Тогда
			пользователь = ПараметрыСеанса.ТекущийПользователь;
		КонецЕсли;
		
		Если УправлениеЭлектроннойПочтой.ПроверитьУчетныеЗаписиДляОтправкиПисем(пользователь, Истина, Ложь).Количество() > 0 Тогда
			Возврат Истина
		Иначе
			СообщениеОтобразить("Отсутствуют установленные для пользователя учетные записи электронной почты");
			Возврат Ложь
		КонецЕсли;
		
	Иначе
		
		#Если Клиент Тогда
		Попытка
			почта = Новый Почта;
			почта.Подключиться();
			почта.Отключиться();
			Возврат Истина
		Исключение
			ОтобразитьСообщениеОбОшибке(ОписаниеОшибки(), ИнформацияОбОшибке());
			Возврат Ложь
		КонецПопытки;
		#КонецЕсли
		
	КонецЕсли;
	
КонецФункции

#КонецОбласти


#Область ФайловаСистема

Функция СимволРазделителяПутиДляПлатформыПолучить() Экспорт
	
	Перем системнаяИнформация;
	
	системнаяИнформация = Новый СистемнаяИнформация;
	
	Возврат
		?(ТипПлатформы.Linux_x86 = системнаяИнформация.ТипПлатформы ИЛИ ТипПлатформы.Linux_x86_64 = системнаяИнформация.ТипПлатформы,
		"/",
		"\")
		
КонецФункции

Функция ПапкаДляСохраненияФайловПользователяОпределить(вызыватьИсключение = Ложь) Экспорт
	
	Перем путьКПапке, символРазделителя;
	
	символРазделителя = "\";
	путьКПапке = НастройкаТекущегоПользователяОсновнойКаталогФайловПолучить();
	
	Если НЕ ЗначениеЗаполнено(путьКПапке) Тогда
		путьКПапке = СистемнаяПапкаПолучить(, вызыватьИсключение);
	КонецЕсли;
	
	Если НЕ Прав(путьКПапке, 1) = символРазделителя Тогда
		путьКПапке = путьКПапке + символРазделителя;
	КонецЕсли;
	
	Возврат путьКПапке
	
КонецФункции

Функция НастройкаТекущегоПользователяОсновнойКаталогФайловПолучить() Экспорт
	
	Возврат УправлениеПользователями.ПолучитьЗначениеПоУмолчанию(ПараметрыСеанса.ТекущийПользователь, "ОсновнойКаталогФайлов")
	
КонецФункции

Функция СистемнаяПапкаПолучить(наименованиеСистемнойПапки = "Desktop", вызыватьИсключение = Ложь) Экспорт
	
	Перем полноеИмяСистемнойПапки, скриптКонтрол;
	
	Попытка
		скриптКонтрол = Новый COMОбъект("WScript.Shell");
		Возврат скриптКонтрол.SpecialFolders().Item("Desktop");
	Исключение
		Если вызыватьИсключение Тогда
			ВызватьИсключениеОтсутствиеРеализации(СтрШаблон("Невозможно получить системную папку %1", наименованиеСистемнойПапки))
		КонецЕсли;
	КонецПопытки;
	
КонецФункции

Функция ФайлПроверитьСуществуетНаСервере(полноеИмяФайла, сообщитьЕслиОтсутствует = Истина) Экспорт
	
	Перем файлСуществует, файл;
	
	файлСуществует = Неопределено;
	
	Если ПустаяСтрока(полноеИмяФайла) Тогда
		СообщениеОтобразить(НСтр("ru = 'Файл не задан!'; uk = 'Файл не вказаний!'"), СтатусСообщения.Внимание);
		Возврат Ложь
	КонецЕсли;
	
	файл = Новый Файл(полноеИмяФайла);
	
	Если файл.Существует() Тогда Возврат Истина конецЕсли;
	
	Если сообщитьЕслиОтсутствует Тогда
		СообщениеОтобразить(СтрШаблон(НСтр("ru = 'Файл отсутствует: %1.'; uk = 'Файл відсутній: %1.'"), полноеИмяФайла), СтатусСообщения.Внимание);
	КонецЕсли;
	
	Возврат Ложь
	
КонецФункции

Функция ФайлФильтрВОкноДиалогаПолучить(типыФайлов = "*") Экспорт
	
	Перем фильтрОбщий;
	
	фильтрОбщий = "";
	
	Для Каждого строка из СтрокаРазбитьНаСоставляющие(типыФайлов) цикл
		
		Если "*" = строка Тогда
			
			фильтрОбщий = СтрШаблон("%1%2%3", фильтрОбщий, ?(НЕ ПустаяСтрока(фильтрОбщий), "|", ""),
				"Все файлы (*.*)|*.*");
				
		ИначеЕсли "xlsx" = строка Тогда
			
			фильтрОбщий = СтрШаблон("%1%2%3", фильтрОбщий, ?(НЕ ПустаяСтрока(фильтрОбщий), "|", ""),
				"Книга Excel (XLSX)|*.xlsx");
				
		ИначеЕсли "xls" = строка Тогда
			
			фильтрОбщий = СтрШаблон("%1%2%3", фильтрОбщий, ?(НЕ ПустаяСтрока(фильтрОбщий), "|", ""),
				"Книга Excel 97-2003(XLS)|*.xls");
				
		ИначеЕсли "xml" = строка Тогда
			
			фильтрОбщий = СтрШаблон("%1%2%3", фильтрОбщий, ?(НЕ ПустаяСтрока(фильтрОбщий), "|", ""),
				"Формат разметки (XML)|*.xml");
				
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат фильтрОбщий
	
КонецФункции

Функция ФайлВыбратьПолучитьПолноеИмя(фильтр = "") Экспорт
	
	#Если Клиент Тогда
	
	полноеИмяФайла = "";
	диалогВыбораФайла = Новый ДиалогВыбораФайла(РежимДиалогаВыбораФайла.Открытие);
	
	диалогВыбораФайла.Заголовок = НСтр("ru = 'Выбор файла'; uk = 'Вибір файла'");
	диалогВыбораФайла.Каталог = НастройкаТекущегоПользователяОсновнойКаталогФайловПолучить();//СистемнаяПапкаПолучить();
	диалогВыбораФайла.ПолноеИмяФайла = полноеИмяФайла;
	
	Если НЕ ПустаяСтрока(фильтр) Тогда
		диалогВыбораФайла.Фильтр = фильтр;//НСтр("ru = 'Все файлы (*.*)|*.*|*.xml|Книга Excel (XLSX)|*.xlsx|Формат разметки (XML)'; uk = 'Всі файли (*.*)|*.*|Книга Excel (XLSX)|*.xls|Формат розмітки (XML)|*.xml'");
	КонецЕсли;
	
	диалогВыбораФайла.ПроверятьСуществованиеФайла = Истина;
	диалогВыбораФайла.МножественныйВыбор = Ложь;
	
	Если диалогВыбораФайла.Выбрать() Тогда
		полноеИмяФайла = диалогВыбораФайла.ПолноеИмяФайла;
	КонецЕсли;
	
	Возврат полноеИмяФайла
	
	#КонецЕсли
	
КонецФункции

Функция КаталогВыбратьПолучитьПолныйПуть(текстЗаголовка = "") Экспорт
	
	#Если Клиент Тогда
	
	Перем диалогВыбораФайла;
	
	диалогВыбораФайла = Новый ДиалогВыбораФайла(РежимДиалогаВыбораФайла.ВыборКаталога);
	
	диалогВыбораФайла.Заголовок =
		?(ПустаяСтрока(текстЗаголовка),
		"Выбор каталога",
		текстЗаголовка);
		
	Возврат
		?(диалогВыбораФайла.Выбрать(),
		диалогВыбораФайла.Каталог,
		"")
		
	#КонецЕсли
	
КонецФункции

//ОбщегоНазначенияКлиентСервер.РазложитьПолноеИмяФайла(полноеИмяФайла)
// <Описание функции>
// Отримання структури параметрів для шляху монтування файла
// Параметры:
//  <полноеИмяФайла>  - <Тип.Строка> - <повний шлях монтування файла>
//  <возвращатьРасширениеСТочкой>  - <Тип.Булево> - <ознака необхідності повертати розширення файла із префіксом у вигляді крапки>
//                 <(опціонально; Хибно - по-замовчуванню)>
//
// Возвращаемое значение:
//   <Тип.Структура>   - <структура параметрів шляху монтування файла>
//                 <ПолноеИмя>
//                 <Имя>
//                 <Путь>
//                 <Расширение>
//                 <ИмяСРасширением>
//                 <СимволРазделителя>
Функция ФайлСтруктураПутиПолучить(полноеИмяФайла, возвращатьРасширениеСТочкой = Ложь) Экспорт
	
	Перем массивЭлементов, имяФайлаСРасширением, расширениеФайла, символРазделителя;
	
	Если ПустаяСтрока(полноеИмяФайла) Тогда Возврат Неопределено конецЕсли;
	
	символРазделителя = "\";
	массивЭлементов = СтрокаРазбитьНаСоставляющие(полноеИмяФайла, символРазделителя);
	имяФайлаСРасширением = массивЭлементов[массивЭлементов.Количество() - 1];
	массивЭлементов = СтрокаРазбитьНаСоставляющие(имяФайлаСРасширением, ".");
	расширениеФайла = массивЭлементов[массивЭлементов.Количество() - 1];
	
	Возврат Новый Структура("ПолноеИмя, Имя, Путь, Расширение, ИмяСРасширением, СимволРазделителя",
		полноеИмяФайла,
		Лев(имяФайлаСРасширением, Найти(имяФайлаСРасширением, ".") - 1),
		Лев(полноеИмяФайла, СтрДлина(полноеИмяФайла) - СтрДлина(имяФайлаСРасширением)),
			?(возвращатьРасширениеСТочкой,
			"." + расширениеФайла,
			расширениеФайла),
		имяФайлаСРасширением,
		символРазделителя)
		
КонецФункции

Функция ФайлИмяПолучитьИзПолныйПуть(полноеИмяФайла, вернутьВместеСРасширением = Ложь) Экспорт
	
	Перем массивЭлементов, имяФайла;
	
	массивЭлементов = СтрокаРазбитьНаСоставляющие(полноеИмяФайла, "\");
	имяФайла = массивЭлементов[массивЭлементов.Количество() - 1];
	
	Возврат
		?(вернутьВместеСРасширением,
		имяФайла,
		Лев(имяФайла, Найти(имяФайла, ".") - 1))
		
КонецФункции

Функция ФайлРасширениеПолучитьИзПолныйПуть(полноеИмяФайла) Экспорт
	
	Перем массивЭлементов, имяФайла, расширениеФайла;
	
	массивЭлементов = СтрокаРазбитьНаСоставляющие(полноеИмяФайла, "\");
	имяФайла = массивЭлементов[массивЭлементов.Количество() - 1];
	массивЭлементов = СтрокаРазбитьНаСоставляющие(имяФайла, ".");
	расширениеФайла = массивЭлементов[массивЭлементов.Количество() - 1];
	
	Возврат расширениеФайла
	
КонецФункции

Функция ФайлРасширениеУбратьТочку(расширениеФайла) Экспорт
	
	Возврат
		?(Найти(расширениеФайла, ".") <> 1,
		расширениеФайла,
		Прав(расширениеФайла, СтрДлина(расширениеФайла) - 1))
		
КонецФункции

Функция ФайлИмяИРасширениеРазделить(имяФайлаСРасширением, символРазделителя = ".") Экспорт
	
	Возврат Новый Структура("ИмяБезРасширения, Расширение",
		Прав(имяФайлаСРасширением, Найти(имяФайлаСРасширением, символРазделителя)),
		Лев(имяФайлаСРасширением, СтрДлина(имяФайлаСРасширением) - СтрДлина(Прав(имяФайлаСРасширением, Найти(имяФайлаСРасширением, символРазделителя)))))
		
КонецФункции

Функция ФайлПереименовать(староеПолноеИмяФайла, новоеПолноеИмяФайла, удалятьКонечнуюПапкуЕслиПустая = Ложь) Экспорт
	
	Если НЕ ФайлВозможностьЗаписиПроверить(новоеПолноеИмяФайла, Ложь) Тогда Возврат Ложь конецЕсли;
	
	Попытка
		ПереместитьФайл(староеПолноеИмяФайла, новоеПолноеИмяФайла);
	Исключение
		ОтобразитьСообщениеОбОшибке(ОписаниеОшибки(), ИнформацияОбОшибке());
	КонецПопытки;
	
	файл = Новый Файл(староеПолноеИмяФайла);
	
	Если НайтиФайлы(файл.Путь, "*.*", Истина).Количество() = 0 Тогда
		Попытка
			УдалитьФайлы(файл.Путь);
		Исключение
			ОтобразитьСообщениеОбОшибке(ОписаниеОшибки(), ИнформацияОбОшибке());
		КонецПопытки;
	КонецЕсли;
	
	Возврат Истина
	
КонецФункции

Функция ФайлСкопировать(полноеИмяФайлаИсточник, полноеИмяФайлаНазначение = "", вопросОПерезаписи = Истина, сообщатьПриОтсутствииФайлаИсточника = Ложь) Экспорт
	
	Перем файл, файлСтруктураПути, папкаДляСохраненияФайловПользователя;
	
	Если НЕ ФайлПроверитьСуществуетНаСервере(полноеИмяФайлаИсточник) Тогда
		
		Если сообщатьПриОтсутствииФайлаИсточника Тогда
			СообщениеОтобразить(полноеИмяФайлаИсточник + НСтр("ru = 'Исходный файл не найден.'; uk = 'Копіювання файла...'"));
		КонецЕсли;
		
		Возврат Ложь
		
	КонецЕсли;
	
	Если НЕ ФайлВозможностьЗаписиПроверить(полноеИмяФайлаНазначение, вопросОПерезаписи) Тогда Возврат Ложь конецЕсли;
	
	СостояниеОтобразить(НСтр("ru = 'Копирование файла...'; uk = 'Копіювання файла...'"));
	
	Если ПустаяСтрока(полноеИмяФайлаНазначение) Тогда
		полноеИмяФайлаНазначение =
			ПапкаДляСохраненияФайловПользователяОпределить(Истина) +
			ФайлСтруктураПутиПолучить(полноеИмяФайлаНазначение).ИмяСРасширением
	КонецЕсли;
	
	Если НЕ полноеИмяФайлаИсточник = полноеИмяФайлаНазначение Тогда
		Попытка
			КопироватьФайл(полноеИмяФайлаИсточник, полноеИмяФайлаНазначение);
		Исключение
			ОтобразитьСообщениеОбОшибке(ОписаниеОшибки(), ИнформацияОбОшибке());
		КонецПопытки;
	КонецЕсли;
	
	файл = Новый Файл(полноеИмяФайлаНазначение);
	
	Возврат файл.Существует()
	
КонецФункции

Функция ФайлСохранить(полноеИмяФайла, вопросОПерезаписи = Истина) Экспорт
	
	#Если Клиент Тогда
	
	ВызватьИсключениеОтсутствиеРеализации();
	
	Если НЕ ФайлВозможностьЗаписиПроверить(полноеИмяФайла, вопросОПерезаписи) Тогда Возврат Ложь конецЕсли;
	
	имяВременногоФайла = ПолучитьИмяВременногоФайла(ФайлРасширениеПолучитьИзПолныйПуть(полноеИмяФайла));
	адресВоВременномХранилище = ПоместитьВоВременноеХранилище(Новый ДвоичныеДанные(имяВременногоФайла));
	
	Возврат ПолучитьФайл(адресВоВременномХранилище)
	
	#КонецЕсли
	
КонецФункции

Функция ФайлВозможностьЗаписиПроверить(полноеИмяФайла, вопросОПерезаписи = Истина, отображатьПолноеИмяФайлаВоВремяЗапросаОПерезаписи = Истина) Экспорт
	
	файл = Новый Файл(полноеИмяФайла);
	
	Если файл.Существует() Тогда
		
		Если вопросОПерезаписи
			И НЕ ВопросПолучитьПодтверждение(
				?(отображатьПолноеИмяФайлаВоВремяЗапросаОПерезаписи,
					полноеИмяФайла + Символы.ПС,
					"") +
				НСтр("ru = 'Файл существует. Перезаписать?'; uk = 'Файл існує. Перезаписати?'") + Символы.ПС +
				Формат(файл.Размер() / 1024, "ЧДЦ=2") + " kB", Ложь) Тогда
			Возврат Ложь
		КонецЕсли;
		
		Если файл.ПолучитьТолькоЧтение() Тогда
			файл.УстановитьТолькоЧтение(Ложь);
		КонецЕсли;
		
	Иначе
		
		каталог = Новый Файл(файл.Путь);
		
		Если НЕ каталог.Существует() Тогда
			Попытка
				СоздатьКаталог(файл.Путь);
			Исключение
				ОтобразитьСообщениеОбОшибке(ОписаниеОшибки(), ИнформацияОбОшибке());
			КонецПопытки;
		КонецЕсли;
		
	КонецЕсли;
	
	Возврат Истина
	
КонецФункции

Процедура ФайлУдалить(полноеИмяФайла, удалятьКонечнуюПапкуЕслиПустая = Ложь) Экспорт
	
	Перем файл;
	
	Попытка
		
		УдалитьФайлы(полноеИмяФайла);
		
		файл = Новый Файл(полноеИмяФайла);
		
		Если НайтиФайлы(файл.Путь, "*.*", Истина).Количество() = 0 Тогда
			УдалитьФайлы(файл.Путь);
		КонецЕсли;
		
	Исключение
		
		ОтобразитьСообщениеОбОшибке(ОписаниеОшибки(), ИнформацияОбОшибке());
		
	КонецПопытки;
	
КонецПроцедуры

Процедура ФайлыУдалить(полныеИменаФайлов, удалятьКонечнуюПапкуЕслиПустая = Ложь) Экспорт
	
	Перем полноеИмяФайла;
	
	Если полныеИменаФайлов.Количество() = 0 Тогда Возврат конецЕсли;
	
	Для Каждого полноеИмяФайла из полныеИменаФайлов цикл
		ФайлУдалить(полноеИмяФайла, удалятьКонечнуюПапкуЕслиПустая);
	КонецЦикла;
	
КонецПроцедуры

#КонецОбласти


#Область МетодиДляВикористанняВСКД

//использование функций общих модулей конфигурации в выражениях компоновки данных
//процессорКомпоновкиСКД.Инициализировать(макетКомпоновкиСКД,,, ИСТИНА);

Функция ОбъектПоместитьВоВременноеХранилище(объект) Экспорт
	
	Возврат ПоместитьВоВременноеХранилище(объект);
КонецФункции

Функция ОбъектПолучитьИзВременногоХранилища(адрес) Экспорт
	
	Возврат ПолучитьИзВременногоХранилища(адрес);
КонецФункции

#КонецОбласти


#Область МетодиЗвітів

Функция ПолучитьКоллекциюЗначенийРезультатаОтчета(отчет, структураПараметров, структураОтборов, коллекцияВВидеДерева = Ложь, имяВариантаОтчета = "Основной", имяМакетаСКД = "ОсновнаяСхемаКомпоновкиДанных") Экспорт	
	
	схемаКомпоновкиДанных = отчет.ПолучитьМакет(имяМакетаСКД);
	Если схемаКомпоновкиДанных = Неопределено Тогда Возврат Неопределено конецЕсли;
	
	настройкиКомпоновкиДанных = отчет.КомпоновщикНастроек.ПолучитьНастройки();
	
	КомпоновщикПараметрыУстановить(отчет, структураПараметров, Ложь, настройкиКомпоновкиДанных, имяВариантаОтчета);
	КомпоновщикОтборыУстановить(отчет, структураОтборов, Ложь, настройкиКомпоновкиДанных, имяВариантаОтчета);
	
	#Если клиент Тогда
	Состояние(НСтр("ru = 'Формирование данных по отчету «'") + отчет.Метаданные().Синоним + "»...");//схемаКомпоновкиДанных.НаборыДанных.Получить(0).Имя
	#КонецЕсли
	
	компоновщикМакетаКомпоновкиДанных = Новый КомпоновщикМакетаКомпоновкиДанных;
	макетКомпоновки = компоновщикМакетаКомпоновкиДанных.Выполнить(схемаКомпоновкиДанных, настройкиКомпоновкиДанных,,, Тип("ГенераторМакетаКомпоновкиДанныхДляКоллекцииЗначений"));
	
	процессорКомпоновкиДанных = Новый ПроцессорКомпоновкиДанных;
	процессорКомпоновкиДанных.Инициализировать(макетКомпоновки,,, Истина);//Истина - можливість використання функцій спільних модулів (Сервер) у виразах компоновки даних
	
	коллекцияЗначений =
		?(коллекцияВВидеДерева,
		Новый ДеревоЗначений,
		Новый ТаблицаЗначений);
	процессорВыводаРезультатаКомпоновкиДанных = Новый ПроцессорВыводаРезультатаКомпоновкиДанныхВКоллекциюЗначений;
	процессорВыводаРезультатаКомпоновкиДанных.УстановитьОбъект(коллекцияЗначений);
	
	процессорВыводаРезультатаКомпоновкиДанных.ОтображатьПроцентВывода = Истина;
	процессорВыводаРезультатаКомпоновкиДанных.Вывести(процессорКомпоновкиДанных);
	
	Возврат коллекцияЗначений;
КонецФункции

Процедура КомпоновщикПараметрыУстановить(отчет, структураПараметров, пользовательскиеНастройки = Истина, настройкиКомпоновкиДанных = Неопределено, имяВариантаОтчета = "Основной") Экспорт
	
	Перем элемент;
	
	Если НЕ настройкиКомпоновкиДанных = Неопределено Тогда
		отчет.КомпоновщикНастроек.ЗагрузитьНастройки(настройкиКомпоновкиДанных);
	КонецЕсли;
	
	Для Каждого элемент из структураПараметров цикл
		
		КомпоновщикПараметрУстановить(
			отчет,
			элемент.Ключ,
				?(ЗначениеЗаполнено(элемент.Значение),
				элемент.Значение,
				отчет[элемент.Ключ]),
			пользовательскиеНастройки,
			настройкиКомпоновкиДанных,
			имяВариантаОтчета);
			
	КонецЦикла;
	
КонецПроцедуры

Функция КомпоновщикПараметрУстановить(отчет, имяПараметра = Неопределено, значениеПараметра = Неопределено, пользовательскиеНастройки = Истина, настройкиКомпоновкиДанных = Неопределено, имяВариантаОтчета = "Основной") Экспорт
	
	Перем значениеПараметраНастроекКомпоновкиДанных;
	
	Если настройкиКомпоновкиДанных = Неопределено Тогда
		настройкиКомпоновкиДанных = отчет.КомпоновщикНастроек.Настройки;
	КонецЕсли;
	
	Для Каждого значениеПараметраНастроекКомпоновкиДанных из настройкиКомпоновкиДанных.ПараметрыДанных.Элементы цикл
		
		Если НЕ имяПараметра = Неопределено
			И НЕ имяПараметра = Строка(значениеПараметраНастроекКомпоновкиДанных.Параметр) Тогда
			Продолжить
		КонецЕсли;
		
		Если пользовательскиеНастройки Тогда
			значениеПараметраНастроекКомпоновкиДанных = отчет.КомпоновщикНастроек.ПользовательскиеНастройки.Элементы.Найти(значениеПараметраНастроекКомпоновкиДанных.ИдентификаторПользовательскойНастройки);
		КонецЕсли;
		
		Если значениеПараметраНастроекКомпоновкиДанных = Неопределено Тогда Продолжить конецЕсли;
		
		значениеПараметраНастроекКомпоновкиДанных.Значение = значениеПараметра;
		значениеПараметраНастроекКомпоновкиДанных.Использование = ЗначениеЗаполнено(значениеПараметра);
		
		Возврат Истина
	
	КонецЦикла;
	
	Возврат Ложь
	
КонецФункции

// структураОтборов = Новый Массив;
// структураОтборов.Добавить(Новый Структура("Имя, Значение, ВидСравнения, Использование", "Подразделение", подразделенияОрганизации, ВидСравненияКомпоновкиДанных.ВСписке, Истина));
Процедура КомпоновщикОтборыУстановить(отчет, структураОтборов, пользовательскиеНастройки = Истина, настройкиКомпоновкиДанных = Неопределено, имяВариантаОтчета = "Основной") Экспорт
	
	Перем элемент;
	
	Если НЕ настройкиКомпоновкиДанных = Неопределено Тогда
		отчет.КомпоновщикНастроек.ЗагрузитьНастройки(настройкиКомпоновкиДанных);
	КонецЕсли;
	
	Для Каждого элемент из структураОтборов цикл
		
		КомпоновщикОтборУстановить(
			отчет,
			элемент.Имя,
			элемент.Значение,
			элемент.ВидСравнения,
			элемент.Использование,
			пользовательскиеНастройки,
			настройкиКомпоновкиДанных,
			имяВариантаОтчета);
			
	КонецЦикла;
	
КонецПроцедуры

Процедура КомпоновщикОтборУстановить(отчет, имяЭлементаОтбора = Неопределено, значениеОтбора = Неопределено, видСравненияКомпоновки = Неопределено, использование = Истина,
	пользовательскиеНастройки = Истина, настройкиКомпоновкиДанных = Неопределено, имяВариантаОтчета = "Основной") Экспорт
	
	Перем элементОтбораКомпоновкиДанных;
	
	Если настройкиКомпоновкиДанных = Неопределено Тогда
		настройкиКомпоновкиДанных = отчет.КомпоновщикНастроек.Настройки;
	КонецЕсли;
	
	Для Каждого элементОтбораКомпоновкиДанных из настройкиКомпоновкиДанных.Отбор.Элементы цикл
		
		Если
			НЕ имяЭлементаОтбора = Неопределено
			И НЕ имяЭлементаОтбора = Строка(элементОтбораКомпоновкиДанных.ЛевоеЗначение) Тогда
			Продолжить
		КонецЕсли;
		
		Если пользовательскиеНастройки Тогда
			элементОтбораКомпоновкиДанных = отчет.КомпоновщикНастроек.ПользовательскиеНастройки.Элементы.Найти(элементОтбораКомпоновкиДанных.ИдентификаторПользовательскойНастройки);
		КонецЕсли;
		
		Если элементОтбораКомпоновкиДанных = Неопределено Тогда Продолжить конецЕсли;
		
		элементОтбораКомпоновкиДанных.Использование = ЗначениеЗаполнено(значениеОтбора);
		элементОтбораКомпоновкиДанных.ПравоеЗначение = значениеОтбора;
		элементОтбораКомпоновкиДанных.ВидСравнения =
			?(видСравненияКомпоновки = Неопределено,
			ВидСравненияКомпоновкиДанных.Равно,
			видСравненияКомпоновки);
			
		Прервать
		
	КонецЦикла;
	
КонецПроцедуры

Процедура КомпоновщикПараметрыОтборыИспользованиеОтключить(отчет, исключаемыеЭлементы = "", настройкиКомпоновкиДанных = Неопределено, пользовательскиеНастройки = Истина, имяВариантаОтчета = "Основной") Экспорт
	
	Перем элемент;
	
	Если настройкиКомпоновкиДанных = Неопределено Тогда
		настройкиКомпоновкиДанных = отчет.КомпоновщикНастроек.Настройки;
	КонецЕсли;
	
	исключаемыеЭлементы = СтрокаРазбитьНаСоставляющие(исключаемыеЭлементы);
	
	Для Каждого элемент из настройкиКомпоновкиДанных.ПараметрыДанных.Элементы цикл
		
		Если НЕ исключаемыеЭлементы.Найти(Строка(элемент.Параметр)) = Неопределено Тогда Продолжить конецЕсли;
		
		Если пользовательскиеНастройки Тогда
			элемент = отчет.КомпоновщикНастроек.ПользовательскиеНастройки.Элементы.Найти(элемент.ИдентификаторПользовательскойНастройки);
		КонецЕсли;
		
		Если элемент = Неопределено Тогда Продолжить конецЕсли;
		
		элемент.Использование = Ложь;
		
		Прервать
	
	КонецЦикла;
	
	КомпоновщикОтборУстановить(отчет,,,,, пользовательскиеНастройки, настройкиКомпоновкиДанных, имяВариантаОтчета);
	
КонецПроцедуры

Функция КомпоновщикНастройкаУстановить(элементыНастроек, имяПараметра, значениеПараметра, использование = Истина) Экспорт
	
	Перем элемент;
	
	Если элементыНастроек.Количество() = 0 ИЛИ элементыНастроек.Найти(имяПараметра) = Неопределено
		ИЛИ НЕ ЗначениеЗаполнено(значениеПараметра) Тогда
		Возврат Ложь
	КонецЕсли;
	
	Для Каждого элемент из элементыНастроек цикл
		
		Если НЕ Строка(элемент.Параметр) = имяПараметра Тогда Продолжить конецЕсли;
		
		Попытка
			
			элемент.Значение = значениеПараметра;
			элемент.Использование = использование;
			
			Возврат Истина
			
		Исключение
			
			СообщениеОтобразить(НСтр("ru = 'Ошибка во время установки значения параметра «'") + имяПараметра + "».", СтатусСообщения.Внимание, Ложь);
			ОтобразитьСообщениеОбОшибке(ОписаниеОшибки(), ИнформацияОбОшибке());
			
			Возврат Ложь
			
		КонецПопытки;
		
	КонецЦикла;
	
КонецФункции

Процедура вывестиЗаголовокОтчета(отчет, форма, имяОтчета, имяТекущегоВариантаОтчета = "", имяНастройкиВариантаОтчета = "", заголовокДополнение = Неопределено, настройкиКомпоновкиДанных = Неопределено)
	Перем элементыНастроек;
	
	Если НЕ ПустаяСтрока(имяТекущегоВариантаОтчета) Тогда
		форма.Заголовок = имяОтчета + " - " + имяТекущегоВариантаОтчета;
	Иначе
		форма.Заголовок = имяОтчета;
	КонецЕсли;
	
	Если НЕ ПустаяСтрока(имяНастройкиВариантаОтчета) Тогда
		форма.Заголовок = форма.Заголовок + " (" + имяНастройкиВариантаОтчета + ")";
	КонецЕсли;
	
	Если НЕ ПустаяСтрока(заголовокДополнение) Тогда
		форма.Заголовок = форма.Заголовок + заголовокДополнение;
	КонецЕсли;
	
	Если настройкиКомпоновкиДанных = Неопределено Тогда
		настройкиКомпоновкиДанных = ПолучитьНастройкиКомпоновкиДанных(отчет);
		Если настройкиКомпоновкиДанных = Неопределено Тогда Возврат конецЕсли;
	КонецЕсли;
	
	элементыНастроек = настройкиКомпоновкиДанных.ПараметрыВывода.Элементы;
	
	КомпоновщикНастройкаУстановить(элементыНастроек, "Заголовок", форма.Заголовок);
	
	УстановитьПараметрыОтображенияЗаголовка(форма, отчет, настройкиКомпоновкиДанных);
	
КонецПроцедуры

Процедура УстановитьПараметрыОтображенияЗаголовка(форма, отчет, настройкиКомпоновкиДанных = Неопределено) Экспорт
	Перем элемент, элементУправления, элементыНастроек, имяПараметра, использованиеОтбора, типВыводаТекста;
	
	Попытка
		элементУправления = форма.ЭлементыФормы.ДействияФормы.Кнопки.ЗаголовокОтчетаИзменитьОтображение;
		
	Исключение
		#Если Клиент Тогда
		Сообщить(НСтр("ru = 'Неверно задано имя элемента управления, отвечающего за изменение отображения заголовка отчета!'"), СтатусСообщения.Внимание);
		#КонецЕсли
			
		Возврат;
	КонецПопытки;
	
	Если настройкиКомпоновкиДанных = Неопределено Тогда
		настройкиКомпоновкиДанных = ПолучитьНастройкиКомпоновкиДанных(отчет);
		Если настройкиКомпоновкиДанных = Неопределено Тогда Возврат конецЕсли;
	КонецЕсли;
	
	элементыНастроек = настройкиКомпоновкиДанных.ПараметрыВывода.Элементы;
	
	Если элементУправления.Пометка Тогда
		типВыводаТекста = ТипВыводаТекстаКомпоновкиДанных.Выводить;
	Иначе
		типВыводаТекста = ТипВыводаТекстаКомпоновкиДанных.НеВыводить;
	КонецЕсли;
	
	имяПараметра = "ВыводитьЗаголовок";
	КомпоновщикНастройкаУстановить(элементыНастроек, имяПараметра, типВыводаТекста);
	
	Если отчет.КомпоновщикНастроек.Настройки.ПараметрыДанных.Элементы.Количество() > 0 Тогда
		имяПараметра = "ВыводитьПараметрыДанных";
		КомпоновщикНастройкаУстановить(элементыНастроек, имяПараметра, типВыводаТекста);
	КонецЕсли;
	
	использованиеОтбора = Ложь;
	
	Для Каждого элемент из отчет.КомпоновщикНастроек.Настройки.Отбор.Элементы цикл
		Если элемент.Использование Тогда
			использованиеОтбора = Истина;
			
			Прервать;
		КонецЕсли;
	КонецЦикла;
	
	Если использованиеОтбора Тогда
		имяПараметра = "ВыводитьОтбор";
		КомпоновщикНастройкаУстановить(элементыНастроек, имяПараметра, типВыводаТекста);
	КонецЕсли;
	
КонецПроцедуры

Функция ПереформироватьОтчет(отчет, форма, табличныйДокументОтчета, структураПараметров, настройкиОтбора, имяВариантаОтчета, представлениеТекущегоВариантаОтчета, имяНастройкиВариантаОтчета, заголовокОтчета = "", имяМакетаШапки = "") Экспорт
	Перем настройкиКомпоновкиДанных;
	
	СкомпоноватьОтчет(отчет, форма, табличныйДокументОтчета, структураПараметров, имяВариантаОтчета, представлениеТекущегоВариантаОтчета, имяНастройкиВариантаОтчета, заголовокОтчета);
	
	настройкиКомпоновкиДанных = ПолучитьНастройкиКомпоновкиДанных(отчет);
	Если настройкиКомпоновкиДанных = Неопределено Тогда возврат Неопределено конецЕсли;
	
	ЗагрузитьНастройкиОтбораВКомпоновщикНастроек(отчет, настройкиКомпоновкиДанных);
	
	Возврат сформироватьОтчетНаСервере(отчет, форма, табличныйДокументОтчета, структураПараметров, настройкиОтбора, имяВариантаОтчета, представлениеТекущегоВариантаОтчета, имяНастройкиВариантаОтчета, заголовокОтчета, имяМакетаШапки, настройкиКомпоновкиДанных);
КонецФункции

Функция СформироватьОтчет(отчет, форма, табличныйДокументОтчета, структураПараметров, настройкиОтбора, имяВариантаОтчета,представлениеТекущегоВариантаОтчета, имяНастройкиВариантаОтчета, заголовокОтчета = "", имяМакетаШапки = "") Экспорт
	Перем настройкиКомпоновкиДанных;
	
	настройкиКомпоновкиДанных = ПолучитьНастройкиКомпоновкиДанных(отчет, Неопределено);
	
	Возврат сформироватьОтчетНаСервере(отчет, форма, табличныйДокументОтчета, структураПараметров, настройкиОтбора, имяВариантаОтчета, представлениеТекущегоВариантаОтчета, имяНастройкиВариантаОтчета, заголовокОтчета, имяМакетаШапки, настройкиКомпоновкиДанных);
КонецФункции

Функция сформироватьОтчетНаСервере(отчет, форма, табличныйДокументОтчета, структураПараметров, настройкиОтбора, имяВариантаОтчета, представлениеТекущегоВариантаОтчета, имяНастройкиВариантаОтчета, заголовокОтчета, имяМакетаШапки = "", настройкиКомпоновкиДанных = Неопределено)
	Перем данныеРасшифровки;
	Перем схемаКомпоновкиДанных, компоновщикМакетаСКД, макетКомпоновки, процессорКомпоновки, процессорВывода, количествоУровнейГруппировок;
	
	схемаКомпоновкиДанных = СкомпоноватьОтчет(отчет, форма, табличныйДокументОтчета, структураПараметров, имяВариантаОтчета, представлениеТекущегоВариантаОтчета, имяНастройкиВариантаОтчета, заголовокОтчета, "", настройкиКомпоновкиДанных);
	Если схемаКомпоновкиДанных = Неопределено Тогда возврат Неопределено конецЕсли;
	
	Если настройкиКомпоновкиДанных = Неопределено Тогда
		настройкиКомпоновкиДанных = ПолучитьНастройкиКомпоновкиДанных(отчет, схемаКомпоновкиДанных);
		Если настройкиКомпоновкиДанных = Неопределено Тогда возврат Неопределено конецЕсли;
	КонецЕсли;
	
	Если НЕ ПустаяСтрока(имяМакетаШапки) Тогда
		вывестиШапкуОтчетаНаСервере(отчет, имяМакетаШапки, табличныйДокументОтчета);
	КонецЕсли;
	
	данныеРасшифровки = Новый ДанныеРасшифровкиКомпоновкиДанных;
	
	#Если клиент Тогда
	Состояние(НСтр("ru = 'Формирование отчета по набору данных «'") + имяВариантаОтчета + "»...");//схемаКомпоновкиДанных.НаборыДанных.Получить(0).Имя
	#КонецЕсли
	
	компоновщикМакетаСКД = Новый КомпоновщикМакетаКомпоновкиДанных;
	макетКомпоновки = компоновщикМакетаСКД.Выполнить(схемаКомпоновкиДанных, настройкиКомпоновкиДанных, данныеРасшифровки);
	
	процессорКомпоновки = Новый ПроцессорКомпоновкиДанных;
	процессорКомпоновки.Инициализировать(макетКомпоновки,, данныеРасшифровки, Истина);//Истина - можливість використання функцій спільних модулів (Сервер) у виразах компоновки даних
	
	процессорВывода = Новый ПроцессорВыводаРезультатаКомпоновкиДанныхВТабличныйДокумент;
	процессорВывода.УстановитьДокумент(табличныйДокументОтчета);
	процессорВывода.Вывести(процессорКомпоновки, Истина);
	
	количествоУровнейГруппировок = получитьКоличествоГруппировокШапки(настройкиКомпоновкиДанных.Структура);
	
	//вывестиРезультатВТабличнийДокумент(табличныйДокументОтчета, процессорВывода, процессорКомпоновки, настройкиКомпоновкиДанных);
	ТабличныйДокументПоказать(табличныйДокументОтчета, форма.Заголовок);
	табличныйДокументОтчета.ПоказатьУровеньГруппировокСтрок(количествоУровнейГруппировок - 2);
	
	скопироватьНастройкиОтбора(настройкиКомпоновкиДанных, настройкиОтбора);
	
	Возврат данныеРасшифровки;
КонецФункции

Функция СкомпоноватьОтчет(отчет, форма, табличныйДокументОтчета, структураПараметров, имяВариантаОтчета, представлениеТекущегоВариантаОтчета, имяНастройкиВариантаОтчета, заголовокОтчета = "", заголовокДополнение = "", настройкиКомпоновкиДанных = Неопределено) Экспорт
	Перем схемаКомпоновкиДанных;
	
	схемаКомпоновкиДанных = получитьСКД(отчет, имяВариантаОтчета);
	Если схемаКомпоновкиДанных = Неопределено Тогда Возврат Неопределено конецЕсли;
	
	Если настройкиКомпоновкиДанных = Неопределено Тогда
		настройкиКомпоновкиДанных = ПолучитьНастройкиКомпоновкиДанных(отчет, схемаКомпоновкиДанных);
		Если настройкиКомпоновкиДанных = Неопределено Тогда возврат Неопределено конецЕсли;
	КонецЕсли;
	
	КомпоновщикПараметрыУстановить(отчет, структураПараметров, Истина, настройкиКомпоновкиДанных, имяВариантаОтчета);
	
	табличныйДокументОтчета.Очистить();
	
	Если заголовокОтчета = Неопределено Тогда
		заголовокОтчета = отчет.Метаданные().Синоним;
	КонецЕсли;
	
	вывестиЗаголовокОтчета(отчет, форма, заголовокОтчета, представлениеТекущегоВариантаОтчета, имяНастройкиВариантаОтчета, заголовокДополнение, настройкиКомпоновкиДанных);
	
	#Если клиент Тогда
	Состояние(НСтр("ru = 'Для построения отчета нажмите кнопку Сформировать.'"));
	#КонецЕсли

	Возврат схемаКомпоновкиДанных
КонецФункции

Функция получитьСКД(отчет, имяМакетаСКД = "ОсновнаяСхемаКомпоновкиДанных", устанавливаемыйТекстЗапроса = "")
	Перем текстСообщения, схемаКомпоновкиДанных;
	
	текстСообщения = НСтр("ru = 'В отчете отсутствует макет СКД с именем «'") + имяМакетаСКД + "».";
	
	Если ПустаяСтрока(имяМакетаСКД) Тогда возврат Неопределено конецЕсли;
	
	Попытка
		схемаКомпоновкиДанных = отчет.ПолучитьМакет(имяМакетаСКД);
		
		Если Строка(схемаКомпоновкиДанных) <> "СхемаКомпоновкиДанных" Тогда
			#Если Клиент Тогда
			Сообщить(текстСообщения, СтатусСообщения.Информация);
			#КонецЕсли
			схемаКомпоновкиДанных = Неопределено;
		КонецЕсли;
		
	Исключение
	#Если Клиент Тогда
		Сообщить(текстСообщения, СтатусСообщения.Внимание);
	#КонецЕсли
	КонецПопытки;
	
	Если
		НЕ ПустаяСтрока(устанавливаемыйТекстЗапроса)
		И схемаКомпоновкиДанных <> Неопределено
		Тогда
		схемаКомпоновкиДанных.НаборыДанных[имяМакетаСКД].Запрос = устанавливаемыйТекстЗапроса;
	КонецЕсли;
	
	Возврат схемаКомпоновкиДанных;
КонецФункции

Функция ПолучитьТекстЗапросаСКД(отчет, имяМакетаСКД = "ОсновнаяСхемаКомпоновкиДанных", имяНаборДанных = "НаборДанных1") Экспорт
	
	Возврат получитьСКД(отчет, имяМакетаСКД).НаборыДанных[имяНаборДанных].Запрос;
	
КонецФункции

Процедура согласоватьПараметрЗапросаСТекстом(отчет, имяВариантаОтчета, имяПараметра)
	Перем текстЗапроса, строкиЗапроса, счетчик;
	
	текстЗапроса = ПолучитьТекстЗапросаСКД(отчет, имяВариантаОтчета);
	строкиЗапроса = СтрокаРазбитьНаСоставляющие(текстЗапроса, Символ(182));
	Для счетчик = 1 по строкиЗапроса.Количество() цикл
		Если Найти(строкиЗапроса[счетчик - 1], "&" + имяПараметра) = 0
			//И СтрЧислоВхождений(строкиЗапроса[счетчик - 1], "&") = 1
			Тогда Продолжить;
		КонецЕсли;
			
		Если счетчик = строкиЗапроса.Количество() Тогда
			строкиЗапроса.Удалить(счетчик - 1);
		Иначе
			Если ТРег(Лев(СокрЛП(строкиЗапроса[счетчик - 1]), 2)) <> "И " Тогда
				// Видалити И з наступної стрічки тексту запиту і замінити нею поточу
				строкиЗапроса[счетчик] = Лев(строкиЗапроса[счетчик], СтрДлина(строкиЗапроса[счетчик]) - СтрДлина(СокрЛ(строкиЗапроса[счетчик])))
				+ Прав(СокрЛП(строкиЗапроса[счетчик]), СтрДлина(СокрЛП(строкиЗапроса[счетчик])) - 2);
			КонецЕсли;
			строкиЗапроса.Удалить(счетчик - 1);
			счетчик = счетчик + 1;
		КонецЕсли;
	КонецЦикла;

	текстЗапроса = строкиЗапроса[0];
	Для счетчик = 2 по строкиЗапроса.Количество() цикл
		текстЗапроса = текстЗапроса + Символы.ПС + строкиЗапроса[счетчик - 1];
	КонецЦикла;
	
	получитьСКД(отчет, имяВариантаОтчета, текстЗапроса);
	
КонецПроцедуры

Функция ПолучитьНастройкиКомпоновкиДанных(отчет, схемаКомпоновкиДанных = Неопределено) Экспорт
	Перем настройкиКомпоновкиДанных;
	
	Если схемаКомпоновкиДанных = Неопределено Тогда
		настройкиКомпоновкиДанных = отчет.КомпоновщикНастроек.ПолучитьНастройки();
	Иначе
		настройкиКомпоновкиДанных = схемаКомпоновкиДанных.НастройкиПоУмолчанию;
	КонецЕсли;
	
	Если настройкиКомпоновкиДанных.Выбор.Элементы.Количество() = 0 Тогда
		#Если Клиент Тогда
		Сообщить(НСтр("ru = 'В заданой настройке компоновки данных отсутствуют выбранные поля!'"), СтатусСообщения.Внимание);
		#КонецЕсли
			
		настройкиКомпоновкиДанных = Неопределено;
	КонецЕсли;
	
	Возврат настройкиКомпоновкиДанных;
КонецФункции

Процедура скопироватьНастройкиОтбора(настройкиКомпоновкиДанных, настройкиОтбора)
	Перем элемент, новаяСтрока;
	
	настройкиОтбора.Очистить();
	
	Для Каждого элемент из настройкиКомпоновкиДанных.Отбор.Элементы цикл
		новаяСтрока = настройкиОтбора.Добавить();
		ЗаполнитьЗначенияСвойств(новаяСтрока, элемент);
	КонецЦикла;
	
	НастройкиОтбора = настройкиОтбора;
	
КонецПроцедуры

Процедура ЗагрузитьНастройкиОтбораВКомпоновщикНастроек(отчет, настройкиКомпоновкиДанных = Неопределено) Экспорт
	Перем элемент, сохраненныйЭлемент;
	
	Если настройкиКомпоновкиДанных = Неопределено Тогда
		настройкиКомпоновкиДанных = ПолучитьНастройкиКомпоновкиДанных(отчет);
		
		Если настройкиКомпоновкиДанных = Неопределено Тогда Возврат конецЕсли;
	КонецЕсли;
	
	Для Каждого элемент из настройкиКомпоновкиДанных.Отбор.Элементы цикл
		
		Для Каждого сохраненныйЭлемент из отчет.НастройкиОтбора цикл
			
			Если сохраненныйЭлемент.ЛевоеЗначение <> элемент.ЛевоеЗначение Тогда Продолжить конецЕсли;
			
			Попытка
				ЗаполнитьЗначенияСвойств(элемент, сохраненныйЭлемент);
			Исключение
				ОтобразитьСообщениеОбОшибке(ОписаниеОшибки(), ИнформацияОбОшибке());
			КонецПопытки;
			
		КонецЦикла;
		
	КонецЦикла;
	
	Если настройкиКомпоновкиДанных <> Неопределено Тогда
		отчет.КомпоновщикНастроек.ЗагрузитьНастройки(настройкиКомпоновкиДанных);
	КонецЕсли;
	
КонецПроцедуры

Процедура вывестиРезультатВТабличнийДокумент(отчет, табличныйДокументОтчета, схемаКомпоновкиДанных, процессорВывода, процессорКомпоновки, настройкиКомпоновкиДанных = Неопределено)
	Перем таблицаЗафиксирована, фиксацияСверху, настройкиВыводаИтогов, итогиРасположеныВверху, элементРезультата;
	
	Если настройкиКомпоновкиДанных = Неопределено Тогда
		настройкиКомпоновкиДанных = ПолучитьНастройкиКомпоновкиДанных(схемаКомпоновкиДанных);
		
		Если настройкиКомпоновкиДанных = Неопределено Тогда Возврат конецЕсли;
	КонецЕсли;
	
	процессорВывода.НачатьВывод();
	
	таблицаЗафиксирована = Ложь;
	фиксацияСверху = 0;
	
	настройкиВыводаИтогов = настройкиКомпоновкиДанных.ПараметрыВывода.НайтиЗначениеПараметра(Новый ПараметрКомпоновкиДанных("ВертикальноеРасположениеОбщихИтогов"));
	
	итогиРасположеныВверху =
		(настройкиВыводаИтогов.Значение = РасположениеИтоговКомпоновкиДанных.Начало
		ИЛИ настройкиВыводаИтогов.Значение = РасположениеИтоговКомпоновкиДанных.НачалоИКонец)
		И настройкиВыводаИтогов.Использование = Истина;
	
	Пока ИСТИНА цикл
 		#Если Клиент Тогда
		ОбработкаПрерыванияПользователя();
		#КонецЕсли
			
		элементРезультата = процессорКомпоновки.Следующий();
		Если элементРезультата = Неопределено Тогда Прервать
			
		Иначе
			Если НЕ таблицаЗафиксирована
				И элементРезультата.ЗначенияПараметров.Количество() > 0
				И ТипЗнч(отчет.КомпоновщикНастроек.Настройки.Структура[0]) <> Тип("ДиаграммаКомпоновкиДанных") Тогда
				// Фіксація шапки
				таблицаЗафиксирована = Истина;
				фиксацияСверху = табличныйДокументОтчета.ВысотаТаблицы
					+ ?(итогиРасположеныВверху,
					1,
					0);
			КонецЕсли;
			
			процессорВывода.ВывестиЭлемент(элементРезультата);
		КонецЕсли;
	КонецЦикла;
	
	процессорВывода.ЗакончитьВывод();
	
	табличныйДокументОтчета.ФиксацияСверху = фиксацияСверху;
	
КонецПроцедуры

Процедура РедактироватьСКД(отчет, форма, имяВариантаОтчета) Экспорт
#Если Клиент Тогда

	Перем схемаКомпоновкиДанных, конструкторСхемыКомпоновкиДанных;
	
	схемаКомпоновкиДанных = получитьСКД(отчет, имяВариантаОтчета);
	Если схемаКомпоновкиДанных = Неопределено Тогда Возврат конецЕсли;
	
	конструкторСхемыКомпоновкиДанных = Новый КонструкторСхемыКомпоновкиДанных(схемаКомпоновкиДанных);
	конструкторСхемыКомпоновкиДанных.Редактировать(форма);
	
#КонецЕсли
КонецПроцедуры

Процедура вывестиШапкуОтчетаНаСервере(отчет, имяМакета, табличныйДокументОтчета)
	
	Перем текстСообщения, макетТабличногоДокумента, областьЗаголовок;
	
	текстСообщения = НСтр("ru = 'В отчете отсутствует макет табличного документа с именем «'") + имяМакета + "».";
	
	Попытка
		макетТабличногоДокумента = отчет.ПолучитьМакет(имяМакета);
		Если Строка(макетТабличногоДокумента.ТипМакета) <> "ТабличныйДокумент" Тогда
			#Если Клиент Тогда
			Сообщить(текстСообщения, СтатусСообщения.Информация);
			#КонецЕсли
			Возврат
		КонецЕсли;
	Исключение
		#Если Клиент Тогда
		Сообщить(текстСообщения, СтатусСообщения.Внимание);
		#КонецЕсли
		Возврат
	КонецПопытки;
	
	областьЗаголовок = макетТабличногоДокумента.ПолучитьОбласть("Заголовок");
	
	//областьЗаголовок.Параметры.Заголовок = _ЗаголовокОтчета;
	//областьЗаголовок.Параметры.НачалоПериода = объектОтчет.КомпоновщикНастроек.Настройки.ПараметрыДанных.Элементы.Найти("НачалоПериода").Значение;
	//областьЗаголовок.Параметры.КонецПериода = объектОтчет.КомпоновщикНастроек.Настройки.ПараметрыДанных.Элементы.Найти("КонецПериода").Значение;
	
	табличныйДокументОтчета.Вывести(областьЗаголовок);
	
КонецПроцедуры

Функция получитьКоличествоГруппировокШапки(структураКомпоновщика)
	Перем количество, счетчикИтераций, элемент;
	
	количество = 0;
	счетчикИтераций = 0;
	
	Для Каждого элемент из структураКомпоновщика цикл
		счетчикИтераций = счетчикИтераций + 1;
		Если НЕ элемент.Использование Тогда Продолжить конецЕсли;
		
		количество = получитьКоличествоГруппировокШапки(элемент.Структура) + 1;
	КонецЦикла;
	
	Возврат
		?(счетчикИтераций > 1,
		счетчикИтераций + количество,
		количество);
КонецФункции

Процедура ОбработкаРасшифровки(имяВариантаОтчета, расшифровка, данныеРасшифровки, массивИменОбрабатываемыхПолейРасшифровкиДанных, отчет = Неопределено, списокПунктовМенюРасшифровкиДанных = Неопределено) Экспорт
	
	Если
		отчет = Неопределено ИЛИ
		списокПунктовМенюРасшифровкиДанных = Неопределено
		Тогда
		обработкаРасшифровкиСсылочныхТипов(расшифровка, данныеРасшифровки, массивИменОбрабатываемыхПолейРасшифровкиДанных);
	Иначе
		обработкаРасшифровкиРезультата(отчет, имяВариантаОтчета, расшифровка, данныеРасшифровки, массивИменОбрабатываемыхПолейРасшифровкиДанных, списокПунктовМенюРасшифровкиДанных);
	КонецЕсли;
	
КонецПроцедуры

Процедура обработкаРасшифровкиСсылочныхТипов(расшифровка, данныеРасшифровки, массивИменОбрабатываемыхПолей)
	Перем значениеПоляРасшифровки;
	
	значениеПоляРасшифровки = данныеРасшифровки.Элементы[расшифровка].ПолучитьПоля()[0];
	Если массивИменОбрабатываемыхПолей.Найти(значениеПоляРасшифровки.Поле) = Неопределено Тогда Возврат конецЕсли;
	
	#Если Клиент Тогда
	ОткрытьЗначение(значениеПоляРасшифровки.Значение);
	#КонецЕсли
		
КонецПроцедуры

// Обробка додаткових пунктів меню
Процедура обработкаРасшифровкиОткрытьСотрудник(расшифровка, данныеРасшифровки, массивИменОбрабатываемыхПолейРасшифровкиДанных)
	
	обработкаРасшифровкиСсылочныхТипов(массивИменОбрабатываемыхПолейРасшифровкиДанных, расшифровка, данныеРасшифровки);
	
КонецПроцедуры

Процедура обработкаРасшифровкиРезультата(отчет, имяВариантаОтчета, расшифровка, данныеРасшифровки, массивИменОбрабатываемыхПолейРасшифровкиДанных, списокПунктовМенюРасшифровкиДанных)
	Перем схемаКомпоновкиДанных, настройкиКомпоновкиДанных;
	Перем обработкаРасшифровки, значениеПоляРасшифровки, текущийСписокПунктовМенюРасшифровкиДаных, выполненноеДействиеИмя;
	
	схемаКомпоновкиДанных = получитьСКД(отчет, имяВариантаОтчета);
	Если схемаКомпоновкиДанных = Неопределено Тогда Возврат конецЕсли;
	
	обработкаРасшифровки = Новый ОбработкаРасшифровкиКомпоновкиДанных(данныеРасшифровки, Новый ИсточникДоступныхНастроекКомпоновкиДанных(схемаКомпоновкиДанных));
	
	значениеПоляРасшифровки = данныеРасшифровки.Элементы[расшифровка].ПолучитьПоля()[0];
	
	текущийСписокПунктовМенюРасшифровкиДаных = Новый СписокЗначений;
	
	Для Каждого пунктМеню из списокПунктовМенюРасшифровкиДанных цикл
		Если Найти(пунктМеню.Значение, значениеПоляРасшифровки.Поле) = 0 Тогда Продолжить конецЕсли;
		
		текущийСписокПунктовМенюРасшифровкиДаных.Добавить(пунктМеню.Значение, пунктМеню.Представление);
	КонецЦикла;
	
	настройкиКомпоновкиДанных = обработкаРасшифровки.Выполнить(расшифровка, выполненноеДействиеИмя, массивИменОбрабатываемыхПолейРасшифровкиДанных, текущийСписокПунктовМенюРасшифровкиДаных);
	
	Если выполненноеДействиеИмя = ДействиеОбработкиРасшифровкиКомпоновкиДанных.Нет
		ИЛИ массивИменОбрабатываемыхПолейРасшифровкиДанных.Найти(выполненноеДействиеИмя) <> Неопределено Тогда Возврат конецЕсли;
	
	// Обробка додаткових пунктів меню
	Если выполненноеДействиеИмя = "Открыть: Сотрудник" Тогда
		обработкаРасшифровкиОткрытьСотрудник(расшифровка, данныеРасшифровки, массивИменОбрабатываемыхПолейРасшифровкиДанных);
		
	Иначе
	КонецЕсли;
	
КонецПроцедуры

#КонецОбласти


#Область Адміністрування

//ПолучитьСтруктуруХраненияБазыДанных(Новый Массив)
//КаталогПрограммы();
//РабочийКаталогДанныхПользователя();
//КаталогВременныхФайлов(); // пользователя
//КаталогДокументов();
//ИмяКомпьютера(); // на сервері всі користувачі 1С
//ПредставлениеПриложения("1CV8"); // "Толстый клиент" (локалізовано)
//ПолучитьИнформациюЭкрановКлиента();

Функция ИнформационнаяБазаСоединенияОтключить(кромеТекущегоПользователя = Истина) Экспорт
	
	Перем данныеАктивныхСеансовИнформационнойБазы, параметрыАдминистрированияИБ;
	Перем сеанс, пользователь;
	
	Если СоединенияИБ.КоличествоСеансовИнформационнойБазы(Ложь) <= 1 Тогда Возврат Истина конецЕсли;
	
	// Невозможно принудительно отсоединить сеансы в файловом режиме работы
	Если ИнформационнаяБазаФайловаяОпределить() Тогда
		
		СоединенияИБ.ЗаписатьНазванияСоединенийИБ("Невозможно принудительно отсоединить сеансы в файловом режиме работы");
		
		Возврат Ложь
		
	КонецЕсли;
	
	параметрыАдминистрированияИБ = СоединенияИБ.ПолучитьПараметрыАдминистрированияИБ();
	
#Если НаКлиенте Тогда
	
	Если ОбщегоНазначенияКлиент.КлиентПодключенЧерезВебСервер() Тогда
		
		Если СоединенияИБПовтИсп.ПараметрыОтключенияСеансов().WindowsПлатформаНаСервере Тогда
			Возврат СоединенияИБ.ОтключитьСоединенияИБ(параметрыАдминистрированияИБ) // Передача управление на сервер
		КонецЕсли;
		
		СоединенияИБ.ЗаписатьНазванияСоединенийИБ(
			"Невозможно принудительно отсоединить сеансы при работе с клиента через веб-сервер,
			| если на сервере не установлена ОС Microsoft Windows");
			
		Возврат Ложь
		
	КонецЕсли;
	
#КонецЕсли
	
	Попытка
		данныеАктивныхСеансовИнформационнойБазы = информационнаяБазаАктивныеСеансыПолучить(параметрыАдминистрированияИБ);
	Исключение
		e_ОбщегоНазначения.ОтобразитьСообщениеОбОшибке(ОписаниеОшибки(), ИнформацияОбОшибке()); // йомвірно, не зареєстрована компонента V83.COMConnector comcntr.dll
	КонецПопытки;
	
	Если данныеАктивныхСеансовИнформационнойБазы = Неопределено Тогда Возврат Ложь конецЕсли;
	
	Попытка
		
		Для Каждого сеанс из данныеАктивныхСеансовИнформационнойБазы.Сеансы цикл
			
			Если кромеТекущегоПользователя И ПараметрыСеанса.ТекущийПользователь.Наименование = сеанс.userName Тогда Продолжить конецЕсли;
			
			пользователь = Справочники.Пользователи.НайтиПоНаименованию(сеанс.UserName);
			
			ЗаписьЖурналаРегистрации(
				"Завершение работы пользователей",
				УровеньЖурналаРегистрации.Примечание,
				Метаданные.Справочники.Пользователи,
				?(ЗначениеЗаполнено(пользователь),
					пользователь,
					сеанс.UserName),
				СтрШаблон("Разрывается сеанс: Пользователь %1, компьютер %2, установлено %3, режим %4",
					сеанс.UserName,
					сеанс.Host,
					сеанс.StartedAt,
					сеанс.AppID));
					
			данныеАктивныхСеансовИнформационнойБазы.АгентСервера.TerminateSession(данныеАктивныхСеансовИнформационнойБазы.КластерСерверов, сеанс);
			
		КонецЦикла;
		
		Возврат СоединенияИБ.КоличествоСеансовИнформационнойБазы(Ложь) <= 1
		
	Исключение
		
		ЗаписьЖурналаРегистрации(
			"Завершение работы пользователей",
			УровеньЖурналаРегистрации.Ошибка,
			Метаданные.Справочники.Пользователи,
			сеанс.UserName,
			ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
			
		Возврат Ложь
		
	КонецПопытки;
	
КонецФункции

Функция информационнаяБазаАктивныеСеансыПолучить(настройкаБлокировки, Знач всеКромеТекущего = Истина)
	
	Перем подстрокиСтрокиСоединения, разделительПорта;
	Перем имяИПортСервера, номерПортаКластера, идентификаторАгентаСервера;
	Перем агентСервера, comСоединитель, кластер, имяСервера, имяИБ, номерТекущегоСеанса, сеанс, возвращаемоеЗначение;
	
	возвращаемоеЗначение = Новый Структура("АгентСервера, КластерСерверов, Сеансы", Неопределено, Неопределено, Новый Массив);
	
	подстрокиСтрокиСоединения = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(
		СтрокаСоединенияИнформационнойБазы(), ";");
		
	имяСервера = СтроковыеФункцииКлиентСервер.СократитьДвойныеКавычки(Сред(подстрокиСтрокиСоединения[0], 7));
	имяИБ = СтроковыеФункцииКлиентСервер.СократитьДвойныеКавычки(Сред(подстрокиСтрокиСоединения[1], 6));
	
	comСоединитель = Новый COMОбъект(ОбщегоНазначения.ИмяCOMСоединителя());
	
	разделительПорта = Найти(имяСервера, ":");
	
	Если разделительПорта > 0 Тогда
		
		имяИПортСервера = имяСервера;
		ИмяСервера = Сред(имяИПортСервера, 1, разделительПорта - 1);
		номерПортаКластера = Число(Сред(имяИПортСервера, разделительПорта + 1));
		
	ИначеЕсли настройкаБлокировки.ПортКластераСерверов <> 0 Тогда
		
		номерПортаКластера = настройкаБлокировки.ПортКластераСерверов;
		
	Иначе
		
		номерПортаКластера = comСоединитель.RMngrPortDefault;
		
	КонецЕсли;
	
	идентификаторАгентаСервера = имяСервера;
	
	Если настройкаБлокировки.ПортАгентаСервера <> 0 Тогда
		идентификаторАгентаСервера = идентификаторАгентаСервера + ":" + Формат(настройкаБлокировки.ПортАгентаСервера, "ЧГ=0");
	КонецЕсли;
	
	// Підключення до агента сервера
	агентСервера = comСоединитель.ConnectAgent(идентификаторАгентаСервера);
	возвращаемоеЗначение.АгентСервера = агентСервера; 
	
#Область Команди_агента_сервера
	// GetInfoBases(кластер)
	// GetInfoBaseSessions(кластер, информационнаяБаза)
	// GetInfoBaseConnections(кластер, информационнаяБаза)
	// GetClusters()
	// GetSessions(кластер)
	// GetWorkingProcesses(кластер)
	// Authenticate(кластер, имяАдминистратораКластера, парольАдминистратораКластера)
	// TerminateSession(кластер, сеанс)
#КонецОбласти
	
	// Пошук кластера
	
	Для Каждого кластер из агентСервера.GetClusters() цикл
		
		Если кластер.MainPort <> номерПортаКластера Тогда Продолжить конецЕсли;
		
		возвращаемоеЗначение.КластерСерверов = кластер;
		агентСервера.Authenticate(кластер, настройкаБлокировки.ИмяАдминистратораКластера, настройкаБлокировки.ПарольАдминистратораКластера);
		
		номерТекущегоСеанса = СоединенияИБПовтИсп.ПараметрыОтключенияСеансов().НомерСеансаИнформационнойБазы;
		
		Для Каждого сеанс из агентСервера.GetSessions(кластер) цикл
			
			Если ВРег(сеанс.InfoBase.Name) <> ВРег(имяИБ) Тогда Продолжить конецЕсли;
			
			Если НЕ всеКромеТекущего ИЛИ (номерТекущегоСеанса <> сеанс.SessionID) Тогда
				возвращаемоеЗначение.Сеансы.Добавить(Сеанс);
			КонецЕсли;
			
		КонецЦикла;
		
	КонецЦикла;
	
	Возврат возвращаемоеЗначение
	
КонецФункции

Функция ИнформационнаяБазаФайловаяОпределить() Экспорт
	
	Возврат ОпределитьЭтаИнформационнаяБазаФайловая();
	
КонецФункции

//СтрокаСоединенияИнформационнойБазы()
//ПолучитьНавигационнуюСсылкуИнформационнойБазы()
Функция ИнформационнаяБазаПредставлениеПолучить(получитьПолноеПредставление = Истина) Экспорт
	
	Перем информационнаяБазаПредставление, символРазделителя;
	
	информационнаяБазаПредставление = ОбщегоНазначения.ПолучитьПредставлениеИнформационнойБазы();
	
	Если получитьПолноеПредставление Тогда Возврат информационнаяБазаПредставление конецЕсли;
	
	символРазделителя = "\";
	
	Если СтрНайти(информационнаяБазаПредставление, символРазделителя, НаправлениеПоиска.СКонца) = 0 Тогда
		символРазделителя = "/";
	КонецЕсли;
	
	информационнаяБазаПредставление =
		Прав(информационнаяБазаПредставление,
		СтрДлина(информационнаяБазаПредставление) - СтрНайти(информационнаяБазаПредставление,
		символРазделителя,
		НаправлениеПоиска.СКонца));
		
	информационнаяБазаПредставление = СокрЛП(СтрЗаменить(информационнаяБазаПредставление, Символ(34), "")); // видалення подвійних кавичок
	
	Возврат информационнаяБазаПредставление
	
КонецФункции

Функция ПодключениеЧерезВебСерверКлиентаОпределить() Экспорт
	
	Возврат ОбщегоНазначенияКлиентСервер.КлиентПодключенЧерезВебСервер()
	
КонецФункции

//УправлениеДопПравамиПользователей.

// замість блокування використовується зміна ознаки Использование
Процедура БлокировкаРегламентныхЗаданий() Экспорт
	
	Перем регламентныеЗаданияИнформационнойБазы, регламентноеЗадание;
	
	регламентныеЗаданияИнформационнойБазы = РегламентныеЗадания.ПолучитьРегламентныеЗадания();
	
	Для Каждого регламентноеЗадание из регламентныеЗаданияИнформационнойБазы цикл
		
		Если НЕ регламентноеЗадание.Использование Тогда Продолжить конецЕсли;
		
		регламентноеЗадание.Использование = Ложь;
		
		регламентноеЗадание.Записать();
		e_ОбщегоНазначения.СообщениеОтобразить(СтрШаблон("Отключено использование регламентного задания «%1».", регламентноеЗадание.Метаданные.Синоним), СтатусСообщения.Внимание);
		
	КонецЦикла;
	
КонецПроцедуры

Функция МонопольныйРежимПопытатьсяУстановить(признакУстановки = Истина) Экспорт
	
	Перем результат;
	
	Попытка
		УстановитьМонопольныйРежим(признакУстановки);
		результат = Истина;
	Исключение
		СообщениеОтобразить("С информационной базой работают другие пользователи.
			|В данный момент невозможно установить монопольный режим!");
		результат = Ложь;
	КонецПопытки;
	
	Возврат результат
	
КонецФункции

Функция ГраницаЗапретаИзмененийПолучитьДляОрганизации(организация) Экспорт
	Перем наборЗаписейРегистра;
	
	наборЗаписейРегистра = РегистрНаборЗаписейПрочитать(
		РегистрыСведений.ГраницыЗапретаИзмененияДанных,
		Новый Структура("Организация, Пользователь", организация),
		Новый Структура("Организация, Пользователь"));
		
	Возврат
		?(наборЗаписейРегистра.Количество() = 0,
		ДатаМинимальноеЗначение(),
		наборЗаписейРегистра.Получить(0).ГраницаЗапретаИзменений)
КонецФункции

Функция ДополнительныеПраваПользователейПолучить(планыВидовХарактеристикПраваПользователей, значениеПоУмолчанию = Неопределено) Экспорт
	
	Перем значенияПравПользователя;
	
	Если значениеПоУмолчанию = Неопределено Тогда
		значениеПоУмолчанию = Ложь;
	КонецЕсли;
	
	значенияПравПользователя = УправлениеДопПравамиПользователей.ПолучитьЗначениеПраваПользователя(планыВидовХарактеристикПраваПользователей, значениеПоУмолчанию);
	
	Возврат
		?(значенияПравПользователя.Количество() = 0,
		значениеПоУмолчанию,
		значенияПравПользователя.Получить(0))
		
КонецФункции

Функция НастройкаПользователяПолучить(планыВидовХарактеристикНастройкиПользователей, значениеПоУмолчанию = Неопределено, пользователь = Неопределено) Экспорт
	
	// РАЗРЕШЕННЫЕ
	Возврат УправлениеПользователями.ПолучитьЗначениеПоУмолчанию(
		?(пользователь = Неопределено,
			ПараметрыСеанса.ТекущийПользователь,
			пользователь),
		планыВидовХарактеристикНастройкиПользователей.ИмяПредопределенныхДанных)
		
КонецФункции

Функция НастройкаПользователяПолучитьОсновнаяОрганизация(пользователь = Неопределено) Экспорт
	
	Возврат УправлениеПользователями.ПолучитьЗначениеПоУмолчанию(
		?(ЗначениеЗаполнено(пользователь),
			пользователь,
			ПараметрыСеанса.ТекущийПользователь),
		"ОсновнаяОрганизация")
		
КонецФункции

Функция НастройкаПользователяПолучитьОсновноеПодразделение(пользователь = Неопределено) Экспорт
	
	Возврат УправлениеПользователями.ПолучитьЗначениеПоУмолчанию(
		?(ЗначениеЗаполнено(пользователь),
		пользователь,
		ПараметрыСеанса.ТекущийПользователь),
		"ОсновноеПодразделение")
		
КонецФункции

Функция НастройкаПользователяПолучитьОсновнойСклад(пользователь = Неопределено) Экспорт
	
	Возврат УправлениеПользователями.ПолучитьЗначениеПоУмолчанию(
		?(ЗначениеЗаполнено(пользователь),
		пользователь,
		ПараметрыСеанса.ТекущийПользователь),
		"ОсновнойСклад")
		
КонецФункции

Функция ПолучитьСписокПользователейИнформационнойБазы(метаданныеРольИмя = "") Экспорт
	
	Перем массивПользователейИБ;
	
	Если ПустаяСтрока(метаданныеРольИмя) Тогда возврат ПользователиИнформационнойБазы.ПолучитьПользователей() конецЕсли;
	
	массивПользователейИБ = Новый Массив;
	
	Для Каждого пользовательИБ из ПользователиИнформационнойБазы.ПолучитьПользователей() цикл
		Если НЕ пользовательИБ.Роли.Содержит(Метаданные.Роли[метаданныеРольИмя]) Тогда Продолжить конецЕсли;
		массивПользователейИБ.Добавить(пользовательИБ);
	КонецЦикла;
	
	Возврат массивПользователейИБ
	
КонецФункции

Функция ФизЛицоПользователяИнформационнойБазыПодобратьПоНаименование(пользовательИнформационнойБазы) Экспорт
	
	Перем запрос, результатВыполненияЗапроса;
	
	запрос = Новый Запрос;
	
	запрос.Текст = "ВЫБРАТЬ РАЗРЕШЕННЫЕ РАЗЛИЧНЫЕ ПЕРВЫЕ 1
	               |	ФизическиеЛица.Ссылка
	               |ИЗ
	               |	Справочник.ФизическиеЛица КАК ФизическиеЛица
	               |ГДЕ
	               |	НЕ ФизическиеЛица.ЭтоГруппа
	               |	И НЕ ФизическиеЛица.ПометкаУдаления
	               |	И ФизическиеЛица.Наименование ПОДОБНО &Наименование";
	
	запрос.УстановитьПараметр("Наименование", СокрЛП(пользовательИнформационнойБазы.Имя));
	
	результатВыполненияЗапроса = запрос.Выполнить();
	
	Возврат
		?(результатВыполненияЗапроса.Пустой(),
		Справочники.ФизическиеЛица.ПустаяСсылка(),
		результатВыполненияЗапроса.Выгрузить().Получить(0).Ссылка)
		
КонецФункции

Функция ПользователиПолучитьПоРоли(имяРоли, получитьПользователейИнформармационнойБазы = Ложь) Экспорт
	Перем пользователи;
	
	пользователи = Новый Массив;
	
	Для Каждого элемент из ПользователиПолучить(,,, Истина) цикл
		Если НЕ элемент.ПользовательИб.Роли.Содержит(Метаданные.Роли[имяРоли]) Тогда Продолжить конецЕсли;
		пользователи.Добавить(элемент.Пользователь);
	КонецЦикла;
	
	Возврат пользователи
КонецФункции

Функция ПользователиПолучить(получитьПользователейИнформармационнойБазы = Ложь, исключитьПомеченныхНаУдаление = Истина, сортировать = Истина, вернутьВВидеСтруктуры = Ложь) Экспорт
	
	Перем элемент, пользователи, пользователиИб, физЛица, индекс, возвращаемоеЗначение;
	
	пользователиИб = Новый СписокЗначений;
	пользователи = Новый Массив;
	физЛица = Новый Массив;
	
	индекс = 0;
	
	Для Каждого элемент из ПользователиИнформационнойБазы.ПолучитьПользователей() цикл
		
		физЛицо = ФизЛицоПользователяИнформационнойБазыПодобратьПоНаименование(элемент);
		
		Если НЕ ЗначениеЗаполнено(физЛицо) Тогда Продолжить конецЕсли;
		
		пользователь = ПользовательПодобратьПоФизЛицу(физЛицо);
		
		Если НЕ ЗначениеЗаполнено(пользователь) ИЛИ исключитьПомеченныхНаУдаление И пользователь.ПометкаУдаления Тогда Продолжить конецЕсли;
		
		пользователиИб.Добавить(элемент, индекс);
		пользователи.Добавить(пользователь);
		физЛица.Добавить(физЛицо);
		
		индекс = индекс + 1;
		
	КонецЦикла;
	
	Если сортировать Тогда
		пользователиИб.СортироватьПоЗначению();
	КонецЕсли;
	
	Если вернутьВВидеСтруктуры Тогда
		
		возвращаемоеЗначение = Новый Массив;
		
		Для Каждого элемент из пользователиИб цикл
			
			возвращаемаяСтруктура = Новый Структура("ПользовательИб, Пользователь, ФизЛицо");
			
			возвращаемаяСтруктура.ПользовательИб = элемент.Значение;
			возвращаемаяСтруктура.Пользователь = пользователи[Число(элемент.Представление)];
			возвращаемаяСтруктура.ФизЛицо = физЛица[Число(элемент.Представление)];
			
			возвращаемоеЗначение.Добавить(возвращаемаяСтруктура);
			
		КонецЦикла;
		
	ИначеЕсли получитьПользователейИнформармационнойБазы Тогда
		
		возвращаемоеЗначение = пользователиИб.ВыгрузитьЗначения();
		
	Иначе
		
		возвращаемоеЗначение = Новый Массив;
		
		Для Каждого элемент из пользователиИб цикл
			возвращаемоеЗначение.Добавить(пользователи[Число(элемент.Представление)]);
		КонецЦикла;
		
	КонецЕсли;
	
	Возврат возвращаемоеЗначение
	
КонецФункции

Функция ПользователиПодбор(Знач списокПользователей = Неопределено, активироватьПодборПоРолях = Ложь) Экспорт
	
	Перем результатВыбора, списокПользователейКопия;
	
	Если списокПользователей = Неопределено Тогда
		списокПользователей = Новый СписокЗначений;
	ИначеЕсли Тип("Массив") = ТипЗнч(списокПользователей) Тогда
		списокПользователейКопия = Новый СписокЗначений;
		списокПользователейКопия.ЗагрузитьЗначения(списокПользователей);
		списокПользователей = списокПользователейКопия;
	КонецЕсли;
	
	#Если Клиент Тогда
	
	результатВыбора = ФормаОткрыть(
		ПолучитьФорму("ОбщаяФорма.ПодборПользователейДляНастройкиПравДоступа"),
		Истина,
		Новый Структура("АктивироватьПодборПоРолях, ОтмеченныеПользователи", активироватьПодборПоРолях, списокПользователей));
		
	Если результатВыбора = Неопределено Тогда
		
		Возврат Неопределено // форму закрито
		
	ИначеЕсли результатВыбора.Количество() = 0 Тогда
		
		Возврат Новый СписокЗначений // не вибрано жодного елемента
		
	КонецЕсли;
	
	Если Тип("СправочникСсылка.ГруппыПользователей") = ТипЗнч(результатВыбора.Получить(0)) Тогда
		
		Если результатВыбора.Получить(0) = Справочники.ГруппыПользователей.ВсеПользователи Тогда
			результатВыбора = e_ОбщегоНазначения.ПользователиПолучить();
		Иначе
			результатВыбора = e_ОбщегоНазначения.РеквизитОбъектовВыгрузитьМассив("Пользователь", результатВыбора.Получить(0).ПользователиГруппы);
		КонецЕсли;
		
	КонецЕсли;
	
	списокПользователей.ЗагрузитьЗначения(результатВыбора);
	
	#КонецЕсли
	
	Возврат списокПользователей
	
КонецФункции

Функция СотрудникНайтиПоФизЛицо(физЛицо, актуальность = Истина, видЗанятости = Неопределено) Экспорт
	
	Перем запрос, результатВыполненияЗапроса;
	
	Если НЕ ЗначениеЗаполнено(физЛицо) Тогда Возврат Неопределено конецЕсли;
	
	запрос = Новый Запрос;
	
	запрос.Текст = "ВЫБРАТЬ РАЗРЕШЕННЫЕ РАЗЛИЧНЫЕ ПЕРВЫЕ 1
	               |	СотрудникиОрганизаций.Ссылка
	               |ИЗ
	               |	Справочник.СотрудникиОрганизаций КАК СотрудникиОрганизаций
	               |ГДЕ
	               |	НЕ СотрудникиОрганизаций.ЭтоГруппа
	               |	И НЕ СотрудникиОрганизаций.ПометкаУдаления
	               |	И СотрудникиОрганизаций.Наименование = &Наименование
	               |	И СотрудникиОрганизаций.Актуальность = &Актуальность
	               |	И СотрудникиОрганизаций.ВидЗанятости = &ВидЗанятости";
	
	запрос.УстановитьПараметр("Наименование", СокрЛП(физЛицо.Наименование));
	запрос.УстановитьПараметр("Актуальность", актуальность);
	запрос.УстановитьПараметр("ВидЗанятости",
		?(видЗанятости = Неопределено,
		Перечисления.ВидыЗанятостиВОрганизации.ОсновноеМестоРаботы,
		видЗанятости));
		
	результатВыполненияЗапроса = запрос.Выполнить();
	
	Возврат
		?(результатВыполненияЗапроса.Пустой(),
		Справочники.СотрудникиОрганизаций.ПустаяСсылка(),
		результатВыполненияЗапроса.Выгрузить().Получить(0).Ссылка)
		
КонецФункции

Функция ПользовательПодобратьПоФизЛицу(физЛицо) Экспорт
	
	Перем запрос, результатВыполненияЗапроса, возвращатьМассив;
	
	Если НЕ ЗначениеЗаполнено(физЛицо) Тогда возврат Неопределено конецЕсли;
	
	возвращатьМассив = Тип("СписокЗначений") = ТипЗнч(физЛицо);
	
	запрос = Новый Запрос;
	
	запрос.Текст = "ВЫБРАТЬ РАЗРЕШЕННЫЕ РАЗЛИЧНЫЕ ПЕРВЫЕ 1
	               |	Пользователи.Ссылка КАК Пользователь
	               |ИЗ
	               |	Справочник.Пользователи КАК Пользователи
	               |ГДЕ
	               |	НЕ Пользователи.ЭтоГруппа
	               |	И НЕ Пользователи.ПометкаУдаления";
	
	Если возвращатьМассив Тогда
		
		запрос.Текст =
			СтрЗаменить(запрос.Текст, " ПЕРВЫЕ 1", "") + "
	               |	И Пользователи.ФизЛицо В(&ФизЛицо)";
		
		запрос.УстановитьПараметр("ФизЛицо", физЛицо);
		
	Иначе
		
		запрос.Текст = запрос.Текст + "
	               |	И Пользователи.Наименование ПОДОБНО &Наименование";
		
		запрос.УстановитьПараметр("Наименование", СокрЛП(физЛицо.Наименование));
		
	КонецЕсли;
	
	результатВыполненияЗапроса = запрос.Выполнить();
	
	Если результатВыполненияЗапроса.Пустой() Тогда
		
		Возврат
			?(возвращатьМассив,
			Новый Массив,
			Справочники.Пользователи.ПустаяСсылка())
			
	Иначе
		
		Возврат
			?(возвращатьМассив,
			результатВыполненияЗапроса.Выгрузить().ВыгрузитьКолонку("Пользователь"),
			результатВыполненияЗапроса.Выгрузить().Получить(0).Пользователь)
			
	КонецЕсли;
	
КонецФункции

Функция ПользовательПользователяИбПолучитьПоИдентификатору(пользователяИб) Экспорт
	
	Возврат Справочники.Пользователи.НайтиПоРеквизиту(
		"ИдентификаторПользователяИБ",
		пользователяИб.УникальныйИдентификатор)
		
КонецФункции

Функция ПользовательИнформационнойБазы(пользователь = Неопределено) Экспорт
	
	Если пользователь = Неопределено Тогда
		пользователь = ПараметрыСеанса.ТекущийПользователь;
	КонецЕсли;
	
	Возврат ПользователиИнформационнойБазы.НайтиПоУникальномуИдентификатору(пользователь.ИдентификаторПользователяИБ)
	
КонецФункции

Функция ПользовательИбРольДоступна(роль, пользователь = Неопределено) Экспорт
	
	Перем пользовательИБ;
	
	Если пользователь = Неопределено Тогда
		пользователь = ПараметрыСеанса.ТекущийПользователь;
	КонецЕсли;
	
	пользовательИБ = e_ОбщегоНазначения.ПользовательИнформационнойБазы(пользователь);
	
	Если пользовательИБ = Неопределено Тогда Возврат Ложь конецЕсли;
	
	Возврат пользовательИБ.Роли.Содержит(
		?(Тип(Метаданные.Роли) = ТипЗнч(роль),
		роль,
		Метаданные.Роли[роль]))
		
КонецФункции

Функция ПользовательОперационнойСистемыДанныеПолучить(пользователь) Экспорт
	
	Перем имяДомена, имяПользователяОс, имяПользователя, временныйМассив;
	
	имяПользователяОс = ПользовательИнформационнойБазы(пользователь).ПользовательОС;
	временныйМассив = e_ОбщегоНазначения.СтрокаРазбитьНаСоставляющие(имяПользователяОс, "\");
	имяПользователя = временныйМассив.Получить(временныйМассив.Количество() - 1);
	имяДомена = Лев(имяПользователяОс, СтрДлина(имяПользователяОс) - СтрДлина(имяПользователя));
	
	Возврат Новый Структура("ИмяДомена, ИмяПользователя", имяДомена,имяПользователя)
	
КонецФункции

Функция ПользовательИнформационнойБазыПодобратьПоФизЛицу(физЛицо) Экспорт
	
	Перем пользовательИнформационнойБазы;
	
	Если НЕ ЗначениеЗаполнено(физЛицо) Тогда возврат Неопределено конецЕсли;
	
	Для Каждого пользовательИнформационнойБазы из ПользователиИнформационнойБазы.ПолучитьПользователей() цикл
		
		Если Найти(СокрЛП(пользовательИнформационнойБазы.ПолноеИмя), СокрЛП(физЛицо.Наименование)) = 0 Тогда Продолжить конецЕсли;
		
		Возврат пользовательИнформационнойБазы;
		
	КонецЦикла;
	
	Возврат Неопределено
	
КонецФункции

Функция ДоменноеИмяАвторизированногоВОсПользователяПолучить(получитьПолноеДоменноеИмя = Истина) Экспорт
	Перем netWorkCOM;
	
	netWorkCOM = Новый COMObject("wscript.network");
	
	Если ПустаяСтрока(netWorkCOM.Username) Тогда Возврат "" конецЕсли;
	
	Возврат
		?(получитьПолноеДоменноеИмя,
		"\\" + netWorkCOM.UserDomain + "\" + netWorkCOM.Username,
		netWorkCOM.Username)
		
КонецФункции

Функция ПользовательИбПолучитьПоДоменномуИмени(доменноеИмяПользователя) Экспорт
	
	Перем пользовательИб;
	
	Для Каждого пользовательИб из ПЕК_Привилегированный.ПолучитьПользователейИнформационнойБазы() цикл
		Если СокрЛП(НРег(пользовательИб.ПользовательОС)) = СокрЛП(НРег(доменноеИмяПользователя)) Тогда Возврат пользовательИб конецЕсли;
	КонецЦикла;
	
	Возврат Неопределено
	
КонецФункции

// На сервері всі користувачі авторизуються як 1CV8
&НаКлиенте
Функция ПользовательПолучитьПоАвторизацииВОС(возвращатьДоменноеИмяПользователяЕслиНеопределено = Истина, выполнятьИдентификациюПользовательИбПользовательФизлицо = Истина) Экспорт
	
	Перем пользовательИбфизЛицо, физЛицо;
	
	доменноеИмяПользователя = ДоменноеИмяАвторизированногоВОсПользователяПолучить();
	
	Если ПустаяСтрока(доменноеИмяПользователя) Тогда
		
		Возврат
			?(возвращатьДоменноеИмяПользователяЕслиНеопределено,
			"",
			Неопределено)
			
	КонецЕсли;
	
	пользовательИб = ПользовательИбПолучитьПоДоменномуИмени(доменноеИмяПользователя);
	
	Если пользовательИб = Неопределено Тогда
		
		Возврат
			?(возвращатьДоменноеИмяПользователяЕслиНеопределено,
			доменноеИмяПользователя,
			Неопределено)
			
	КонецЕсли;
	
	Если выполнятьИдентификациюПользовательИбПользовательФизлицо Тогда
		
		физЛицо = ФизЛицоПользователяИнформационнойБазыПодобратьПоНаименование(пользовательИб);
		
		Если НЕ ЗначениеЗаполнено(физЛицо) Тогда
			
			Возврат
				?(возвращатьДоменноеИмяПользователяЕслиНеопределено,
				доменноеИмяПользователя,
				Справочники.Пользователи.ПустаяСсылка())
				
		КонецЕсли;
		
		Возврат ПользовательПодобратьПоФизЛицу(физЛицо)
		
	Иначе
		
		Возврат ПользовательПользователяИбПолучитьПоИдентификатору(пользовательИб)
		
	КонецЕсли;
	
КонецФункции

Функция ПолучитьСписокАктивныхПользователей() Экспорт
	
	таблицаЗначений = Новый ТаблицаЗначений();
	таблицаЗначений.Колонки.Добавить("Пользователь");
	таблицаЗначений.Колонки.Добавить("Приложение");
	таблицаЗначений.Колонки.Добавить("НачалоРаботы");
	таблицаЗначений.Колонки.Добавить("Компьютер");
	таблицаЗначений.Колонки.Добавить("Соединение");
	соединенияИнформационнойБазы = ПолучитьСоединенияИнформационнойБазы();
	
	Для Каждого соединение из соединенияИнформационнойБазы цикл
		
		строка = таблицаЗначений.Добавить();
		строка.Приложение = ПредставлениеПриложения(соединение.ИмяПриложения);
		строка.НачалоРаботы = соединение.НачалоСеанса;
		строка.Компьютер = соединение.ИмяКомпьютера;
		строка.Соединение = соединение.НомерСоединения;
		
		пользователь = Справочники.Пользователи.НайтиПоКоду(соединение.Пользователь.Имя);
		пользовательПоПолноеИмя = Справочники.Пользователи.НайтиПоКоду(соединение.Пользователь.ПолноеИмя);
		
		Если ЗначениеЗаполнено(пользователь)
			И ЗначениеЗаполнено(пользовательПоПолноеИмя) Тогда
			
			Если пользователь.ПометкаУдаления
				И пользователь = пользовательПоПолноеИмя Тогда
				строка.Пользователь = пользователь;
			Иначе// Різні коди
				Если пользователь.ПометкаУдаления
					И пользовательПоПолноеИмя.ПометкаУдаления Тогда
					строка.Пользователь = пользователь;
				Иначе
					строка.Пользователь = пользовательПоПолноеИмя;
				КонецЕсли;
			КонецЕсли;
			
		Иначе
			
			строка.Пользователь = Неопределено;
			
		КонецЕсли
		
	КонецЦикла;
	
	номерТекущегоСоединения = НомерСоединенияИнформационнойБазы();
	
	Возврат таблицаЗначений
	
КонецФункции

Функция ПроконтролироватьВходПользователейВСистемму(пользователи) Экспорт
	
	Если пользователи = Неопределено Тогда
		
		Возврат Ложь;
		
	ИначеЕсли ТипЗнч(пользователи) = Тип("СправочникСсылка.Пользователи") Тогда
		
		Если пользователи = ПараметрыСеанса.ТекущийПользователь Тогда возврат Истина конецЕсли;
		
		массивПользователей = Новый Массив();
		массивПользователей.Добавить(пользователи);
		
		Возврат проконтролироватьВходПользователейВСистемму(массивПользователей);
		
	ИначеЕсли ТипЗнч(пользователи) = Тип("СписокЗначений") Тогда
		
		Возврат проконтролироватьВходПользователейВСистемму(пользователи.ВыгрузитьЗначения());
		
	КонецЕсли;
	
	#Если Клиент Тогда
	Состояние(НСтр("ru='Проверка входа пользователей в системму...'; uk='Перевірка входу користувачів в систему...'"));
	#КонецЕсли
	
	активныеПользователиБазы = ПолучитьСписокАктивныхПользователей();
	Если Тип(пользователи) = Тип("Массив") Тогда
		
		Для Каждого пользователь из пользователи цикл
			пользователиВыполнилиВходВСистемму = Ложь;
			
			Для Каждого активныйПользователь из активныеПользователиБазы цикл
				Если активныйПользователь.Пользователь = Неопределено Тогда Продолжить конецЕсли;
				
				Если СокрЛП(пользователь.Код) = СокрЛП(активныйПользователь.Пользователь.Код) Тогда
					пользователиВыполнилиВходВСистемму = Истина;
					
					Прервать;
				КонецЕсли;
			КонецЦикла;
			
			Если НЕ пользователиВыполнилиВходВСистемму Тогда
				
				#Если Клиент Тогда
				ответ = Вопрос(
					"На данный момент пользователь «" + СокрЛП(пользователь) + "» не выполнил вход в системму. Продолжить?",
					РежимДиалогаВопрос.ДаНет, 5, КодВозвратаДиалога.Да,, КодВозвратаДиалога.Да);
				Если ответ = КодВозвратаДиалога.Нет Тогда возврат Ложь конецЕсли;
				
				#Иначе
				Возврат Ложь
				#КонецЕсли
				
			КонецЕсли;
		КонецЦикла;
		
	Иначе
		#Если Клиент Тогда
		Сообщить(НСтр("ru='Тип значения «Пользователя» неопределен'; uk='Тип значення «Користувача» не визначений'"), СтатусСообщения.Внимание);
		#КонецЕсли
		
		Возврат Ложь
	КонецЕсли;
	
	Возврат Истина
	
КонецФункции

//ПравоДоступа
Функция ПроверитьПрава(роль = Неопределено, текстСообщения = "") Экспорт
	
	Перем текущийПользовательВладеетРолью;
	
	Если роль = Неопределено Тогда
		роль = Метаданные.Роли.ПолныеПрава;
	КонецЕсли;
	
	Если ПустаяСтрока(текстСообщения) Тогда
		текстСообщения = НСтр("ru='Для выполнения этого действия необходима роль «'; uk='Для виконання цієї дії необхідна роль «'") + роль + "»";
	КонецЕсли;
	
	текущийПользовательВладеетРолью = РольДоступна(роль);
	
	Если НЕ текущийПользовательВладеетРолью
		И НЕ текстСообщения = Неопределено Тогда
		СообщениеОтобразить(текстСообщения);
	КонецЕсли;
	
	Возврат текущийПользовательВладеетРолью
	
КонецФункции

Процедура ОбновитьПараметрыСеансаПользователя() Экспорт
	Перем текстРезультата;
	
	#Если Клиент Тогда
	
	текстРезультата = "";
	
	ПолныеПрава.УстановитьИзменяемыеПараметрыСеансаПользователя(Истина, текстРезультата);
	
	текстРезультата = НСтр("ru='Обновление системной информации завершено успешно!'; uk='Оновлення системної інформації завершено успішно!'") + Символы.ПС + Символы.ПС
	+ НСтр("ru='Протокол обновления:';uk='Протокол оновлення:'") + Символы.ПС + Символы.НПП + СокрЛП(текстРезультата);
	
	Предупреждение(ТекстРезультата);
	
	#КонецЕсли

КонецПроцедуры

Функция ПриложениеЗапущеноОтИмениАдминистратораПроверить(текстСообщения = Неопределено) Экспорт
	
	Перем символРазделителя, имяФайла, естьДоступ;
	
	естьДоступ = Истина;
	символРазделителя = "\";
	имяФайла = СтрШаблон(
		"C:%1~TestAdmin%2",
		символРазделителя,
		СтрокаУбратьНедопустимыеСимволы(ТекущаяУниверсальнаяДатаВМиллисекундах()));
		
	Попытка
		СоздатьКаталог(имяФайла);
	Исключение // ігнорувати
		естьДоступ = Ложь
	КонецПопытки;
	
	Попытка
		УдалитьФайлы(имяФайла);
	Исключение //ігнорувати
		естьДоступ = Ложь
	КонецПопытки;
	
	Если НЕ естьДоступ И НЕ текстСообщения = Неопределено Тогда
		
		Если ПустаяСтрока(текстСообщения) Тогда
			текстСообщения = "Для выполнения выбранного действия требуется запуск приложения от имени Администратора.";
		КонецЕсли;
		
		СообщениеОтобразить(текстСообщения);
		
	КонецЕсли;
	
	Возврат естьДоступ
	
КонецФункции

Функция ПараметрыСоединенияИнформационнойБазыСтруктураПараметровПолучить() Экспорт
	
	Перем структураПараметров, параметрыСоединения, структураПути;
	
	структураПараметров = Новый Структура("СтрокаСоединения, ВариантРаботыКлиентСерверный, ИмяСервера, ИмяБазы");
	
	структураПараметров.СтрокаСоединения = СтрокаСоединенияИнформационнойБазы();
	параметрыСоединения = СтрокаРазбитьНаСоставляющие(структураПараметров.СтрокаСоединения, ";");
	
	Если Лев(параметрыСоединения[0], 4) = "Srvr" Тогда
		структураПараметров.ВариантРаботыКлиентСерверный = Истина;
		структураПараметров.ИмяСервера = Сред(параметрыСоединения[0], 7, СтрДлина(параметрыСоединения[0]) - 7);
		структураПараметров.ИмяБазы = Сред(параметрыСоединения[1], 6, СтрДлина(параметрыСоединения[1]) - 6);
	Иначе
		структураПараметров.ВариантРаботыКлиентСерверный = Ложь;
		структураПути = ФайлСтруктураПутиПолучить(Сред(параметрыСоединения[0], 6, СтрДлина(параметрыСоединения[0]) - 6));
		структураПараметров.ИмяСервера = структураПути.Путь;
		структураПараметров.ИмяБазы = структураПути.ИмяСРасширением;
	КонецЕсли;
	
	Возврат структураПараметров
	
КонецФункции

Функция СредаВыполненияКонтекстПолучить() Экспорт
	
	#Если ТолстыйКлиентОбычноеПриложение ИЛИ ТолстыйКлиентУправляемоеПриложение Тогда
		
		Возврат "Толстый клиент"
		
	#ИначеЕсли Сервер Тогда
		
		Возврат "Сервер"
		
	#ИначеЕсли ВнешнееСоединение Тогда
		
		Возврат "Внешнее соединение"
		
	#ИначеЕсли ТонкийКлиент Тогда
		
		Возврат "Тонкий клиент"
		
	#ИначеЕсли ВебКлиент Тогда
		
		Возврат "Веб-клиент"
		
	#Иначе
		
		Возврат Неопределено
		
	#КонецЕсли
	
КонецФункции

//ОбщегоНазначенияКлиентСервер.КлиентПодключенЧерезВебСервер()
Функция СредаВыполненияИмяПриложенияПолучить(пользовательИнформационнойБазы = Неопределено) Экспорт
	
	Если пользовательИнформационнойБазы = Неопределено Тогда
		пользовательИнформационнойБазы = ПользователиИнформационнойБазы.ТекущийПользователь();
	КонецЕсли;
	
	Для Каждого соединениеИнформационнойБазы из ПолучитьСоединенияИнформационнойБазы() цикл
		Если соединениеИнформационнойБазы.Пользователь.УникальныйИдентификатор <> пользовательИнформационнойБазы.УникальныйИдентификатор Тогда Продолжить конецЕсли;
		Возврат соединениеИнформационнойБазы.ИмяПриложения
	КонецЦикла;
	
	Возврат ""
	
КонецФункции

Функция КодЯзыкаПользователяПолучить(получитьЯзыкФормированияПечатныхФорм = Ложь, возвращатьКодЯзыкаСистемыЕслиНезаполнено = Истина) Экспорт
	
	Если получитьЯзыкФормированияПечатныхФорм Тогда
		
		кодЯзыка = ЛокализацияПовтИсп.ПолучитьЯзыкФормированияПечатныхФормДокументов();
		
	Иначе
		
		кодЯзыка = ПользователиИнформационнойБазы.ТекущийПользователь().Язык;
		
		Если кодЯзыка <> Неопределено Тогда
			кодЯзыка = кодЯзыка.КодЯзыка;
		ИначеЕсли возвращатьКодЯзыкаСистемыЕслиНезаполнено Тогда
			кодЯзыка = КодЯзыкаСистемыПолучить();
		Иначе
			кодЯзыка = Неопределено;
		КонецЕсли;
		
	КонецЕсли;
	
	Возврат кодЯзыка
	
КонецФункции

Функция КодЯзыкаСистемыПолучить() Экспорт
	
	Возврат ЛокализацияПовтИсп.КодЯзыкаСистемы()
	
КонецФункции

#КонецОбласти


#Область МетодиМодуля

Функция дополнитьРекурсивноКоллекциюСтрокДереваЗначений(колекцияСтрок, строкаДереваЗначений)
	
	Перем вВидеТаблицыЗначений, этоУзел, новаяСтрока;
	
	вВидеТаблицыЗначений = Тип("ТаблицаЗначений") = ТипЗнч(колекцияСтрок);
	
	Если Тип("ДеревоЗначений") = ТипЗнч(строкаДереваЗначений) Тогда
		
		Для Каждого подстрокаДереваЗначений из строкаДереваЗначений.Строки цикл // верхній рівень
			
			#Если Клиент Тогда
			ОбработкаПрерыванияПользователя();
			#КонецЕсли
			
			этоУзел = подстрокаДереваЗначений.Строки.Количество() > 0;
			
			Если НЕ этоУзел Тогда
				
				Если вВидеТаблицыЗначений Тогда
					новаяСтрока = колекцияСтрок.Добавить();
					ЗаполнитьЗначенияСвойств(новаяСтрока, подстрокаДереваЗначений);
				Иначе
					колекцияСтрок.Добавить(подстрокаДереваЗначений);
				КонецЕсли;
				
			Иначе // рекурсія
				
				дополнитьРекурсивноКоллекциюСтрокДереваЗначений(колекцияСтрок, подстрокаДереваЗначений);
				
			КонецЕсли;
			
		КонецЦикла;
		
	ИначеЕсли Тип("СтрокаДереваЗначений") = ТипЗнч(строкаДереваЗначений) Тогда
		
		Для Каждого подстрокаДереваЗначений из строкаДереваЗначений.Строки цикл // верхній рівень
			
			#Если Клиент Тогда
			ОбработкаПрерыванияПользователя();
			#КонецЕсли
			
			этоУзел = подстрокаДереваЗначений.Строки.Количество() > 0;
			
			Если НЕ этоУзел Тогда
				
				Если вВидеТаблицыЗначений Тогда
					новаяСтрока = колекцияСтрок.Добавить();
					ЗаполнитьЗначенияСвойств(новаяСтрока, подстрокаДереваЗначений);
				Иначе
					колекцияСтрок.Добавить(подстрокаДереваЗначений);
				КонецЕсли;
				
			Иначе // рекурсія
				
				дополнитьРекурсивноКоллекциюСтрокДереваЗначений(колекцияСтрок, подстрокаДереваЗначений);
				
			КонецЕсли;
			
		КонецЦикла;
		
	КонецЕсли;
	
	Возврат колекцияСтрок
	
КонецФункции

Функция строкаРазложитьВМассивПодстрокРекурсивно(строка, массивПодстрок = Неопределено, строкаРазделителя = ";")
	
	Перем индексРазделителя, подстрока, остатокСтроки;
	
	Если ПустаяСтрока(строка) Тогда Возврат Неопределено конецЕсли;
	
	Если массивПодстрок = Неопределено Тогда
		массивПодстрок = Новый Массив();
	КонецЕсли;
	
	индексРазделителя = Найти(строка, строкаРазделителя);
	
	Если индексРазделителя = 0 Тогда
		массивПодстрок.Добавить(строка);
		Возврат массивПодстрок
	КонецЕсли;
	
	// Якщо є додаткові символи, наприклад Символы.ПС
	количествоДополнительныхСимволовРазделителя = 1;
	
	подстрока = Лев(строка, индексРазделителя - 1);
	остатокСтроки = Прав(строка, СтрДлина(строка) - индексРазделителя - количествоДополнительныхСимволовРазделителя);
	массивПодстрок.Добавить(подстрока);
	строкаРазложитьВМассивПодстрокРекурсивно(остатокСтроки, массивПодстрок);
	
	Возврат массивПодстрок
	
КонецФункции

Функция проверитьЗаполнениеОбязательныхРеквизитовОбъекта(наименованиеТипа, структураДанных, текстСообщения)
	
	Перем естьНезаполненныеРеквизиты;
	
	Попытка
		
		Если "«Схемы налогового учета по договорам контрагентов»" = наименованиеТипа
			ИЛИ "«Виды договоров по ГК»" = наименованиеТипа Тогда
			
			естьНезаполненныеРеквизиты = НЕ ЗначениеЗаполнено(структураДанных.Наименование);
			
		ИначеЕсли "«Вид номенклатуры»" = наименованиеТипа
			И (ПустаяСтрока(структураДанных.Наименование)
			ИЛИ ПустаяСтрока(структураДанных.ТипНоменклатуры)) Тогда
			
			естьНезаполненныеРеквизиты = Истина;
			
		ИначеЕсли "«Контактное лицо контрагента»" = наименованиеТипа
			И (ПустаяСтрока(структураДанных.Наименование)
			ИЛИ НЕ ЗначениеЗаполнено(структураДанных.Владелец.Ссылка)) Тогда
			
			естьНезаполненныеРеквизиты = Истина;
			
		ИначеЕсли "«Информационная карта»" = наименованиеТипа
			И (Число(структураДанных.КодКарты) = 0
			ИЛИ НЕ ЗначениеЗаполнено(структураДанных.ВидКарты)) Тогда
			
			естьНезаполненныеРеквизиты = Истина;
			
		ИначеЕсли "«Штрихкод»" = наименованиеТипа
			И (Число(структураДанных.КодКарты) = 0
			ИЛИ НЕ ЗначениеЗаполнено(структураДанных.ТипШтрихкода)
			ИЛИ НЕ ЗначениеЗаполнено(структураДанных.Владелец)) Тогда
			
			естьНезаполненныеРеквизиты = Истина;
			
		ИначеЕсли "«Контактная информация»" = наименованиеТипа
			И (НЕ ЗначениеЗаполнено(структураДанных.Объект)
			ИЛИ НЕ ЗначениеЗаполнено(структураДанных.Тип)
			ИЛИ НЕ ЗначениеЗаполнено(структураДанных.Вид)) Тогда
			
			естьНезаполненныеРеквизиты = Истина;
			
		ИначеЕсли "«Паспортные данные физических лиц»" = наименованиеТипа
			И (НЕ ЗначениеЗаполнено(структураДанных.ФизЛицо)
			ИЛИ НЕ ЗначениеЗаполнено(структураДанных.Период)
			ИЛИ НЕ ЗначениеЗаполнено(структураДанных.ДокументВид)
			ИЛИ НЕ ЗначениеЗаполнено(структураДанных.ДокументКемВыдан)
			ИЛИ НЕ ЗначениеЗаполнено(структураДанных.ДокументДатаВыдачи)) Тогда
			
			Если 6 = СтрДлина(структураДанных.ДокументНомер) Тогда
				естьНезаполненныеРеквизиты = НЕ ЗначениеЗаполнено(структураДанных.ДокументСерия);
			ИначеЕсли 9 = СтрДлина(структураДанных.ДокументНомер) Тогда
			Иначе
				естьНезаполненныеРеквизиты = Истина;
			КонецЕсли;
			
		ИначеЕсли "«Схемы налогообложения контрагентов»" = наименованиеТипа
			И (НЕ ЗначениеЗаполнено(структураДанных.Контрагент)
			ИЛИ НЕ ЗначениеЗаполнено(структураДанных.СхемаНалогообложения)) Тогда
			
			естьНезаполненныеРеквизиты = Истина;
			
		ИначеЕсли "«Договоры Контрагентов»" = наименованиеТипа
			И (НЕ ЗначениеЗаполнено(структураДанных.Организация)
			ИЛИ НЕ ЗначениеЗаполнено(структураДанных.Владелец)
			ИЛИ НЕ ЗначениеЗаполнено(структураДанных.Наименование)) Тогда
			
			естьНезаполненныеРеквизиты = Истина;
			
		ИначеЕсли "«Банковские счета»" = наименованиеТипа
			И (НЕ ЗначениеЗаполнено(структураДанных.Владелец)
			ИЛИ НЕ ЗначениеЗаполнено(структураДанных.Банк)
			ИЛИ НЕ ЗначениеЗаполнено(структураДанных.НомерСчета)
			ИЛИ НЕ ЗначениеЗаполнено(структураДанных.ВалютаДенежныхСредств)) Тогда
			
			естьНезаполненныеРеквизиты = Истина;
			
		ИначеЕсли "«Банки»" = наименованиеТипа
			И НЕ ЗначениеЗаполнено(структураДанных.КодПоЕДРПОУ) Тогда
			
			естьНезаполненныеРеквизиты = Истина;
			
		Иначе
			
			естьНезаполненныеРеквизиты = Ложь;
			
		КонецЕсли;
		
		Если естьНезаполненныеРеквизиты Тогда
			СообщениеОтобразить(текстСообщения, СтатусСообщения.Информация);
		КонецЕсли;
		
	Исключение
		
		СообщениеОтобразить(текстСообщения, СтатусСообщения.Внимание);
		естьНезаполненныеРеквизиты = Истина;
		
	КонецПопытки;
	
	Возврат НЕ естьНезаполненныеРеквизиты
	
КонецФункции

Функция вернутьСсылкуГруппыОбъектов(объектМетаданных, структураДанных, создаватьОбъектыЕслиОтсутствуют = Истина)
	
	Перем объект;
	
	Если "Справочник" <> Лев(Тип(объектМетаданных), СтрНайти(Тип(объектМетаданных), " ") - 1)
		ИЛИ ПустаяСтрока(структураДанных.Наименование) Тогда
		Возврат Неопределено
	КонецЕсли;
	
	объект = объектМетаданных.ПустаяСсылка();
	справочникВыборка = объектМетаданных.Выбрать(
		?(структураДанных.Свойство("Родитель"),
			структураДанных.Родитель,
			Неопределено),,
		Новый Структура("Наименование", структураДанных.Наименование));
		
	Пока справочникВыборка.Следующий() цикл
		объект = справочникВыборка.Ссылка;
		Если объект.ЭтоГруппа Тогда Прервать конецЕсли;
	КонецЦикла;

	Если создаватьОбъектыЕслиОтсутствуют
		И (НЕ ЗначениеЗаполнено(объект)
		ИЛИ НЕ объект.ЭтоГруппа) Тогда
		
		объект = объектМетаданных.СоздатьГруппу();
		ЗаполнитьЗначенияСвойств(объект, структураДанных);
		
		Попытка
			объект.Записать();
		Исключение
			ОтобразитьСообщениеОбОшибке(ОписаниеОшибки(), ИнформацияОбОшибке());
			объект = объектМетаданных.ПустаяСсылка();
		КонецПопытки;
		
	КонецЕсли;
	
	Возврат объект
	
КонецФункции

Функция вернутьСсылкуОбъекта(владелецФормы, объектМетаданных, наименованиеТипа, структураДанных,
	структураОтбора = Неопределено, текстСообщенияПриОшибке = "", представлениеОбъекта = "",
	запросСозданияНового = Ложь, записать = Истина, заменять = Ложь,// ToDo: записать, заменять - видалити
	режимДиалогаТолькоПриНеобходимости = Истина, модифицироватьДанные = Истина,
	перемещатьВГруппуЕслиУказана = Ложь)
	
	Перем объектСсылка, объект, ответ, текстСообщения, необходимостьЗаписиОбъекта;
	Перем информацияОбОшибке, естьНезаполненныеРеквизиты;
	
	// Перевірка заповненості даних, необхідних для ідентифікації об`єкта
	
	текстСообщения = НСтр("ru='Отсутствуют необходимые данные объекта'; uk=""Відсутні необхідні дані об'єкта""");
	
	Если НЕ ПустаяСтрока(представлениеОбъекта) Тогда
		текстСообщения = СтрШаблон("%1 %2 «%3»", текстСообщения, наименованиеТипа, представлениеОбъекта);
	КонецЕсли;
	
	текстСообщения = СтрШаблон("%1 %2", текстСообщения, наименованиеТипа);
	
	Если НЕ проверитьЗаполнениеОбязательныхРеквизитовОбъекта(наименованиеТипа, структураДанных, текстСообщения) Тогда возврат Неопределено конецЕсли;
	
	// Вибір об`єкта, якщо вже існує в базі
	
	структураДанных.Вставить("Объект", объектМетаданных);
	
	объектСсылка = ОбъектВыбратьВФорме(владелецФормы, структураДанных, структураОтбора, режимДиалогаТолькоПриНеобходимости);// +++++++++++++++++++++++
	
	Если НЕ модифицироватьДанные Тогда
		структураДанных.Удалить("Объект");
		Возврат объектСсылка
	КонецЕсли;
	
	необходимостьЗаписиОбъекта = Ложь;
	
	Если ЗначениеЗаполнено(объектСсылка) Тогда
		
		объект = объектСсылка.ПолучитьОбъект();
		
		Если объектСсылка.ПометкаУдаления Тогда
			
			Если режимДиалогаТолькоПриНеобходимости Тогда
				
				Если ВопросПолучитьПодтверждение(СтрШаблон(
						НСтр("ru='«%1» - объект помечен на удаление (%2). Снять пометку?'; uk=""«%1» - об'єкт відмічений на вилучення (%2). Зняти помітку?"""),
						Строка(объектСсылка),
						ТипЗнч(объектСсылка)), Ложь) Тогда
					необходимостьЗаписиОбъекта = Истина;
					объект.ПометкаУдаления = Ложь;
				КонецЕсли;
				
			Иначе
				
				СообщениеОтобразить(СтрШаблон(
					НСтр("ru = '«%1» - объект помечен на удаление (%2).'; uk = '«%1» - об''єкт відмічений на вилучення (%2).'"),
					СокрЛП(объектСсылка),
					ТипЗнч(объектСсылка)), СтатусСообщения.Внимание);
					
			КонецЕсли;
			
		КонецЕсли;
		
	Иначе
		
		// Створення нового, якщо не знайдено
		Если НЕ получитьПодтверждениеПользователяОСозданияНовогоОбъектаВИнформационнойБазе(запросСозданияНового, наименованиеТипа, представлениеОбъекта, Ложь) Тогда Возврат Неопределено конецЕсли;
		
		необходимостьЗаписиОбъекта = Истина;
		объект = // +++++++++++++++++++++++
			?("Справочник" = Лев(Тип(объектМетаданных), СтрНайти(Тип(объектМетаданных), " ") - 1),
			объектМетаданных.СоздатьЭлемент(),
			объектМетаданных.СоздатьДокумент());
			
	КонецЕсли;
	
	текстСообщения = НСтр("ru='Ошибка во время заполнения свойств типа '; uk='Помилка під час заповнення властивостей типу '") + ТипЗнч(объект) + " - «" + Строка(объект) + "»";
	
	Попытка
		
		Если модифицироватьДанные Тогда
			
			Если объект.ЭтоНовый() Тогда
				
				ЗаполнитьЗначенияСвойств(объект, структураДанных);
				
			Иначе
				
				Если структураДанных.Свойство("Родитель")
					И ЗначениеЗаполнено(структураДанных.Родитель)
					И перемещатьВГруппуЕслиУказана Тогда
					объект.Родитель = структураДанных.Родитель;
					необходимостьЗаписиОбъекта = Истина;
				КонецЕсли;
				
				Для Каждого ключЗначение из структураДанных цикл
					Если "Объект" = ключЗначение.Ключ ИЛИ "Родитель" = ключЗначение.Ключ Тогда Продолжить конецЕсли;
					Если объект[ключЗначение.Ключ] = ключЗначение.Значение Тогда Продолжить конецЕсли;
					объект[ключЗначение.Ключ] = ключЗначение.Значение;
					необходимостьЗаписиОбъекта = Истина;
				КонецЦикла;
				
			КонецЕсли;
			
		КонецЕсли;
		
	Исключение
		
		#Если Клиент Тогда
		
		Сообщить(текстСообщения, СтатусСообщения.Внимание);
		
		информацияОбОшибке = ИнформацияОбОшибке();
		
		Если информацияОбОшибке.Причина <> Неопределено Тогда
			Сообщить(информацияОбОшибке.Причина.Описание, СтатусСообщения.Информация);
		КонецЕсли;
		
		#КонецЕсли
		
	КонецПопытки;
	
	Если записать И необходимостьЗаписиОбъекта Тогда
		объектСсылка = ОбъектЗаписатьПолучитьСсылку(объект, структураДанных, текстСообщенияПриОшибке, Ложь);
	КонецЕсли;
	
	структураДанных.Удалить("Объект");
	
	Возврат объектСсылка
	
КонецФункции

Функция получитьПодтверждениеПользователяОСозданияНовогоОбъектаВИнформационнойБазе(запросСозданияНового,
	наименованиеТипа = "", представлениеОбъекта = "", заменять = Истина)
	Перем ответ, текстСообщения;
	
	Если заменять Тогда
		текстСообщения = НСтр("ru='Подтверждаете замену существующего объекта в информационной базе '; uk=""Підтверджуєте заміну існуючого об'єкта в інформаційній базі""");
	Иначе
		текстСообщения = НСтр("ru='Подтверждаете создание в информационной базе нового объекта'; uk=""Підтверджуєте створення в інформаційній базі нового об'єкта""");
	КонецЕсли;
	
	Если НЕ ПустаяСтрока(представлениеОбъекта) Тогда
		текстСообщения = текстСообщения + " «" + представлениеОбъекта + " »";
	КонецЕсли;
	
	Если ПустаяСтрока(наименованиеТипа) Тогда
		текстСообщения = текстСообщения + "?";
	Иначе
		текстСообщения = текстСообщения + НСтр("ru=' типа '; uk="" типу """) + наименованиеТипа + "?";
	КонецЕсли;
	
	ответ = Истина;
	
	Возврат ответ
	
КонецФункции

Процедура табличныйДокументОпределитьГруппировкуСтроки(табличныйДокумент, областьМакета, строка, коллекцияКолонокТаблицы, списокГруппировок, переченьГруппировок)
	
	Перем группировка, уровеньГруппировки, счетчикКолонок;
	
	Для Каждого группировка из списокГруппировок цикл
		
		Если строка[группировка.Представление] = группировка.Значение Тогда
			
			строка[группировка.Представление] = "";
			
			Продолжить
			
		Иначе
			
			////////////////////////////////// Закрити вкладені групи //////////////////////////////////
			
			Если группировка.Значение <> Неопределено Тогда
				
				уровеньГруппировки = списокГруппировок.Индекс(списокГруппировок.НайтиПоЗначению(группировка.Значение));
				
				Пока уровеньГруппировки < списокГруппировок.Количество() цикл
					
					табличныйДокумент.ЗакончитьГруппуСтрок();
					
					списокГруппировок.Получить(уровеньГруппировки).Значение = Неопределено;
					
					уровеньГруппировки = уровеньГруппировки + 1;
				КонецЦикла;
				
			КонецЕсли;
			
			группировка.Значение = строка[группировка.Представление];
			
			Если ПустаяСтрока(группировка.Значение) Тогда Возврат конецЕсли;
			
		КонецЕсли;
		
		////////////////////////////////// Вивести стрічку заголовка нової групи //////////////////////////////////
		
		счетчикКолонок = 1;
		
		Для Каждого колонка из коллекцияКолонокТаблицы цикл
			
			ячейка = областьМакета.Область("R1C" + Строка(счетчикКолонок));
			
			Если колонка.Имя = группировка.Представление Тогда
				
				ячейка.Текст = СокрЛП(Строка(строка[колонка.Имя]));
				
			ИначеЕсли Найти(переченьГруппировок, колонка.Имя) = 0 Тогда
				
				ячейка.Текст = "";
				
			КонецЕсли;
			
			табличноеПолеОформитьВнешнийВидЯчейки(ячейка, "Группа");
			
			счетчикКолонок = счетчикКолонок + 1;
			
		КонецЦикла;
		
		табличныйДокумент.Вывести(областьМакета);
		
		////////////////////////////////// Розкрити нову групу //////////////////////////////////
		
		табличныйДокумент.НачатьГруппуСтрок(группировка.Представление + ": " + группировка.Значение, группировка.Пометка);
		
		строка[группировка.Представление] = "";
		
	КонецЦикла;
	
КонецПроцедуры

Процедура табличноеПолеОформитьВнешнийВидЯчейки(ячейка, типОформления = "")
	Перем линия1, линия2;
	
	ячейка.ВертикальноеПоложение = ВертикальноеПоложение.Центр;
	
	линия1 = Новый Линия(ТипЛинииЯчейкиТабличногоДокумента.Сплошная, 1);
	линия2 = Новый Линия(ТипЛинииЯчейкиТабличногоДокумента.Сплошная, 2);
	
	ячейка.ВыделятьОтрицательные = Истина;
	ячейка.РежимИзмененияРазмераКолонки = РежимИзмененияРазмера.БыстроеИзменение;
	
	Если типОформления = "Заголовок" Тогда
		ячейка.Шрифт = Новый Шрифт(, 8, Истина, Ложь, Ложь, Ложь);
		ячейка.ЦветТекста = WebЦвета.КожаноКоричневый;
		ячейка.ЦветФона = WebЦвета.ЗамшаСветлый;
		ячейка.ГоризонтальноеПоложение = ГоризонтальноеПоложение.Центр;
		ячейка.Обвести(линия1, линия2, линия1, линия2);
		
	ИначеЕсли типОформления = "Группа" Тогда
		ячейка.Шрифт = Новый Шрифт(, 8, Истина, Ложь, Ложь, Ложь);
		ячейка.ЦветТекста = WebЦвета.ГрифельноСерый;
		ячейка.ЦветФона = WebЦвета.ТопленоеМолоко;
		ячейка.ГоризонтальноеПоложение = ГоризонтальноеПоложение.Право;
		ячейка.Обвести(линия1, линия1, линия1, линия1);
		
	ИначеЕсли типОформления = "Итог" Тогда
		ячейка.Шрифт = Новый Шрифт(, 8, Истина, Ложь, Ложь, Ложь);
		ячейка.ЦветТекста = WebЦвета.Персиковый;
		ячейка.ЦветФона = WebЦвета.Охра;
		ячейка.ГоризонтальноеПоложение = ГоризонтальноеПоложение.Право;
		ячейка.Обвести(линия1, линия2, линия1, линия2);
		
	ИначеЕсли типОформления = "Запись" Тогда
		ячейка.Шрифт = Новый Шрифт(, 8, Ложь, Ложь, Ложь, Ложь);
		ячейка.ЦветТекста = ЦветаСтиля.ЦветТекстаПоля;
		ячейка.ЦветФона = ЦветаСтиля.ЦветФонаПоля;
		ячейка.ГоризонтальноеПоложение = ГоризонтальноеПоложение.Авто;
		ячейка.Обвести(линия1,, линия1, линия1);
		
	ИначеЕсли типОформления = "ВерхняяТолстаяЛиния" Тогда
		ячейка.Обвести(, линия2);
		
	Иначе
		ячейка.Шрифт = Новый Шрифт(, 8, Ложь, Ложь, Ложь, Ложь);
		ячейка.ЦветТекста = ЦветаСтиля.ЦветТекстаПоля;
		ячейка.ЦветФона = ЦветаСтиля.ЦветФонаПоля;
		ячейка.ГоризонтальноеПоложение = ГоризонтальноеПоложение.Авто;
		ячейка.Обвести(линия1,, линия1, линия1);
	КонецЕсли;
	
КонецПроцедуры

Процедура регистрУстановитьОтбор(регистрНаборЗаписей, структураДанных, структураОтбора = Неопределено)
	
	Перем элемент;
	
	Если структураОтбора <> Неопределено Тогда
		
		Для Каждого элемент из структураОтбора цикл
			регистрУстановитьЭлементОтбора(регистрНаборЗаписей, элемент.Ключ, структураДанных, структураОтбора);
		КонецЦикла;
		
	Иначе
		
		регистрУстановитьЭлементОтбора(регистрНаборЗаписей, "Объект", структураДанных, структураОтбора);
		регистрУстановитьЭлементОтбора(регистрНаборЗаписей, "Владелец", структураДанных, структураОтбора);
		регистрУстановитьЭлементОтбора(регистрНаборЗаписей, "ТипКонтактнойИнформации", структураДанных, структураОтбора);
		регистрУстановитьЭлементОтбора(регистрНаборЗаписей, "ВидКонтактнойИнформации", структураДанных, структураОтбора);
		регистрУстановитьЭлементОтбора(регистрНаборЗаписей, "Штрихкод", структураДанных, структураОтбора);
		
	КонецЕсли;
	
КонецПроцедуры

Процедура формаУстановитьОтборДляВыбора(форма, структураДанных, структураОтбора = Неопределено)
	
	Перем элемент;
	
	Если структураОтбора <> Неопределено Тогда
		
		Для Каждого элемент из структураОтбора цикл
			Если НЕ структураДанных.Свойство(элемент.Ключ) Тогда Продолжить конецЕсли;
			формаУстановитьЭлементОтбора(форма, элемент.Ключ, ТипЗнч(структураДанных[элемент.Ключ]), структураДанных, структураОтбора);
		КонецЦикла;
		
	Иначе
		
		формаУстановитьЭлементОтбора(форма, "Наименование", ТипЗнч("Строка"), структураДанных, структураОтбора);
		формаУстановитьЭлементОтбора(форма, "ВладелецКарты", Неопределено, структураДанных, структураОтбора);
		формаУстановитьЭлементОтбора(форма, "КодКарты", ТипЗнч("Строка"), структураДанных, структураОтбора);
		
	КонецЕсли;
	
КонецПроцедуры

Процедура регистрУстановитьЭлементОтбора(регистрНаборЗаписей, имяСвойства, структураДанных, структураОтбора = Неопределено)
	
	Перем использование;
	
	Если структураОтбора = Неопределено Тогда
		
		использование = Истина;
		
	ИначеЕсли структураДанных[имяСвойства] <> Неопределено
		И структураОтбора <> Неопределено
		И структураОтбора.Свойство(имяСвойства) Тогда
		
		Если структураОтбора[имяСвойства] = Ложь Тогда
			использование = Ложь;
		Иначе
			использование = Истина;
		КонецЕсли;
		
	Иначе
		
		использование = Неопределено;
		
	КонецЕсли;
	
	Если использование <> Неопределено Тогда
		
		Попытка
			регистрНаборЗаписей.Отбор[имяСвойства].Установить(структураДанных[имяСвойства]);
			регистрНаборЗаписей.Отбор[имяСвойства].Использование = использование;
		Исключение
			Если структураОтбора <> Неопределено Тогда
				ОтобразитьСообщениеОбОшибке(ОписаниеОшибки(), ИнформацияОбОшибке());
			КонецЕсли;
		КонецПопытки;
		
	КонецЕсли;
	
КонецПроцедуры

Процедура формаУстановитьЭлементОтбора(форма, имяСвойства, типЗначенияСвойства = Неопределено, структураДанных, структураОтбора = Неопределено)
	
	Если структураОтбора = Неопределено Тогда
		использование = Истина;
	ИначеЕсли
		структураДанных[имяСвойства] <> Неопределено
		И структураОтбора <> Неопределено
		И структураОтбора.Свойство(имяСвойства) Тогда
		использование =
			?(структураОтбора[имяСвойства] = Неопределено,
			ЗначениеЗаполнено(структураДанных[имяСвойства]),
			ЗначениеЗаполнено(структураОтбора[имяСвойства]));
	Иначе
		использование = Неопределено;
	КонецЕсли;
	
	Если использование <> Неопределено Тогда
		
		Попытка
			
			элементОтбора = форма.Отбор[имяСвойства];
			
			Если структураОтбора[имяСвойства] = Неопределено ИЛИ структураОтбора[имяСвойства] = Ложь Тогда
				элементОтбора.ВидСравнения = ВидСравнения.Равно;
			Иначе
				элементОтбора.ВидСравнения = структураОтбора[имяСвойства];
			КонецЕсли;
			
			Если типЗначенияСвойства = Тип("Строка") Тогда
				элементОтбора.Значение = Строка(структураДанных[имяСвойства]);
			ИначеЕсли типЗначенияСвойства = Тип("Число") Тогда
				элементОтбора.Значение = Число(структураДанных[имяСвойства]);
			Иначе
				элементОтбора.Значение = структураДанных[имяСвойства];
			КонецЕсли;
			
			элементОтбора.Использование = использование;
			
		Исключение
			
			Если структураОтбора <> Неопределено Тогда
				ОтобразитьСообщениеОбОшибке(ОписаниеОшибки(), ИнформацияОбОшибке());
			КонецЕсли;
			
		КонецПопытки;
		
	КонецЕсли;
	
КонецПроцедуры

Процедура формаУстановитьПараметрыПросмотраДляВыбора(форма, заголовокФормы)
	
	#Если Клиент Тогда
	
	Если НЕ ПустаяСтрока(заголовокФормы) Тогда
		форма.Заголовок = заголовокФормы;
	КонецЕсли;
	
	форма.РазрешитьСоединятьОкно = Истина;
	форма.РазрешитьСостояниеПрикрепленное = Истина;
	
	форма.СоединяемоеОкно = Истина;
	форма.СостояниеОкна = ВариантСостоянияОкна.Прикрепленное;
	форма.ПоложениеПрикрепленногоОкна = ВариантПрикрепленияОкна.Право;
	
	форма.РазрешитьСостояниеОбычное = Истина;
	форма.РазрешитьСостояниеПрячущееся = Ложь;//
	форма.РазрешитьСостояниеСвободное = Ложь;
	
	форма.ИзменятьСпособОтображенияОкна = ИзменениеСпособаОтображенияОкна.Разрешить;
	форма.РазрешитьЗакрытие = Истина;
	
	форма.РежимВыбора = Истина;
	форма.ЗакрыватьПриВыборе = Истина;
	форма.МножественныйВыбор = Ложь;
	
	Если РеквизитОбъектаПроверитьНаличие(форма, "ПараметрВыборГруппИЭлементов") Тогда
		форма.ПараметрВыборГруппИЭлементов = ИспользованиеГруппИЭлементов.Элементы;
	КонецЕсли;
	
	Если РеквизитОбъектаПроверитьНаличие(форма, "СправочникСписок") Тогда
		форма.ЭлементыФормы.СправочникСписок.ИерархическийПросмотр = Ложь;
	КонецЕсли;
	
	#КонецЕсли
	
КонецПроцедуры

#КонецОбласти




EndToDo

ToDo

EndToDo